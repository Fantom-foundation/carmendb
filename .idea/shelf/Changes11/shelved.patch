Index: go/state/state_db.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\n// Deprecated: external users should switch to the carmen package as the new top-level API\npackage state\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"maps\"\n\t\"math/big\"\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n)\n\n//go:generate mockgen -source state_db.go -destination state_db_mock.go -package state\n\n// VmStateDB defines the basic operations that can be conducted on a StateDB as\n// required by an EVM implementation.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype VmStateDB interface {\n\t// Account management.\n\tCreateAccount(common.Address)\n\tExist(common.Address) bool\n\tEmpty(common.Address) bool\n\n\tSuicide(common.Address) bool\n\tHasSuicided(common.Address) bool\n\n\t// Balance\n\tGetBalance(common.Address) *big.Int\n\tAddBalance(common.Address, *big.Int)\n\tSubBalance(common.Address, *big.Int)\n\n\t// Nonce\n\tGetNonce(common.Address) uint64\n\tSetNonce(common.Address, uint64)\n\n\t// Read and update storage.\n\tGetCommittedState(common.Address, common.Key) common.Value\n\tGetState(common.Address, common.Key) common.Value\n\tSetState(common.Address, common.Key, common.Value)\n\tGetTransientState(common.Address, common.Key) common.Value\n\tSetTransientState(common.Address, common.Key, common.Value)\n\n\t// Code management.\n\tGetCode(common.Address) []byte\n\tSetCode(common.Address, []byte)\n\tGetCodeHash(common.Address) common.Hash\n\tGetCodeSize(common.Address) int\n\n\t// Refund tracking.\n\tAddRefund(uint64)\n\tSubRefund(uint64)\n\tGetRefund() uint64\n\n\t// Log management:\n\t// AddLog adds a log into the current transaction.\n\tAddLog(*common.Log)\n\t// GetLogs provides logs produced in the current transaction.\n\tGetLogs() []*common.Log\n\n\t// Access list tracking.\n\tClearAccessList()\n\tAddAddressToAccessList(common.Address)\n\tAddSlotToAccessList(common.Address, common.Key)\n\tIsAddressInAccessList(common.Address) bool\n\tIsSlotInAccessList(common.Address, common.Key) (addressPresent bool, slotPresent bool)\n\n\t// Transaction scope management.\n\tSnapshot() int\n\tRevertToSnapshot(int)\n\n\tBeginTransaction()\n\tEndTransaction()\n\n\t// GetTransactionChanges provides a set of accounts and their slots, which have been\n\t// potentially changed in the current transaction.\n\t// Must be called before EndTransaction call.\n\tGetTransactionChanges() map[common.Address][]common.Key\n\n\t// Deprecated: not necessary, to be removed\n\tAbortTransaction()\n\n\t// GetHash obtains a cryptographically unique hash of the committed state.\n\tGetHash() common.Hash\n\n\t// Check checks the state of the DB and reports an error if issues have been\n\t// encountered. Check should be called periodically to validate all interactions\n\t// with a StateDB instance. If an error is reported, all operations since the\n\t// last successful check need to be considered invalid.\n\tCheck() error\n}\n\n// StateDB serves as the public interface definition of a Carmen StateDB.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype StateDB interface {\n\tVmStateDB\n\n\tBeginBlock()\n\tEndBlock(number uint64)\n\n\tBeginEpoch()\n\tEndEpoch(number uint64)\n\n\t// Flushes committed state to disk.\n\t// Deprecated: these methods shuold not be called, one statedb inst should not close/flush global databsae\n\tFlush() error\n\tClose() error\n\n\t// StartBulkLoad initiates a bulk load operation by-passing internal caching and\n\t// snapshot, transaction, block, or epoch handling to support faster initialization\n\t// of StateDB instances. All updates of a bulk-load call are committed to the DB\n\t// as a single block with the given block number. Bulk-loads may only be started\n\t// outside the scope of any block.\n\tStartBulkLoad(block uint64) BulkLoad\n\n\t// GetArchiveStateDB provides a historical state view for given block.\n\t// An error is returned if the archive is not enabled or if it is empty.\n\tGetArchiveStateDB(block uint64) (NonCommittableStateDB, error)\n\n\t// GetArchiveBlockHeight provides the last block height available in the archive.\n\t// An empty archive is signaled by an extra return value. An error is returned if the\n\t// archive is not enabled or some other issue has occurred.\n\tGetArchiveBlockHeight() (height uint64, empty bool, err error)\n\n\t// GetMemoryFootprint computes an approximation of the memory used by this state.\n\tGetMemoryFootprint() *common.MemoryFootprint\n\n\tResetBlockContext()\n}\n\n// NonCommittableStateDB is the public interface offered for views on states that can not\n// be permanently modified. The prime example for those are views on historic blocks backed\n// by an archive. While volatile transaction internal changes are supported, there is no\n// way offered for committing those.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype NonCommittableStateDB interface {\n\tVmStateDB\n\n\t// Copy creates a copy of the StateDB, including all uncommitted changes.\n\t// Should be used only in-between transactions, as the tx context is not copied.\n\t// Any change to the copy does not affect the original StateDB, except the state caches.\n\t// Available for non-committable states only, as a commit to the backing state\n\t// makes all other StateDBs with the same backing state invalid.\n\tCopy() NonCommittableStateDB\n\n\t// Release should be called whenever this instance is no longer needed to allow\n\t// held resources to be reused for future requests. After the release, no more\n\t// operations may be conducted on this StateDB instance.\n\tRelease()\n}\n\n// BulkLoad serves as the public interface for loading preset data into the state DB.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype BulkLoad interface {\n\tCreateAccount(common.Address)\n\tSetBalance(common.Address, *big.Int)\n\tSetNonce(common.Address, uint64)\n\tSetState(common.Address, common.Key, common.Value)\n\tSetCode(common.Address, []byte)\n\tClose() error\n}\n\n// stateDB is the internal implementation of the StateDB interface.\ntype stateDB struct {\n\t// The underlying state data is read/written to.\n\tstate State\n\n\t// A transaction local cache for account states to avoid double-fetches and support rollbacks.\n\taccounts map[common.Address]*accountState\n\n\t// A transaction local cache of balances to avoid double-fetches and support rollbacks.\n\tbalances map[common.Address]*balanceValue\n\n\t// A transaction local cache of nonces to avoid double-fetches and support rollbacks.\n\tnonces map[common.Address]*nonceValue\n\n\t// A transaction local cache of storage values to avoid double-fetches and support rollbacks.\n\tdata *common.FastMap[slotId, *slotValue]\n\n\t// Transient storage is a temporary storage that gets deleted after each transaction.\n\ttransientStorage *common.FastMap[slotId, common.Value]\n\n\t// A transaction local cache of contract codes and their properties.\n\tcodes map[common.Address]*codeValue\n\n\t// A list of accounts to be deleted at the end of the transaction.\n\taccountsToDelete []common.Address\n\n\t// Tracks the clearing state of individual accounts.\n\tclearedAccounts map[common.Address]accountClearingState\n\n\t// A list of operations undoing modifications applied on the inner state if a snapshot revert needs to be performed.\n\tundo []func()\n\n\t// The refund accumulated in the current transaction.\n\trefund uint64\n\n\t// The list of log messages recorded for the current transaction.\n\tlogs []*common.Log\n\n\t// The amount of logs in the current block.\n\tlogsInBlock uint\n\n\t// A set of accessed addresses in the current transaction.\n\taccessedAddresses map[common.Address]bool\n\n\t// A set of accessed slots in the current transaction.\n\taccessedSlots *common.FastMap[slotId, bool]\n\n\t// A set of slots with current value (possibly) different from the committed value - for needs of committing.\n\twrittenSlots map[*slotValue]bool\n\n\t// A non-transactional local cache of stored storage values.\n\tstoredDataCache *common.LruCache[slotId, storedDataCacheValue]\n\n\t// A non-transactional reincarnation counter for accounts. This is used to efficiently invalidate data in\n\t// the storedDataCache upon account deletion. The maintained values are internal information only.\n\treincarnation map[common.Address]uint64\n\n\t// A list of addresses, which have possibly become empty in the transaction\n\temptyCandidates []common.Address\n\n\t// True, if this state DB is allowed to apply changes to the underlying state, false otherwise.\n\tcanApplyChanges bool\n\n\t// A list of errors encountered during DB interactions.\n\terrors []error\n}\n\ntype accountLifeCycleState int\n\n// The life-cycle states of an account as seen by the StateDB\n//  - unknown     ... the state has not been fetched from the DB; only valid for the original field in the account state\n//  - NonExisting ... the account is known to not exist\n//  - Exists      ... the account is known to exist\n//  - Suicided    ... the account existed during the current transaction, but suicided\n//\n// The following transitions are allowed:\n//\n//    Unknown -- Load --> NonExisting\n//    Unknown -- Load --> Exists\n//\n//    NonExisting -- CreateAccount --> Exists\n//\n//    Exists -- CreateAccount --> Exists\n//    Exists -- Suicide --> Suicided\n//    Exists -- EndTransaction --> NonExisting    // if account was empty\n//\n//    Suicided -- CreateAccount --> Exists\n//    Suicided -- EndTransaction --> NonExisting\n//\n// Accounts with the state Suicided can only exist during a transaction. At the end of a\n// transaction, Suicided accounts transition automatically into NonExisting accounts.\n\nconst (\n\taccountNonExisting    accountLifeCycleState = 1\n\taccountExists         accountLifeCycleState = 2\n\taccountSelfDestructed accountLifeCycleState = 3\n)\n\nfunc (s accountLifeCycleState) String() string {\n\tswitch s {\n\tcase accountNonExisting:\n\t\treturn \"NonExisting\"\n\tcase accountExists:\n\t\treturn \"Exists\"\n\tcase accountSelfDestructed:\n\t\treturn \"Suicided\"\n\t}\n\treturn \"?\"\n}\n\n// accountState maintains the state of an account during a transaction.\ntype accountState struct {\n\t// The committed account state, set to kUnknown if never fetched.\n\toriginal accountLifeCycleState\n\t// The current account state visible to the state DB users.\n\tcurrent accountLifeCycleState\n}\n\ntype accountClearingState int\n\nconst (\n\t// noClearing is the state of an account not be to cleared (make sure this has the default value 0)\n\tnoClearing accountClearingState = 0\n\t// pendingClearing is the state of an account that is scheduled for clearing at the end of the current transaction but should still appear like it exists.\n\tpendingClearing accountClearingState = 1\n\t// cleared is the state of an account that should appear as it has been cleared.\n\tcleared accountClearingState = 2\n\t// same as cleared, but some SetState has been invoked on the account after its cleaning. So the cached state may be tainted.\n\tclearedAndTainted accountClearingState = 3\n)\n\nfunc (s accountClearingState) String() string {\n\tswitch s {\n\tcase noClearing:\n\t\treturn \"noClearing\"\n\tcase pendingClearing:\n\t\treturn \"pendingClearing\"\n\tcase cleared:\n\t\treturn \"cleared\"\n\tcase clearedAndTainted:\n\t\treturn \"clearedAndTainted\"\n\t}\n\treturn \"?\"\n}\n\n// balanceVale maintains a balance during a transaction.\ntype balanceValue struct {\n\t// The committed balance of an account, missing if never fetched.\n\toriginal *big.Int\n\t// The current value of the account balance visible to the state DB users.\n\tcurrent big.Int\n}\n\n// nonceValue maintains a nonce during a transaction.\ntype nonceValue struct {\n\t// The committed nonce of an account, missing if never fetched.\n\toriginal *uint64\n\t// The current nonce of an account visible to the state DB users.\n\tcurrent uint64\n}\n\n// slotId identifies a storage location.\ntype slotId struct {\n\taddr common.Address\n\tkey  common.Key\n}\n\ntype slotHasher struct{}\n\nfunc (h slotHasher) Hash(id slotId) uint16 {\n\treturn uint16(id.addr[19])<<8 | uint16(id.key[31])\n}\n\nfunc (s *slotId) Compare(other *slotId) int {\n\tc := s.addr.Compare(&other.addr)\n\tif c < 0 {\n\t\treturn -1\n\t}\n\tif c > 0 {\n\t\treturn 1\n\t}\n\treturn s.key.Compare(&other.key)\n}\n\n// slotValue maintains the value of a slot.\ntype slotValue struct {\n\t// The value in the DB, missing if never fetched.\n\tstored common.Value\n\t// The value committed by the last completed transaction.\n\tcommitted common.Value\n\t// The current value as visible to the state DB users.\n\tcurrent common.Value\n\t// Whether the stored value is known.\n\tstoredKnown bool\n\t// Whether the committed value is known.\n\tcommittedKnown bool\n}\n\n// codeValue maintains the code associated to a given address.\ntype codeValue struct {\n\tcode      []byte\n\tsize      int\n\thash      *common.Hash\n\tdirty     bool // < set if code has been updated in transaction\n\tcodeValid bool // < set if code is loaded from the state (or written as dirty)\n\tsizeValid bool // < set if size is loaded from the state (or written as dirty)\n}\n\nconst defaultStoredDataCacheSize = 1000000 // ~ 100 MiB of memory for this cache.\nconst nonCommittableStoredDataCacheSize = 100\n\n// storedDataCacheValue maintains the cached version of a value in the store. To\n// support the efficient clearing of values cached for accounts being deleted, an\n// additional account reincarnation counter is added.\ntype storedDataCacheValue struct {\n\tvalue         common.Value // < the cached version of the value in the store\n\treincarnation uint64       // < the reincarnation the cached value belongs to\n}\n\n// CreateStateDBUsing creates a StateDB instance wrapping the given state supporting\n// all operations including end-of-block operations mutating the underlying state.\n// Note: any StateDB instanced becomes invalid if the underlying state is\n// modified by any other StateDB instance or through any other direct modification.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\nfunc CreateStateDBUsing(state State) StateDB {\n\treturn CreateCustomStateDBUsing(state, defaultStoredDataCacheSize)\n}\n\n// CreateCustomStateDBUsing is the same as CreateStateDBUsing but allows the caller to specify\n// the capacity of the stored Data cache used in the resulting instance. The default\n// cache size used by CreateCustomStateDBUsing may be too large if StateDB instances\n// only have a short live time. In such cases, the initialization and destruction of\n// the maintained data cache may dominate execution time.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\nfunc CreateCustomStateDBUsing(state State, storedDataCacheSize int) StateDB {\n\tif storedDataCacheSize <= 0 {\n\t\tstoredDataCacheSize = defaultStoredDataCacheSize\n\t}\n\treturn createStateDBWith(state, storedDataCacheSize, true)\n}\n\n// CreateNonCommittableStateDBUsing creates a read-only StateDB instance wrapping\n// the given state supporting all operations specified by the VmStateDB interface.\n// Note: any StateDB instanced becomes invalid if the underlying state is\n// modified by any other StateDB instance or through any other direct modification.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\nfunc CreateNonCommittableStateDBUsing(state State) NonCommittableStateDB {\n\t// Since StateDB instances are big objects costly to create we reuse those using\n\t// a pool of objects. However, instances need to be properly reset.\n\tdb := nonCommittableStateDbPool.Get().(*stateDB)\n\tdb.resetState(state)\n\treturn &nonCommittableStateDB{db}\n}\n\nfunc createStateDBWith(state State, storedDataCacheCapacity int, canApplyChanges bool) *stateDB {\n\treturn &stateDB{\n\t\tstate:             state,\n\t\taccounts:          map[common.Address]*accountState{},\n\t\tbalances:          map[common.Address]*balanceValue{},\n\t\tnonces:            map[common.Address]*nonceValue{},\n\t\tdata:              common.NewFastMap[slotId, *slotValue](slotHasher{}),\n\t\ttransientStorage:  common.NewFastMap[slotId, common.Value](slotHasher{}),\n\t\tstoredDataCache:   common.NewLruCache[slotId, storedDataCacheValue](storedDataCacheCapacity),\n\t\treincarnation:     map[common.Address]uint64{},\n\t\tcodes:             map[common.Address]*codeValue{},\n\t\trefund:            0,\n\t\taccessedAddresses: map[common.Address]bool{},\n\t\taccessedSlots:     common.NewFastMap[slotId, bool](slotHasher{}),\n\t\twrittenSlots:      map[*slotValue]bool{},\n\t\taccountsToDelete:  make([]common.Address, 0, 100),\n\t\tundo:              make([]func(), 0, 100),\n\t\tclearedAccounts:   make(map[common.Address]accountClearingState),\n\t\temptyCandidates:   make([]common.Address, 0, 100),\n\t\tcanApplyChanges:   canApplyChanges,\n\t}\n}\n\nfunc (s *stateDB) setAccountState(addr common.Address, state accountLifeCycleState) {\n\ts.Exist(addr) // < make sure s.accounts[addr] is initialized\n\tval, exists := s.accounts[addr]\n\t// exists will be false when calling s.Exists() did not succeed\n\tif !exists || val.current == state {\n\t\treturn\n\t}\n\toldState := val.current\n\tval.current = state\n\ts.undo = append(s.undo, func() {\n\t\tval.current = oldState\n\t})\n}\n\nfunc (s *stateDB) Exist(addr common.Address) bool {\n\tif val, exists := s.accounts[addr]; exists {\n\t\treturn val.current == accountExists || val.current == accountSelfDestructed // self-destructed accounts still exist till the end of the transaction.\n\t}\n\texists, err := s.state.Exists(addr)\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to get account state for %v: %w\", addr, err))\n\t\treturn false\n\t}\n\tstate := accountNonExisting\n\tif exists {\n\t\tstate = accountExists\n\t}\n\ts.accounts[addr] = &accountState{\n\t\toriginal: state,\n\t\tcurrent:  state,\n\t}\n\treturn exists\n}\n\nfunc (s *stateDB) CreateAccount(addr common.Address) {\n\ts.setNonceInternal(addr, 0)\n\ts.setCodeInternal(addr, []byte{})\n\n\texists := s.Exist(addr)\n\ts.setAccountState(addr, accountExists)\n\n\t// Created because touched - will be deleted at the end of the transaction if it stays empty\n\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\n\t// Initialize the balance with 0, unless the account existed before.\n\t// Thus, accounts previously marked as unknown (default) or deleted\n\t// will get their balance reset. In particular, deleted accounts that\n\t// are restored will have an empty balance. However, for accounts that\n\t// already existed before this create call the balance is preserved.\n\tif !exists {\n\t\ts.resetBalance(addr)\n\t}\n\n\t// Reset storage of the account, to purge any potential former values.\n\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\tif slot.addr == addr {\n\t\t\t// Support rollback of account creation.\n\t\t\tbackup := *value\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\t*value = backup\n\t\t\t})\n\n\t\t\t// Clear cached values.\n\t\t\tvalue.stored = common.Value{}\n\t\t\tvalue.storedKnown = true\n\t\t\tvalue.committed = common.Value{}\n\t\t\tvalue.committedKnown = true\n\t\t\tvalue.current = common.Value{}\n\t\t}\n\t})\n\n\t// Mark account to be treated like if was already committed.\n\toldState := s.clearedAccounts[addr]\n\ts.clearedAccounts[addr] = cleared\n\ts.undo = append(s.undo, func() {\n\t\ts.clearedAccounts[addr] = oldState\n\t})\n}\n\nfunc (s *stateDB) createAccountIfNotExists(addr common.Address) bool {\n\tif s.Exist(addr) {\n\t\treturn false\n\t}\n\ts.setAccountState(addr, accountExists)\n\n\t// Initialize the balance with 0, unless the account existed before.\n\t// Thus, accounts previously marked as unknown (default) or deleted\n\t// will get their balance reset. In particular, deleted accounts that\n\t// are restored will have an empty balance. However, for accounts that\n\t// already existed before this create call the balance is preserved.\n\ts.resetBalance(addr)\n\n\treturn true\n}\n\n// Suicide marks the given account as suicided.\n// This clears the account balance.\n// The account still exist until the state is committed.\nfunc (s *stateDB) Suicide(addr common.Address) bool {\n\tif !s.Exist(addr) {\n\t\treturn false\n\t}\n\n\ts.setAccountState(addr, accountSelfDestructed)\n\n\ts.resetBalance(addr)\n\tdeleteListLength := len(s.accountsToDelete)\n\ts.accountsToDelete = append(s.accountsToDelete, addr)\n\ts.undo = append(s.undo, func() {\n\t\ts.accountsToDelete = s.accountsToDelete[0:deleteListLength]\n\t})\n\n\t// Mark account for clearing to plan its removing on commit and\n\t// to avoid fetching new data into the cache during the ongoing block.\n\toldState := s.clearedAccounts[addr]\n\tif oldState == noClearing {\n\t\ts.clearedAccounts[addr] = pendingClearing\n\t\ts.undo = append(s.undo, func() {\n\t\t\ts.clearedAccounts[addr] = oldState\n\t\t})\n\t}\n\n\treturn true\n}\n\nfunc (s *stateDB) HasSuicided(addr common.Address) bool {\n\tstate := s.accounts[addr]\n\treturn state != nil && state.current == accountSelfDestructed\n}\n\nfunc (s *stateDB) Empty(addr common.Address) bool {\n\t// Defined as balance == nonce == code == 0\n\treturn s.GetBalance(addr).Sign() == 0 && s.GetNonce(addr) == 0 && s.GetCodeSize(addr) == 0\n}\n\nfunc clone(val *big.Int) *big.Int {\n\tres := new(big.Int)\n\tres.Set(val)\n\treturn res\n}\n\nfunc (s *stateDB) GetBalance(addr common.Address) *big.Int {\n\t// Check cache first.\n\tif val, exists := s.balances[addr]; exists {\n\t\treturn clone(&val.current) // Do not hand out a pointer to the internal copy!\n\t}\n\t// Since the value is not present, we need to fetch it from the store.\n\tbalance, err := s.state.GetBalance(addr)\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to load balance for address %v: %w\", addr, err))\n\t\treturn new(big.Int) // We need to return something that allows the VM to continue.\n\t}\n\tres := balance.ToBigInt()\n\ts.balances[addr] = &balanceValue{\n\t\toriginal: res,\n\t\tcurrent:  *res,\n\t}\n\treturn clone(res) // Do not hand out a pointer to the internal copy!\n}\n\nfunc (s *stateDB) AddBalance(addr common.Address, diff *big.Int) {\n\ts.createAccountIfNotExists(addr)\n\n\tif diff == nil || diff.Sign() == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t\treturn\n\t}\n\tif diff.Sign() < 0 {\n\t\ts.SubBalance(addr, diff.Abs(diff))\n\t\treturn\n\t}\n\n\toldValue := s.GetBalance(addr)\n\tnewValue := new(big.Int).Add(oldValue, diff)\n\n\ts.balances[addr].current = *newValue\n\ts.undo = append(s.undo, func() {\n\t\ts.balances[addr].current = *oldValue\n\t})\n}\n\nfunc (s *stateDB) SubBalance(addr common.Address, diff *big.Int) {\n\ts.createAccountIfNotExists(addr)\n\n\tif diff == nil || diff.Sign() == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t\treturn\n\t}\n\tif diff.Sign() < 0 {\n\t\ts.AddBalance(addr, diff.Abs(diff))\n\t\treturn\n\t}\n\n\toldValue := s.GetBalance(addr)\n\tnewValue := new(big.Int).Sub(oldValue, diff)\n\n\tif newValue.Sign() == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n\n\ts.balances[addr].current = *newValue\n\ts.undo = append(s.undo, func() {\n\t\ts.balances[addr].current = *oldValue\n\t})\n}\n\nfunc (s *stateDB) resetBalance(addr common.Address) {\n\tif val, exists := s.balances[addr]; exists {\n\t\tif val.current.Sign() != 0 {\n\t\t\toldValue := val.current\n\t\t\tval.current = *big.NewInt(0)\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\tval.current = oldValue\n\t\t\t})\n\t\t}\n\t} else {\n\t\ts.balances[addr] = &balanceValue{\n\t\t\toriginal: nil,\n\t\t\tcurrent:  *big.NewInt(0),\n\t\t}\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.balances, addr)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) GetNonce(addr common.Address) uint64 {\n\t// Check cache first.\n\tif val, exists := s.nonces[addr]; exists {\n\t\treturn val.current\n\t}\n\n\t// Since the value is not present, we need to fetch it from the store.\n\tnonce, err := s.state.GetNonce(addr)\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to load nonce for address %v: %w\", addr, err))\n\t\treturn 0\n\t}\n\tres := nonce.ToUint64()\n\ts.nonces[addr] = &nonceValue{\n\t\toriginal: &res,\n\t\tcurrent:  res,\n\t}\n\treturn res\n}\n\nfunc (s *stateDB) SetNonce(addr common.Address, nonce uint64) {\n\ts.setNonceInternal(addr, nonce)\n\tif s.createAccountIfNotExists(addr) && nonce == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n}\n\nfunc (s *stateDB) setNonceInternal(addr common.Address, nonce uint64) {\n\tif val, exists := s.nonces[addr]; exists {\n\t\tif val.current != nonce {\n\t\t\toldValue := val.current\n\t\t\tval.current = nonce\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\tval.current = oldValue\n\t\t\t})\n\t\t}\n\t} else {\n\t\ts.nonces[addr] = &nonceValue{\n\t\t\toriginal: nil,\n\t\t\tcurrent:  nonce,\n\t\t}\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.nonces, addr)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) GetCommittedState(addr common.Address, key common.Key) common.Value {\n\t// Check cache first.\n\tsid := slotId{addr, key}\n\tval, exists := s.data.Get(sid)\n\tif exists && val.committedKnown {\n\t\treturn val.committed\n\t}\n\t// If the value is not present, fetch it from the store.\n\treturn s.loadStoredState(sid, val)\n}\n\nfunc (s *stateDB) loadStoredState(sid slotId, val *slotValue) common.Value {\n\tif clearingState, found := s.clearedAccounts[sid.addr]; found && (clearingState == cleared || clearingState == clearedAndTainted) {\n\t\t// If the account has been cleared in a committed transaction within the current block,\n\t\t// the effects are not yet updated in the data base. So it must not be read from the DB\n\t\t// before the next block.\n\t\treturn common.Value{}\n\t}\n\treincarnation := s.reincarnation[sid.addr]\n\tvar stored storedDataCacheValue\n\tstored, found := s.storedDataCache.Get(sid)\n\tif !found {\n\t\tvar err error\n\t\tstored.value, err = s.state.GetStorage(sid.addr, sid.key)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to load storage location %v/%v: %w\", sid.addr, sid.key, err))\n\t\t\treturn common.Value{}\n\t\t}\n\t\tstored.reincarnation = reincarnation\n\t\ts.storedDataCache.Set(sid, stored)\n\t}\n\t// If the cached value is out-dated, the current value is zero. If the same slot would\n\t// have been updated since the clearing, it would have also been updated in the cache.\n\tif stored.reincarnation < reincarnation {\n\t\tstored.value = common.Value{}\n\t}\n\n\t// Remember the stored value for future accesses.\n\tif val != nil {\n\t\tval.committed, val.committedKnown = stored.value, true\n\t\tval.stored, val.storedKnown = stored.value, true\n\t} else {\n\t\ts.data.Put(sid, &slotValue{\n\t\t\tstored:         stored.value,\n\t\t\tcommitted:      stored.value,\n\t\t\tcurrent:        stored.value,\n\t\t\tstoredKnown:    true,\n\t\t\tcommittedKnown: true,\n\t\t})\n\t}\n\treturn stored.value\n}\n\nfunc (s *stateDB) GetState(addr common.Address, key common.Key) common.Value {\n\t// Check whether the slot is already cached/modified.\n\tsid := slotId{addr, key}\n\tif val, exists := s.data.Get(sid); exists {\n\t\treturn val.current\n\t}\n\t// Fetch missing slot values (will also populate the cache).\n\treturn s.loadStoredState(sid, nil)\n}\n\nfunc (s *stateDB) SetState(addr common.Address, key common.Key, value common.Value) {\n\tif s.createAccountIfNotExists(addr) {\n\t\t// The account was implicitly created and may have to be removed at the end of the block.\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n\tsid := slotId{addr, key}\n\tif entry, exists := s.data.Get(sid); exists {\n\t\tif entry.current != value {\n\t\t\toldValue := entry.current\n\t\t\tentry.current = value\n\t\t\ts.writtenSlots[entry] = true\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\tentry.current = oldValue\n\t\t\t})\n\t\t}\n\t} else {\n\t\tentry = &slotValue{current: value}\n\t\ts.data.Put(sid, entry)\n\t\ts.writtenSlots[entry] = true\n\t\ts.undo = append(s.undo, func() {\n\t\t\tentry, _ := s.data.Get(sid)\n\t\t\tif entry.committedKnown {\n\t\t\t\tentry.current = entry.committed\n\t\t\t} else {\n\t\t\t\ts.data.Remove(sid)\n\t\t\t}\n\t\t\tdelete(s.writtenSlots, entry)\n\t\t})\n\t}\n\toldState := s.clearedAccounts[addr]\n\tif oldState == cleared {\n\t\ts.clearedAccounts[addr] = clearedAndTainted\n\t\ts.undo = append(s.undo, func() { s.clearedAccounts[addr] = oldState })\n\t}\n}\n\nfunc (s *stateDB) GetTransientState(addr common.Address, key common.Key) common.Value {\n\tsid := slotId{addr, key}\n\tval, _ := s.transientStorage.Get(sid)\n\treturn val\n}\n\nfunc (s *stateDB) SetTransientState(addr common.Address, key common.Key, value common.Value) {\n\tsid := slotId{addr, key}\n\tcurrentValue, _ := s.transientStorage.Get(sid)\n\tif currentValue == value {\n\t\treturn\n\t}\n\n\t// Save previous value for rollbacks\n\toldValue := currentValue\n\ts.undo = append(s.undo, func() {\n\t\ts.transientStorage.Put(sid, oldValue)\n\t})\n\n\ts.transientStorage.Put(sid, value)\n}\n\nfunc (s *stateDB) GetCode(addr common.Address) []byte {\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{}\n\t\ts.codes[addr] = val\n\t}\n\tif !val.codeValid {\n\t\tcode, err := s.state.GetCode(addr)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to obtain code for %v: %w\", addr, err))\n\t\t\treturn nil\n\t\t}\n\t\tval.code, val.codeValid = code, true\n\t\tval.size, val.sizeValid = len(code), true\n\t}\n\treturn val.code\n}\n\nfunc (s *stateDB) SetCode(addr common.Address, code []byte) {\n\ts.createAccountIfNotExists(addr)\n\ts.setCodeInternal(addr, code)\n\tif len(code) == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n}\n\nfunc (s *stateDB) setCodeInternal(addr common.Address, code []byte) {\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{dirty: true}\n\t\tval.code, val.codeValid = code, true\n\t\tval.size, val.sizeValid = len(code), true\n\t\ts.codes[addr] = val\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.codes, addr)\n\t\t})\n\t} else {\n\t\told := *val\n\t\tval.code, val.codeValid = code, true\n\t\tval.size, val.sizeValid = len(code), true\n\t\tval.hash = nil\n\t\tval.dirty = true\n\t\ts.undo = append(s.undo, func() {\n\t\t\t*(s.codes[addr]) = old\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) GetCodeHash(addr common.Address) common.Hash {\n\t// The hash of the code of a non-existing account is always zero.\n\tif !s.Exist(addr) {\n\t\treturn common.Hash{}\n\t}\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{}\n\t\ts.codes[addr] = val\n\t}\n\tif val.dirty && val.hash == nil {\n\t\t// If the code is dirty (=uncommitted) the hash needs to be computed on the fly.\n\t\thash := common.GetKeccak256Hash(val.code)\n\t\tval.hash = &hash\n\t}\n\tif val.hash == nil {\n\t\t// hash not loaded, code not dirty - needs to load the hash from the state\n\t\thash, err := s.state.GetCodeHash(addr)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to obtain code hash for %v: %w\", addr, err))\n\t\t\treturn common.Hash{}\n\t\t}\n\t\tval.hash = &hash\n\t}\n\treturn *val.hash\n}\n\nfunc (s *stateDB) GetCodeSize(addr common.Address) int {\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{}\n\t\ts.codes[addr] = val\n\t}\n\tif !val.sizeValid {\n\t\tsize, err := s.state.GetCodeSize(addr)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to obtain code size for %v: %w\", addr, err))\n\t\t\treturn 0\n\t\t}\n\t\tval.size, val.sizeValid = size, true\n\t}\n\treturn val.size\n}\n\nfunc (s *stateDB) AddRefund(amount uint64) {\n\told := s.refund\n\ts.refund += amount\n\ts.undo = append(s.undo, func() {\n\t\ts.refund = old\n\t})\n}\nfunc (s *stateDB) SubRefund(amount uint64) {\n\tif amount > s.refund {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to lower refund, attempted to removed %d from current refund %d\", amount, s.refund))\n\t\treturn\n\t}\n\told := s.refund\n\ts.refund -= amount\n\ts.undo = append(s.undo, func() {\n\t\ts.refund = old\n\t})\n}\n\nfunc (s *stateDB) GetRefund() uint64 {\n\treturn s.refund\n}\n\nfunc (s *stateDB) AddLog(log *common.Log) {\n\tsize := len(s.logs)\n\tlog.Index = s.logsInBlock\n\ts.logs = append(s.logs, log)\n\ts.logsInBlock++\n\ts.undo = append(s.undo, func() {\n\t\ts.logs = s.logs[0:size]\n\t\ts.logsInBlock--\n\t})\n}\n\nfunc (s *stateDB) GetLogs() []*common.Log {\n\treturn s.logs\n}\n\nfunc (s *stateDB) ClearAccessList() {\n\tif len(s.accessedAddresses) > 0 {\n\t\ts.accessedAddresses = make(map[common.Address]bool)\n\t}\n\tif s.accessedSlots.Size() > 0 {\n\t\ts.accessedSlots.Clear()\n\t}\n}\n\nfunc (s *stateDB) AddAddressToAccessList(addr common.Address) {\n\t_, found := s.accessedAddresses[addr]\n\tif !found {\n\t\ts.accessedAddresses[addr] = true\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.accessedAddresses, addr)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) AddSlotToAccessList(addr common.Address, key common.Key) {\n\ts.AddAddressToAccessList(addr)\n\tsid := slotId{addr, key}\n\t_, found := s.accessedSlots.Get(sid)\n\tif !found {\n\t\ts.accessedSlots.Put(sid, true)\n\t\ts.undo = append(s.undo, func() {\n\t\t\ts.accessedSlots.Remove(sid)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) IsAddressInAccessList(addr common.Address) bool {\n\t_, found := s.accessedAddresses[addr]\n\treturn found\n}\n\nfunc (s *stateDB) IsSlotInAccessList(addr common.Address, key common.Key) (addressPresent bool, slotPresent bool) {\n\t_, found := s.accessedSlots.Get(slotId{addr, key})\n\tif found {\n\t\treturn true, true\n\t}\n\treturn s.IsAddressInAccessList(addr), false\n}\n\nfunc (s *stateDB) Snapshot() int {\n\treturn len(s.undo)\n}\n\nfunc (s *stateDB) RevertToSnapshot(id int) {\n\tif id < 0 || len(s.undo) < id {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to revert to invalid snapshot id %d, allowed range 0 - %d\", id, len(s.undo)))\n\t\treturn\n\t}\n\tfor len(s.undo) > id {\n\t\ts.undo[len(s.undo)-1]()\n\t\ts.undo = s.undo[:len(s.undo)-1]\n\t}\n}\n\nfunc (s *stateDB) BeginTransaction() {\n\t// Ignored\n}\n\nfunc (s *stateDB) EndTransaction() {\n\t// Updated committed state of storage.\n\tfor value := range s.writtenSlots {\n\t\tvalue.committed, value.committedKnown = value.current, true\n\t}\n\n\t// EIP-161: At the end of the transaction, any account touched by the execution of that transaction\n\t// which is now empty SHALL instead become non-existent (i.e. deleted).\n\tfor _, addr := range s.emptyCandidates {\n\t\tif s.Empty(addr) {\n\t\t\ts.accountsToDelete = append(s.accountsToDelete, addr)\n\t\t\t// Mark the account storage state to be cleaned below.\n\t\t\ts.clearedAccounts[addr] = pendingClearing\n\t\t}\n\t}\n\n\t// Delete accounts scheduled for deletion - by suicide or because they are empty.\n\tif len(s.accountsToDelete) > 0 {\n\t\tfor _, addr := range s.accountsToDelete {\n\t\t\t// Transition accounts marked by suicide to be deleted.\n\t\t\tif s.HasSuicided(addr) {\n\t\t\t\ts.setAccountState(addr, accountNonExisting)\n\t\t\t\ts.setCodeInternal(addr, []byte{})\n\t\t\t\ts.clearedAccounts[addr] = pendingClearing\n\t\t\t}\n\n\t\t\t// If the account was already cleared because it was recreated, we skip this part.\n\t\t\tif state, found := s.clearedAccounts[addr]; found && (state == cleared || state == clearedAndTainted) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Note: storage state is handled through the clearedAccount map\n\t\t\t// the clearing of the data and storedDataCache at various phases\n\t\t\t// of the block processing.\n\t\t\ts.setAccountState(addr, accountNonExisting)\n\t\t\ts.resetBalance(addr) // reset balance if balance is set after suicide\n\t\t\ts.setNonceInternal(addr, 0)\n\t\t\ts.setCodeInternal(addr, []byte{})\n\n\t\t\t// Clear cached value states for the targeted account.\n\t\t\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\t\t\tif slot.addr == addr {\n\t\t\t\t\t// Clear cached values.\n\t\t\t\t\tvalue.stored = common.Value{}\n\t\t\t\t\tvalue.storedKnown = true\n\t\t\t\t\tvalue.committed = common.Value{}\n\t\t\t\t\tvalue.committedKnown = true\n\t\t\t\t\tvalue.current = common.Value{}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Signal to future fetches in this block that this account should be considered cleared.\n\t\t\ts.clearedAccounts[addr] = cleared\n\t\t}\n\n\t\ts.accountsToDelete = s.accountsToDelete[0:0]\n\t}\n\n\ts.writtenSlots = map[*slotValue]bool{}\n\t// Reset state, in particular seal effects by forgetting undo list.\n\ts.resetTransactionContext()\n}\n\nfunc (s *stateDB) GetTransactionChanges() map[common.Address][]common.Key {\n\tchanges := make(map[common.Address][]common.Key)\n\tfor addr := range s.accounts {\n\t\tchanges[addr] = nil\n\t}\n\tfor addr := range s.balances {\n\t\tchanges[addr] = nil\n\t}\n\tfor addr := range s.nonces {\n\t\tchanges[addr] = nil\n\t}\n\tfor addr := range s.codes {\n\t\tchanges[addr] = nil\n\t}\n\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\tif !value.committedKnown || value.committed != value.current {\n\t\t\tchanges[slot.addr] = append(changes[slot.addr], slot.key)\n\t\t}\n\t})\n\treturn changes\n}\n\n// Deprecated: not necessary, to be removed\nfunc (s *stateDB) AbortTransaction() {\n\t// Revert all effects and reset transaction context.\n\ts.RevertToSnapshot(0)\n\ts.resetTransactionContext()\n}\n\nfunc (s *stateDB) BeginBlock() {\n\t// ignored\n}\n\nfunc (s *stateDB) EndBlock(block uint64) {\n\tif !s.canApplyChanges {\n\t\terr := fmt.Errorf(\"unable to process EndBlock event in StateDB without permission to apply changes\")\n\t\ts.errors = append(s.errors, err)\n\t\treturn\n\t}\n\n\t// Skip applying changes if there have been any issues.\n\tif err := s.Check(); err != nil {\n\t\treturn\n\t}\n\n\tupdate := common.Update{}\n\n\t// Clear all accounts that have been deleted at some point during this block.\n\t// This will cause all storage slots of that accounts to be reset before new\n\t// values may be written in the subsequent updates.\n\tnonExistingAccounts := map[common.Address]bool{}\n\tfor addr, clearingState := range s.clearedAccounts {\n\t\tif clearingState == cleared || clearingState == clearedAndTainted {\n\t\t\tif s.accounts[addr].original == accountExists {\n\t\t\t\t// Pretend this account was originally deleted, such that in the loop below\n\t\t\t\t// it would be detected as re-created in case its new state is Existing.\n\t\t\t\ts.accounts[addr].original = accountNonExisting\n\t\t\t\t// If the account was not later re-created, we mark it for deletion.\n\t\t\t\tif s.accounts[addr].current != accountExists {\n\t\t\t\t\tupdate.AppendDeleteAccount(addr)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnonExistingAccounts[addr] = true\n\t\t\t}\n\t\t\t// Increment the reincarnation counter of cleared addresses to invalidate\n\t\t\t// cached entries in the stored data cache.\n\t\t\ts.reincarnation[addr] = s.reincarnation[addr] + 1\n\t\t}\n\t}\n\n\t// (Re-)create new or resurrected accounts.\n\tfor addr, value := range s.accounts {\n\t\tif value.original != value.current {\n\t\t\tif value.current == accountExists {\n\t\t\t\tupdate.AppendCreateAccount(addr)\n\t\t\t\tdelete(nonExistingAccounts, addr)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update balances.\n\tfor addr, value := range s.balances {\n\t\tif _, found := nonExistingAccounts[addr]; found {\n\t\t\tcontinue\n\t\t}\n\t\tif value.original == nil || value.original.Cmp(&value.current) != 0 {\n\t\t\tnewBalance, err := common.ToBalance(&value.current)\n\t\t\tif err != nil {\n\t\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to convert big.Int balance %v to common.Balance: %w\", &value.current, err))\n\t\t\t} else {\n\t\t\t\tupdate.AppendBalanceUpdate(addr, newBalance)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update nonces.\n\tfor addr, value := range s.nonces {\n\t\tif _, found := nonExistingAccounts[addr]; found {\n\t\t\tcontinue\n\t\t}\n\t\tif value.original == nil || *value.original != value.current {\n\t\t\tupdate.AppendNonceUpdate(addr, common.ToNonce(s.nonces[addr].current))\n\t\t}\n\t}\n\n\t// Update storage values in state DB\n\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\tif !value.storedKnown || value.stored != value.current {\n\t\t\tupdate.AppendSlotUpdate(slot.addr, slot.key, value.current)\n\t\t\ts.storedDataCache.Set(slot, storedDataCacheValue{value.current, s.reincarnation[slot.addr]})\n\t\t}\n\t})\n\n\t// Update modified codes.\n\tfor addr, value := range s.codes {\n\t\tif _, found := nonExistingAccounts[addr]; found {\n\t\t\tcontinue\n\t\t}\n\t\tif value.dirty {\n\t\t\tupdate.AppendCodeUpdate(addr, s.codes[addr].code)\n\t\t}\n\t}\n\n\t// Skip applying changes if there have been any issues.\n\tif err := s.Check(); err != nil {\n\t\treturn\n\t}\n\n\t// Send the update to the state.\n\tif err := s.state.Apply(block, update); err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to apply update for block %d: %w\", block, err))\n\t\treturn\n\t}\n\n\t// Reset internal state for next block\n\ts.ResetBlockContext()\n}\n\nfunc (s *stateDB) BeginEpoch() {\n\t// ignored\n}\n\nfunc (s *stateDB) EndEpoch(uint64) {\n\t// ignored\n}\n\nfunc (s *stateDB) GetHash() common.Hash {\n\thash, err := s.state.GetHash()\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to compute hash: %w\", err))\n\t\treturn common.Hash{}\n\t}\n\treturn hash\n}\n\nfunc (s *stateDB) Check() error {\n\treturn errors.Join(\n\t\terrors.Join(s.errors...),\n\t\ts.state.Check())\n}\n\nfunc (s *stateDB) Flush() error {\n\treturn errors.Join(\n\t\ts.Check(),\n\t\ts.state.Flush(),\n\t)\n}\n\nfunc (s *stateDB) Close() error {\n\treturn errors.Join(\n\t\ts.Flush(),\n\t\ts.state.Close(),\n\t)\n}\n\nfunc (s *stateDB) StartBulkLoad(block uint64) BulkLoad {\n\ts.storedDataCache.Clear()\n\treturn &bulkLoad{s, common.Update{}, block, nil}\n}\n\nfunc (s *stateDB) GetMemoryFootprint() *common.MemoryFootprint {\n\tconst addressSize = 20\n\tconst keySize = 32\n\tconst hashSize = 32\n\tconst slotIdSize = addressSize + keySize\n\n\tmf := common.NewMemoryFootprint(unsafe.Sizeof(*s))\n\tmf.AddChild(\"state\", s.state.GetMemoryFootprint())\n\n\t// For account-states, balances, and nonces an over-approximation should be sufficient.\n\tmf.AddChild(\"accounts\", common.NewMemoryFootprint(uintptr(len(s.accounts))*(addressSize+unsafe.Sizeof(accountState{})+unsafe.Sizeof(common.AccountState(0)))))\n\tmf.AddChild(\"balances\", common.NewMemoryFootprint(uintptr(len(s.balances))*(addressSize+unsafe.Sizeof(balanceValue{}))))\n\tmf.AddChild(\"nonces\", common.NewMemoryFootprint(uintptr(len(s.nonces))*(addressSize+unsafe.Sizeof(nonceValue{})+8)))\n\tmf.AddChild(\"slots\", common.NewMemoryFootprint(uintptr(s.data.Size())*(slotIdSize+unsafe.Sizeof(slotValue{}))))\n\n\tvar sum uintptr = 0\n\tfor _, value := range s.codes {\n\t\tsum += addressSize\n\t\tif value.hash != nil {\n\t\t\tsum += hashSize\n\t\t}\n\t\tsum += uintptr(len(value.code))\n\t}\n\tmf.AddChild(\"codes\", common.NewMemoryFootprint(sum))\n\n\tvar boolean bool\n\tconst boolSize = unsafe.Sizeof(boolean)\n\tmf.AddChild(\"accessedAddresses\", common.NewMemoryFootprint(uintptr(len(s.accessedAddresses))*(addressSize+boolSize)))\n\tmf.AddChild(\"accessedSlots\", common.NewMemoryFootprint(uintptr(s.accessedSlots.Size())*(slotIdSize+boolSize)))\n\tmf.AddChild(\"writtenSlots\", common.NewMemoryFootprint(uintptr(len(s.writtenSlots))*(boolSize+unsafe.Sizeof(&slotValue{}))))\n\tmf.AddChild(\"storedDataCache\", s.storedDataCache.GetMemoryFootprint(0))\n\tmf.AddChild(\"reincarnation\", common.NewMemoryFootprint(uintptr(len(s.reincarnation))*(addressSize+unsafe.Sizeof(uint64(0)))))\n\tmf.AddChild(\"emptyCandidates\", common.NewMemoryFootprint(uintptr(len(s.emptyCandidates))*(addressSize)))\n\n\treturn mf\n}\n\nfunc (s *stateDB) GetArchiveStateDB(block uint64) (NonCommittableStateDB, error) {\n\tarchiveState, err := s.state.GetArchiveState(block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn CreateNonCommittableStateDBUsing(archiveState), nil\n}\n\nfunc (s *stateDB) GetArchiveBlockHeight() (uint64, bool, error) {\n\treturn s.state.GetArchiveBlockHeight()\n}\n\nfunc (s *stateDB) resetTransactionContext() {\n\ts.refund = 0\n\ts.ClearAccessList()\n\ts.transientStorage.Clear()\n\ts.undo = s.undo[0:0]\n\ts.emptyCandidates = s.emptyCandidates[0:0]\n\ts.logs = s.logs[0:0]\n}\n\nfunc (s *stateDB) ResetBlockContext() {\n\ts.accounts = make(map[common.Address]*accountState, len(s.accounts))\n\ts.balances = make(map[common.Address]*balanceValue, len(s.balances))\n\ts.nonces = make(map[common.Address]*nonceValue, len(s.nonces))\n\ts.data.Clear()\n\ts.clearedAccounts = make(map[common.Address]accountClearingState)\n\ts.codes = make(map[common.Address]*codeValue)\n\ts.logsInBlock = 0\n\ts.resetTransactionContext()\n}\n\nfunc (s *stateDB) resetState(state State) {\n\ts.ResetBlockContext()\n\ts.storedDataCache.Clear()\n\ts.reincarnation = map[common.Address]uint64{}\n\ts.errors = s.errors[0:0]\n\ts.state = state\n}\n\ntype bulkLoad struct {\n\tdb     *stateDB\n\tupdate common.Update\n\tblock  uint64\n\terrs   []error\n}\n\nfunc (l *bulkLoad) CreateAccount(addr common.Address) {\n\tl.update.AppendCreateAccount(addr)\n}\n\nfunc (l *bulkLoad) SetBalance(addr common.Address, value *big.Int) {\n\tnewBalance, err := common.ToBalance(value)\n\tif err != nil {\n\t\tl.errs = append(l.errs, fmt.Errorf(\"unable to convert big.Int balance to common.Balance: %w\", err))\n\t\treturn\n\t}\n\tl.update.AppendBalanceUpdate(addr, newBalance)\n}\n\nfunc (l *bulkLoad) SetNonce(addr common.Address, value uint64) {\n\tl.update.AppendNonceUpdate(addr, common.ToNonce(value))\n}\n\nfunc (l *bulkLoad) SetState(addr common.Address, key common.Key, value common.Value) {\n\tl.update.AppendSlotUpdate(addr, key, value)\n}\n\nfunc (l *bulkLoad) SetCode(addr common.Address, code []byte) {\n\tl.update.AppendCodeUpdate(addr, code)\n}\n\nfunc (l *bulkLoad) apply() {\n\t// Apply the update to the DB as one new block.\n\tif err := l.update.Normalize(); err != nil {\n\t\tl.errs = append(l.errs, err)\n\t\treturn\n\t}\n\terr := l.db.state.Apply(l.block, l.update)\n\tl.update = common.Update{}\n\tif err != nil {\n\t\tl.errs = append(l.errs, err)\n\t}\n}\n\nfunc (l *bulkLoad) Close() error {\n\tl.apply()\n\t// Return if errors occurred\n\tif l.errs != nil {\n\t\treturn errors.Join(l.errs...)\n\t}\n\n\t// Flush out all inserted data.\n\tif err := l.db.state.Flush(); err != nil {\n\t\treturn err\n\t}\n\t// Compute hash to bring cached hashes up-to-date.\n\t_, err := l.db.state.GetHash()\n\t// Reset state to allow starting bulk-load with existing database.\n\tl.db.resetState(l.db.state)\n\treturn err\n}\n\nvar nonCommittableStateDbPool = sync.Pool{\n\tNew: func() any {\n\t\t// We use a smaller stored-data cache size to support faster initialization\n\t\t// and resetting of instances. NonCommittable instances are expected to live\n\t\t// only for the duration of a few transactions.\n\t\treturn createStateDBWith(nil, nonCommittableStoredDataCacheSize, false)\n\t},\n}\n\ntype nonCommittableStateDB struct {\n\t*stateDB\n}\n\nfunc (db *nonCommittableStateDB) Copy() NonCommittableStateDB {\n\tcp := nonCommittableStateDbPool.Get().(*stateDB)\n\tcp.resetState(db.state)\n\n\tmaps.Copy(cp.accounts, db.accounts)\n\tmaps.Copy(cp.balances, db.balances)\n\tmaps.Copy(cp.nonces, db.nonces)\n\tdb.data.CopyTo(cp.data)\n\tmaps.Copy(cp.codes, db.codes)\n\tmaps.Copy(cp.clearedAccounts, db.clearedAccounts)\n\tmaps.Copy(cp.reincarnation, db.reincarnation)\n\tcp.logsInBlock = db.logsInBlock\n\t// we suppose ended tx - we may skip members,\n\t// which are reset at the end of every tx\n\n\treturn &nonCommittableStateDB{cp}\n}\n\nfunc (db *nonCommittableStateDB) Release() {\n\tif db.stateDB != nil {\n\t\tnonCommittableStateDbPool.Put(db.stateDB)\n\t\tdb.stateDB = nil\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/state_db.go b/go/state/state_db.go
--- a/go/state/state_db.go	(revision d3c08449c012a8878e3106e865c20051293c5885)
+++ b/go/state/state_db.go	(date 1718705367055)
@@ -550,6 +550,33 @@
 	return true
 }
 
+func (s *stateDB) Suicide6780(addr common.Address) bool {
+	if !s.Exist(addr) {
+		return false
+	}
+	//
+	s.setAccountState(addr, accountSelfDestructed)
+
+	s.resetBalance(addr)
+	deleteListLength := len(s.accountsToDelete)
+	s.accountsToDelete = append(s.accountsToDelete, addr)
+	s.undo = append(s.undo, func() {
+		s.accountsToDelete = s.accountsToDelete[0:deleteListLength]
+	})
+
+	// Mark account for clearing to plan its removing on commit and
+	// to avoid fetching new data into the cache during the ongoing block.
+	oldState := s.clearedAccounts[addr]
+	if oldState == noClearing {
+		s.clearedAccounts[addr] = pendingClearing
+		s.undo = append(s.undo, func() {
+			s.clearedAccounts[addr] = oldState
+		})
+	}
+
+	return true
+}
+
 // Suicide marks the given account as suicided.
 // This clears the account balance.
 // The account still exist until the state is committed.
@@ -557,7 +584,7 @@
 	if !s.Exist(addr) {
 		return false
 	}
-
+	//
 	s.setAccountState(addr, accountSelfDestructed)
 
 	s.resetBalance(addr)
