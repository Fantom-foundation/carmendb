Index: go/carmen/carmen.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage carmen\n\nimport (\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n)\n\n//go:generate mockgen -source carmen.go -destination carmen_mock.go -package carmen\n\n// UnsupportedConfiguration is the error returned if unsupported configurations\n// are identified. The text may contain further details regarding the\n// unsupported feature.\nconst UnsupportedConfiguration = state.UnsupportedConfiguration\n\n// OpenDatabase opens a database located in the given directory. If the directory is\n// empty, a new empty database is initialized. If the directory does not exist,\n// it is created first.\n//\n// Opening a Database may fail if\n//  1. the target database is already opened by this or some other process\n//  2. the database is marked as corrupted and should not be accessed\n//  3. the configuration does not match the database in the given directory\n//  4. an IO error prevented the database to be opened\n//\n// Any database successfully opened by this function must be eventually closed.\nfunc OpenDatabase(directory string, implementation Configuration, properties Properties) (Database, error) {\n\treturn openDatabase(directory, implementation, properties)\n}\n\n// Database provides access to the blockchain state.\n// It can query historic state referring to existing blocks\n// and append new blocks with modified state at the head of the chain.\n//\n// At any time, only one thread can run a transaction adding a new block.\n// Many threads may, however, query the history at the same time.\ntype Database interface {\n\t// QueryHeadState provides read-only query access to the current\n\t// blockchain head's state. All operations within the query are\n\t// guaranteed to be based on a consistent block state. Multiple\n\t// queries may be conducted concurrently. However, query operations\n\t// should be of short duration, since long-running queries may\n\t// prevent the head state from being updated. If this call produces\n\t// an error, the data retrieved in the query should be considered\n\t// invalid.\n\tQueryHeadState(query func(QueryContext)) error\n\n\t// BeginBlock starts a new block context, which is used\n\t// to access and possibly modify the current world state.\n\t// The world state is accessed via transactions that can\n\t// be created using the returned context.\n\t// This method lends the context to the caller, and the caller\n\t// is eventually required to return the context by either\n\t// committing or aborting it.\n\t// Only one context at a time can be opened, and an error\n\t// is produced for opening a context before another one was\n\t// either committed or aborted.\n\tBeginBlock(block uint64) (HeadBlockContext, error)\n\n\t// AddBlock appends a new block to the blockchain.\n\t// The input callback function accesses a new block context,\n\t// which allows for modification of the state via one or more transactions.\n\t// This method commits the provided block context before it terminates,\n\t// unless the callback function returns an error. If the callback function\n\t// returns an error, the creation of the block is aborted and callback's\n\t// error is returned by the AddBlock call. In this case no block is created.\n\tAddBlock(block uint64, run func(HeadBlockContext) error) error\n\n\t// GetArchiveBlockHeight returns the current last block number of the blockchain.\n\t// This value is available only when the archive is enabled.\n\tGetArchiveBlockHeight() (int64, error)\n\n\t// GetHistoricStateHash returns state root hash for the input block number.\n\t// This value is available only when the archive is enabled.\n\t// Deprecated: use QueryHistoricState\n\tGetHistoricStateHash(block uint64) (Hash, error)\n\n\t// QueryHistoricState provides read-only query access to a historic\n\t// state in the block chain in the range [0 .. GetArchiveBlockHeight()].\n\t// All operations within the query are guaranteed to be based on a\n\t// consistent block state. Multiple queries may be conducted concurrently.\n\t// If this call produces an error, the data retrieved in the query should\n\t// be considered invalid.\n\tQueryHistoricState(block uint64, query func(QueryContext)) error\n\n\t// GetHistoricContext returns a block context, which accesses\n\t// the world state history as it was for the input block number.\n\t// This method lends the context to the caller, and the caller\n\t// is eventually required to return the context closing it.\n\t// Many historic contexts can be opened in parallel.\n\t// This context is available only when the archive is enabled.\n\tGetHistoricContext(block uint64) (HistoricBlockContext, error)\n\n\t// QueryBlock accesses a block context that may query the world state\n\t// history as it was for the input block number.\n\t// The context is provided to the caller via the input callback function.\n\t// The context is released before this function terminates,\n\t// i.e. the user does not have to close it.\n\t// This context is available only when the archive is enabled.\n\tQueryBlock(block uint64, run func(HistoricBlockContext) error) error\n\n\t// Flush persists all committed HeadBlockContexts to the database.\n\t// This method blocks until all changes are persisted.\n\t// If archive is enabled, this function also waits until\n\t// all updates to the archive are persisted.\n\tFlush() error\n\n\t// Close flushes and releases this database.\n\t// No methods of the database should be called\n\t// after it is closed, a new instance must be\n\t// created.\n\tClose() error\n\n\t// --- Legacy features ---\n\n\t// StartBulkLoad creates a specific context for fast filling of a database.\n\t// It directly inserts values into the database bypassing all checks.\n\t// This feature should be used in specific scenarios only where fast population\n\t// of a database is needed.\n\t// It cannot replace regular block processing.\n\t// Only one bulk load can run at a time. Also, no head-block transaction may be active while a BulkLoad operation is in progress.\n\tStartBulkLoad(block uint64) (BulkLoad, error)\n}\n\n// blockContext is an interface that accesses transactions of a block.\n// This can be used for applying transactions to a new block, which is eventually added\n// to the blockchain, or for querying world state history referred to a block.\ntype blockContext interface {\n\n\t// BeginTransaction opens a new transaction context.\n\t// It allows querying state information and performing volatile modifications within this block context.\n\t// This method lends the context to the caller, and the caller\n\t// is eventually required to return the context by either committing or aborting it.\n\t// Only one context at a time can be opened, and an error is produced for opening\n\t// a context before another one was either committed or aborted.\n\tBeginTransaction() (TransactionContext, error)\n\n\t// RunTransaction provides a transaction context.\n\t// It allows querying state information and performing volatile modifications within this block context.\n\t// This method begins a new transaction context, provides the context to the caller via the callback,\n\t// and either commits or aborts the context at the end. The context is aborted if the callback\n\t// returns error, otherwise it is committed.\n\t// This method does not require the caller to drive the lifecycle of the transaction context,\n\t// as the context is opened and closed within this method call.\n\tRunTransaction(run func(TransactionContext) error) error\n}\n\n// HeadBlockContext provides an environment to create a new head-block of the blockchain.\n// It can be modified via a set of transactions and eventually committed or aborted.\n// If the context is committed, it forms a new block at the head of the blockchain.\n// This new block is added to the archive should the archive be enabled.\n// If the context is aborted, no change happens.\n//\n// Only one head block context may be created at the time.\n// Attempts to create another context before the previous one was either committed or aborted\n// produce an error.\ntype HeadBlockContext interface {\n\tblockContext\n\n\t// Commit writes the changes of this block into the database, progressing the\n\t// head world state and making it (eventually) visible in the archive state.\n\t// It also releases resources bound to this context. This context is invalid\n\t// after this call and should be discarded.\n\tCommit() error\n\n\t// Abort releases this context without committing changes. This context is\n\t// invalid after this call and should be discarded.\n\tAbort() error\n}\n\n// HistoricBlockContext provides access to the world state of a block of a blockchain.\n// This context allows the caller to open a transaction\n// and query state of the blockchain as it was for this particular block withing the history.\n// The caller can as well modify the context via a transaction, i.e. simulating\n// an alternative history.\n// These changes cannot be, however, committed as this context can not be committed, only be closed.\n// When the context is closed, all possibly held resources are released, but no change\n// to the blockchain happens.\ntype HistoricBlockContext interface {\n\tblockContext\n\n\t// Close releases resources held by this context. All modifications made\n\t// within this context are discarded. This context is invalid after this\n\t// call and should be discarded. Every historic block context needs to be\n\t// closed once.\n\tClose() error\n}\n\n// TransactionContext represents a transaction within a block.\n// Transactions may manipulate and read the state.\n// Both head of the blockchain and historic blocks  can be queried\n// and updated via transactions, but only a transaction bound to\n// the head block context can eventually update the blockchain.\n// A block context can have only one active transaction context\n// at a time.\n// The caller is required to commit or abort the transaction\n// context before another one can be opened.\n// Methods of this interface are not thread safe.\ntype TransactionContext interface {\n\n\t// CreateAccount creates a new account with the given address.\n\t// If the account already exists, its fields are emptied.\n\t// It means balance is set to zero, nonce is set to zero,\n\t// associated code is removed, and storage is cleared.\n\tCreateAccount(Address)\n\n\t// Exist checks if the account with the given address exists.\n\tExist(Address) bool\n\n\t// Empty checks if the account with the given address is empty.\n\t// The account is empty if its balance is zero, nonce is zero,\n\t// and there is no associated code with this account.\n\tEmpty(Address) bool\n\n\t// SelfDestruct invalidates the account with the given address.\n\t// It clears its balance, and marks the account as destructed.\n\tSelfDestruct(Address) bool\n\n\t// HasSelfDestructed checks if the account with the given address\n\t// was destructed.\n\tHasSelfDestructed(Address) bool\n\n\t// GetBalance returns the current balance of an account with\n\t// the given address.\n\tGetBalance(Address) Amount\n\n\t// AddBalance increases the balance of an account with\n\t// the given address of the input increment.\n\tAddBalance(Address, Amount)\n\n\t// SubBalance decreases the balance of an account with\n\t// the given address of the input decrement.\n\tSubBalance(Address, Amount)\n\n\t// GetNonce returns current nonce of an account with\n\t// the given address.\n\tGetNonce(Address) uint64\n\n\t// SetNonce sets nonce of an account with\n\t// the given address to the input value.\n\tSetNonce(Address, uint64)\n\n\t// GetCommittedState returns a value of the input key\n\t// stored in the account with the given address.\n\t// This method returns a value committed before this\n\t// transaction.\n\tGetCommittedState(Address, Key) Value\n\n\t// GetState returns a value of the input key\n\t// stored in the account with the given address.\n\t// This method returns an ongoing value that could be\n\t// updated in the current transaction.\n\tGetState(Address, Key) Value\n\n\t// SetState updates a value for the input key\n\t// stored in the account with the given address.\n\tSetState(Address, Key, Value)\n\n\t// GetTransientState retrieves the value associated with a specific\n\t// key within the transient state storage at a given address.\n\t// Transient State is an in-memory storage\n\t// that gets reset after each transaction.\n\tGetTransientState(Address, Key) Value\n\n\t// SetTransientState sets a value in the transient state\n\t// storage for a specific key at a given address.\n\t// Transient State is an in-memory storage\n\t// that gets reset after each transaction.\n\tSetTransientState(Address, Key, Value)\n\n\t// GetCode returns smart contract byte-code\n\t// of an account with the given address.\n\tGetCode(Address) []byte\n\n\t// SetCode updates smart contract byte-code\n\t// of an account with the given address.\n\tSetCode(Address, []byte)\n\n\t// GetCodeHash returns a hash of smart contract\n\t// byte-code for an account with the given address.\n\tGetCodeHash(Address) Hash\n\n\t// GetCodeSize returns the size of smart contract\n\t// byte-code for an account with the given address.\n\tGetCodeSize(Address) int\n\n\t// AddRefund increases refund of input amount.\n\t// It allows for tracking possible refund of\n\t// the current transaction.\n\tAddRefund(uint64)\n\n\t// SubRefund decreases refund of input amount.\n\t// It allows for tracking possible refund\n\t// fo current transaction.\n\tSubRefund(uint64)\n\n\t// GetRefund returns refund accumulated so far.\n\t// It allows for tracking possible refund\n\t// fo current transaction.\n\tGetRefund() uint64\n\n\t// AddLog adds a log into the current transaction.\n\tAddLog(*Log)\n\n\t// GetLogs provides logs produced in the current transaction.\n\tGetLogs() []*Log\n\n\t// ClearAccessList empties the list of accounts accessed\n\t// in this transaction.\n\tClearAccessList()\n\n\t// AddAddressToAccessList stores in a temporary list\n\t// that the input account was accessed.\n\t// This method is used for tracking accounts accessed\n\t// in the current transaction.\n\tAddAddressToAccessList(Address)\n\n\t// AddSlotToAccessList stores in a temporary list\n\t// that the input account and its storage was accessed.\n\t// This method is used for tracking slots accessed\n\t// in the current transaction.\n\tAddSlotToAccessList(Address, Key)\n\n\t// IsAddressInAccessList checks if the input account\n\t// was accessed.\n\tIsAddressInAccessList(Address) bool\n\n\t// IsSlotInAccessList checks if the input account\n\t// and its storage was accessed.\n\tIsSlotInAccessList(Address, Key) (addressPresent bool, slotPresent bool)\n\n\t// Snapshot marks a snapshot of a current transaction state.\n\t// The snapshot is marked by a number, which is returned.\n\tSnapshot() int\n\n\t// RevertToSnapshot rollbacks current state to the previous snapshot\n\t// marked by call to Snapshot.\n\tRevertToSnapshot(int)\n\n\t// Commit completes this transaction. Pending changes are considered\n\t// committed for subsequent transactions in the same block. However,\n\t// changes are only persisted when committing the enclosing block.\n\t// A call to Commit also implicitly releases underlying resources,\n\t// invalidating this instance. The instance should be discarded after\n\t// this call.\n\tCommit() error\n\n\t// Abort releases underlying resources without committing results. This\n\t// invalidates this instance, which should be discarded after this call.\n\tAbort() error\n}\n\n// QueryContext is a context provided to query operations for retrieving\n// information for a selected state. All operations are thread-safe and\n// responses are guaranteed to be derived from a consistent state. Thus,\n// access is synchronized regarding potential concurrent updates.\ntype QueryContext interface {\n\t// GetBalance returns the current balance of an account with\n\t// the given address.\n\tGetBalance(Address) Amount\n\n\t// GetNonce returns current nonce of an account with\n\t// the given address.\n\tGetNonce(Address) uint64\n\n\t// GetState returns a value of the input key\n\t// stored in the account with the given address.\n\t// This method returns an ongoing value that could be\n\t// updated in the current transaction.\n\tGetState(Address, Key) Value\n\n\t// GetCode returns smart contract byte-code\n\t// of an account with the given address.\n\tGetCode(Address) []byte\n\n\t// GetCodeHash returns a hash of smart contract\n\t// byte-code for an account with the given address.\n\tGetCodeHash(Address) Hash\n\n\t// GetCodeSize returns the size of smart contract\n\t// byte-code for an account with the given address.\n\tGetCodeSize(Address) int\n\n\t// GetStateHash get the state root hash for the state queried\n\t// by this context.\n\tGetStateHash() Hash\n}\n\n// BulkLoad provides a context for fast filling of the database.\n// It allows for direct insertion of values into the database bypassing all checks.\n// Only one bulk load can run at a time.\n// Methods of this interface are not thread safe.\n// WARNING: One BulkLoad should not exceed 100k updates. Client should\n// break large bulk-loads into smaller ones not exceeding this value.\ntype BulkLoad interface {\n\n\t// CreateAccount creates a new account with the given address.\n\t// If the account already exists, its fields are emptied.\n\t// It means balance is set to zero, nonce is set to zero,\n\t// associated code is removed, and storage is cleared.\n\tCreateAccount(Address)\n\n\t// SetBalance sets the balance of the given account address\n\t// to the input value.\n\tSetBalance(Address, Amount)\n\n\t// SetNonce sets the nonce of the given account address\n\t// to the input value.\n\tSetNonce(Address, uint64)\n\n\t// SetState sets the storage slot of the given account\n\t// address and the input storage key to the input value.\n\tSetState(Address, Key, Value)\n\n\t// SetCode sets the smart contract byte-code of\n\t// the given account address to the input value.\n\tSetCode(Address, []byte)\n\n\t// Finalize applies so far accumulated bulk load\n\t// into the database.\n\t// Furthermore, it invalidates the BulkLoad\n\t// and releases its hold on the Database.\n\tFinalize() error\n}\n\n// Address is a 20byte account address.\ntype Address common.Address\n\n// Key is a 32byte storage address.\ntype Key common.Key\n\n// Value is a 32byte storage value.\ntype Value common.Value\n\n// Hash is a 32byte hash.\ntype Hash common.Hash\n\n// Log summarizes a log message recorded during the execution of a contract.\ntype Log struct {\n\t// -- payload --\n\t// Address of the contract that generated the event.\n\tAddress Address\n\t// List of topics the log message should be tagged by.\n\tTopics []Hash\n\t// The actual log message.\n\tData []byte\n\n\t// -- metadata --\n\t// Index of the log in the block.\n\tIndex uint\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/carmen/carmen.go b/go/carmen/carmen.go
--- a/go/carmen/carmen.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/carmen/carmen.go	(date 1718180956922)
@@ -12,6 +12,7 @@
 
 import (
 	"github.com/Fantom-foundation/Carmen/go/common"
+	"github.com/Fantom-foundation/Carmen/go/common/tribool"
 	"github.com/Fantom-foundation/Carmen/go/state"
 )
 
@@ -261,6 +262,8 @@
 	// updated in the current transaction.
 	GetState(Address, Key) Value
 
+	HasEmptyStorage(Address) tribool.Tribool
+
 	// SetState updates a value for the input key
 	// stored in the account with the given address.
 	SetState(Address, Key, Value)
Index: go/carmen/transaction.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage carmen\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n)\n\ntype transactionContext struct {\n\tblockContext *commonContext\n\tstate        state.VmStateDB\n}\n\nfunc (t *transactionContext) CreateAccount(address Address) {\n\tif t.state != nil {\n\t\tt.state.CreateAccount(common.Address(address))\n\t}\n}\n\nfunc (t *transactionContext) Exist(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.Exist(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) Empty(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.Empty(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) SelfDestruct(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.Suicide(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) HasSelfDestructed(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.HasSuicided(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) GetBalance(address Address) Amount {\n\tif t.state != nil {\n\t\tamount, err := NewAmountFromBigInt(t.state.GetBalance(common.Address(address)))\n\t\tif err != nil {\n\t\t\treturn NewAmount()\n\t\t}\n\t\treturn amount\n\t}\n\treturn NewAmount()\n}\n\nfunc (t *transactionContext) AddBalance(address Address, value Amount) {\n\tif t.state != nil {\n\t\tt.state.AddBalance(common.Address(address), value.ToBig())\n\t}\n}\n\nfunc (t *transactionContext) SubBalance(address Address, value Amount) {\n\tif t.state != nil {\n\t\tt.state.SubBalance(common.Address(address), value.ToBig())\n\t}\n}\n\nfunc (t *transactionContext) GetNonce(address Address) uint64 {\n\tif t.state != nil {\n\t\treturn t.state.GetNonce(common.Address(address))\n\t}\n\treturn 0\n}\n\nfunc (t *transactionContext) SetNonce(address Address, nonce uint64) {\n\tif t.state != nil {\n\t\tt.state.SetNonce(common.Address(address), nonce)\n\t}\n}\n\nfunc (t *transactionContext) GetCommittedState(address Address, key Key) Value {\n\tif t.state != nil {\n\t\treturn Value(t.state.GetCommittedState(common.Address(address), common.Key(key)))\n\t}\n\treturn Value{}\n}\n\nfunc (t *transactionContext) GetState(address Address, key Key) Value {\n\tif t.state != nil {\n\t\treturn Value(t.state.GetState(common.Address(address), common.Key(key)))\n\t}\n\treturn Value{}\n}\n\nfunc (t *transactionContext) SetState(address Address, key Key, value Value) {\n\tif t.state != nil {\n\t\tt.state.SetState(common.Address(address), common.Key(key), common.Value(value))\n\t}\n}\n\nfunc (t *transactionContext) GetTransientState(address Address, key Key) Value {\n\tif t.state != nil {\n\t\treturn Value(t.state.GetTransientState(common.Address(address), common.Key(key)))\n\t}\n\n\treturn Value{}\n}\n\nfunc (t *transactionContext) SetTransientState(address Address, key Key, value Value) {\n\tif t.state != nil {\n\t\tt.state.SetTransientState(common.Address(address), common.Key(key), common.Value(value))\n\t}\n}\n\nfunc (t *transactionContext) GetCode(address Address) []byte {\n\tif t.state != nil {\n\t\treturn t.state.GetCode(common.Address(address))\n\t}\n\treturn []byte{}\n}\n\nfunc (t *transactionContext) SetCode(address Address, code []byte) {\n\tif t.state != nil {\n\t\tt.state.SetCode(common.Address(address), code)\n\t}\n}\n\nfunc (t *transactionContext) GetCodeHash(address Address) Hash {\n\tif t.state != nil {\n\t\treturn Hash(t.state.GetCodeHash(common.Address(address)))\n\t}\n\treturn Hash{}\n}\n\nfunc (t *transactionContext) GetCodeSize(address Address) int {\n\tif t.state != nil {\n\t\treturn t.state.GetCodeSize(common.Address(address))\n\t}\n\treturn 0\n}\n\nfunc (t *transactionContext) AddRefund(value uint64) {\n\tif t.state != nil {\n\t\tt.state.AddRefund(value)\n\t}\n}\n\nfunc (t *transactionContext) SubRefund(value uint64) {\n\tif t.state != nil {\n\t\tt.state.SubRefund(value)\n\t}\n}\n\nfunc (t *transactionContext) GetRefund() uint64 {\n\tif t.state != nil {\n\t\treturn t.state.GetRefund()\n\t}\n\treturn 0\n}\n\nfunc (t *transactionContext) AddLog(log *Log) {\n\tif t.state != nil && log != nil {\n\t\ttopics := make([]common.Hash, 0, len(log.Topics))\n\t\tfor _, topic := range log.Topics {\n\t\t\ttopics = append(topics, common.Hash(topic))\n\t\t}\n\t\tt.state.AddLog(&common.Log{\n\t\t\tAddress: common.Address(log.Address),\n\t\t\tTopics:  topics,\n\t\t\tData:    log.Data,\n\t\t\tIndex:   log.Index,\n\t\t})\n\t}\n}\n\nfunc (t *transactionContext) GetLogs() []*Log {\n\tif t.state != nil {\n\t\tlogs := t.state.GetLogs()\n\t\tres := make([]*Log, 0, len(logs))\n\t\tfor _, log := range logs {\n\t\t\ttopics := make([]Hash, 0, len(log.Topics))\n\t\t\tfor _, topic := range log.Topics {\n\t\t\t\ttopics = append(topics, Hash(topic))\n\t\t\t}\n\n\t\t\tres = append(res, &Log{\n\t\t\t\tAddress: Address(log.Address),\n\t\t\t\tTopics:  topics,\n\t\t\t\tData:    log.Data,\n\t\t\t\tIndex:   log.Index,\n\t\t\t})\n\t\t}\n\t\treturn res\n\t}\n\treturn []*Log{}\n}\n\nfunc (t *transactionContext) ClearAccessList() {\n\tif t.state != nil {\n\t\tt.state.ClearAccessList()\n\t}\n}\n\nfunc (t *transactionContext) AddAddressToAccessList(address Address) {\n\tif t.state != nil {\n\t\tt.state.AddAddressToAccessList(common.Address(address))\n\t}\n}\n\nfunc (t *transactionContext) AddSlotToAccessList(address Address, key Key) {\n\tif t.state != nil {\n\t\tt.state.AddSlotToAccessList(common.Address(address), common.Key(key))\n\t}\n}\n\nfunc (t *transactionContext) IsAddressInAccessList(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.IsAddressInAccessList(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) IsSlotInAccessList(address Address, key Key) (addressPresent bool, slotPresent bool) {\n\tif t.state != nil {\n\t\treturn t.state.IsSlotInAccessList(common.Address(address), common.Key(key))\n\t}\n\treturn false, false\n}\n\nfunc (t *transactionContext) Snapshot() int {\n\tif t.state != nil {\n\t\treturn t.state.Snapshot()\n\t}\n\treturn -1\n}\n\nfunc (t *transactionContext) RevertToSnapshot(snapshot int) {\n\tif t.state != nil {\n\t\tt.state.RevertToSnapshot(snapshot)\n\t}\n}\n\nfunc (t *transactionContext) GetStateHash() Hash {\n\treturn Hash(t.state.GetHash())\n}\n\nfunc (t *transactionContext) Commit() error {\n\tif t.state == nil {\n\t\treturn fmt.Errorf(\"transaction context is invalid\")\n\t}\n\tt.state.EndTransaction() // < commits changes\n\treturn t.end()           // < releases resources\n}\n\nfunc (t *transactionContext) Abort() error {\n\tif t.state == nil {\n\t\treturn nil\n\t}\n\tt.state.AbortTransaction()\n\treturn t.end()\n}\n\nfunc (t *transactionContext) end() error {\n\t// inform block context of ended transaction\n\tt.blockContext.releaseTxsContext()\n\tt.blockContext = nil\n\terr := t.state.Check()\n\tt.state = nil\n\treturn err\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/carmen/transaction.go b/go/carmen/transaction.go
--- a/go/carmen/transaction.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/carmen/transaction.go	(date 1718181248039)
@@ -14,6 +14,7 @@
 	"fmt"
 
 	"github.com/Fantom-foundation/Carmen/go/common"
+	"github.com/Fantom-foundation/Carmen/go/common/tribool"
 	"github.com/Fantom-foundation/Carmen/go/state"
 )
 
@@ -106,6 +107,13 @@
 	return Value{}
 }
 
+func (t *transactionContext) HasEmptyStorage(address Address) tribool.Tribool {
+	if t.state != nil {
+		return t.state.HasEmptyStorage(common.Address(address))
+	}
+	return tribool.Unknown()
+}
+
 func (t *transactionContext) SetState(address Address, key Key, value Value) {
 	if t.state != nil {
 		t.state.SetState(common.Address(address), common.Key(key), common.Value(value))
