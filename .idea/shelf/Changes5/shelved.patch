Index: go/state/gostate/go_schema2.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage gostate\n\nimport (\n\t\"crypto/sha256\"\n\t\"hash\"\n\t\"io\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/depot\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/index\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/multimap\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/store\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\n// GoSchema2 implementation of a state utilizes a schema where Addresses are indexed,\n// but slot keys are not.\n//\n// It uses addressIndex to map an address to an id\n// and the couple (addressId, slotKey) is mapped by slotIndex to the id into the valuesStore,\n// where are slots values stored.\n//\n// It uses a MultiMap to keep track of slots, which must be reset, when a contract is self-destructed.\ntype GoSchema2 struct {\n\taddressIndex    index.Index[common.Address, uint32]\n\tslotIndex       index.Index[common.SlotIdxKey[uint32], uint32]\n\taccountsStore   store.Store[uint32, common.AccountState]\n\tnoncesStore     store.Store[uint32, common.Nonce]\n\tbalancesStore   store.Store[uint32, common.Balance]\n\tvaluesStore     store.Store[uint32, common.Value]\n\tcodesDepot      depot.Depot[uint32]\n\tcodeHashesStore store.Store[uint32, common.Hash]\n\taddressToSlots  multimap.MultiMap[uint32, uint32]\n\thasher          hash.Hash\n}\n\nfunc (s *GoSchema2) CreateAccount(address common.Address) (err error) {\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = s.accountsStore.Set(idx, common.Exists)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.clearAccount(idx)\n}\n\nfunc (s *GoSchema2) Exists(address common.Address) (bool, error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\tstate, err := s.accountsStore.Get(idx)\n\treturn state == common.Exists, err\n}\n\nfunc (s *GoSchema2) DeleteAccount(address common.Address) error {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\terr = s.accountsStore.Set(idx, common.Unknown)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.clearAccount(idx)\n}\n\nfunc (s *GoSchema2) clearAccount(idx uint32) error {\n\tslotIdxs, err := s.addressToSlots.GetAll(idx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, slotIdx := range slotIdxs {\n\t\tif err := s.valuesStore.Set(slotIdx, common.Value{}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.addressToSlots.RemoveAll(idx)\n}\n\nfunc (s *GoSchema2) GetBalance(address common.Address) (balance common.Balance, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Balance{}, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.balancesStore.Get(idx)\n}\n\nfunc (s *GoSchema2) SetBalance(address common.Address, balance common.Balance) (err error) {\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.balancesStore.Set(idx, balance)\n}\n\nfunc (s *GoSchema2) GetNonce(address common.Address) (nonce common.Nonce, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Nonce{}, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.noncesStore.Get(idx)\n}\n\nfunc (s *GoSchema2) SetNonce(address common.Address, nonce common.Nonce) (err error) {\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.noncesStore.Set(idx, nonce)\n}\n\nfunc (s *GoSchema2) GetStorage(address common.Address, key common.Key) (value common.Value, err error) {\n\taddressIdx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Value{}, nil\n\t\t}\n\t\treturn\n\t}\n\tslotIdx, err := s.slotIndex.Get(common.SlotIdxKey[uint32]{AddressIdx: addressIdx, Key: key})\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Value{}, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.valuesStore.Get(slotIdx)\n}\n\nfunc (s *GoSchema2) SetStorage(address common.Address, key common.Key, value common.Value) error {\n\taddressIdx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tslotIdx, err := s.slotIndex.GetOrAdd(common.SlotIdxKey[uint32]{AddressIdx: addressIdx, Key: key})\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = s.valuesStore.Set(slotIdx, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif value == (common.Value{}) {\n\t\terr = s.addressToSlots.Remove(addressIdx, slotIdx)\n\t} else {\n\t\terr = s.addressToSlots.Add(addressIdx, slotIdx)\n\t}\n\treturn err\n}\n\nfunc (s *GoSchema2) HasEmptyStorage(address common.Address) (bool, error) {\n\t//TODO implement me\n\tpanic(\"implement me\")\n}\n\nfunc (s *GoSchema2) GetCode(address common.Address) (value []byte, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.codesDepot.Get(idx)\n}\n\nfunc (s *GoSchema2) GetCodeSize(address common.Address) (size int, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.codesDepot.GetSize(idx)\n}\n\nfunc (s *GoSchema2) SetCode(address common.Address, code []byte) (err error) {\n\tvar codeHash common.Hash\n\tif code != nil { // codeHash is zero for empty code\n\t\tif s.hasher == nil {\n\t\t\ts.hasher = sha3.NewLegacyKeccak256()\n\t\t}\n\t\tcodeHash = common.GetHash(s.hasher, code)\n\t}\n\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = s.codesDepot.Set(idx, code)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.codeHashesStore.Set(idx, codeHash)\n}\n\nfunc (s *GoSchema2) GetCodeHash(address common.Address) (hash common.Hash, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn emptyCodeHash, nil\n\t\t}\n\t\treturn\n\t}\n\thash, err = s.codeHashesStore.Get(idx)\n\tif err != nil {\n\t\treturn hash, err\n\t}\n\t// Stores use the default value in cases where there is no value present. Thus,\n\t// when returning a zero hash, we need to check whether it is indeed the case\n\t// that this is the hash of the code or whether we should actually return the\n\t// hash of the empty code.\n\tif (hash == common.Hash{}) {\n\t\tsize, err := s.GetCodeSize(address)\n\t\tif err != nil {\n\t\t\treturn hash, err\n\t\t}\n\t\tif size == 0 {\n\t\t\treturn emptyCodeHash, nil\n\t\t}\n\t}\n\treturn hash, nil\n}\n\nfunc (s *GoSchema2) GetHash() (hash common.Hash, err error) {\n\tsources := []common.HashProvider{\n\t\ts.addressIndex,\n\t\ts.slotIndex,\n\t\ts.balancesStore,\n\t\ts.noncesStore,\n\t\ts.valuesStore,\n\t\ts.accountsStore,\n\t\ts.codesDepot,\n\t\t// codeHashesStore omitted intentionally\n\t\t// addressToSlots omitted intentionally\n\t}\n\n\th := sha256.New()\n\tfor _, source := range sources {\n\t\tif hash, err = source.GetStateHash(); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif _, err = h.Write(hash[:]); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tcopy(hash[:], h.Sum(nil))\n\treturn hash, nil\n}\n\nfunc (s *GoSchema2) Apply(block uint64, update common.Update) (archiveUpdateHints common.Releaser, err error) {\n\tif err := update.Normalize(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn nil, update.ApplyTo(s)\n}\n\nfunc (s *GoSchema2) Flush() (lastErr error) {\n\tflushables := []common.Flusher{\n\t\ts.addressIndex,\n\t\ts.slotIndex,\n\t\ts.accountsStore,\n\t\ts.noncesStore,\n\t\ts.balancesStore,\n\t\ts.valuesStore,\n\t\ts.codesDepot,\n\t\ts.codeHashesStore,\n\t\ts.addressToSlots,\n\t}\n\n\tfor _, flushable := range flushables {\n\t\tif err := flushable.Flush(); err != nil {\n\t\t\tlastErr = err\n\t\t}\n\t}\n\n\treturn lastErr\n}\n\nfunc (s *GoSchema2) Close() (lastErr error) {\n\tcloseables := []io.Closer{\n\t\ts.addressIndex,\n\t\ts.slotIndex,\n\t\ts.accountsStore,\n\t\ts.noncesStore,\n\t\ts.balancesStore,\n\t\ts.valuesStore,\n\t\ts.codesDepot,\n\t\ts.codeHashesStore,\n\t\ts.addressToSlots,\n\t}\n\n\tfor _, closeable := range closeables {\n\t\tif err := closeable.Close(); err != nil {\n\t\t\tlastErr = err\n\t\t}\n\t}\n\n\treturn lastErr\n}\n\nfunc (s *GoSchema2) GetSnapshotableComponents() []backend.Snapshotable {\n\treturn nil // = snapshotting not supported\n}\n\nfunc (s *GoSchema2) RunPostRestoreTasks() error {\n\treturn backend.ErrSnapshotNotSupported\n}\n\n// GetMemoryFootprint provides sizes of individual components of the state in the memory\nfunc (s *GoSchema2) GetMemoryFootprint() *common.MemoryFootprint {\n\tmf := common.NewMemoryFootprint(0)\n\tmf.AddChild(\"addressIndex\", s.addressIndex.GetMemoryFootprint())\n\tmf.AddChild(\"slotIndex\", s.slotIndex.GetMemoryFootprint())\n\tmf.AddChild(\"accountsStore\", s.accountsStore.GetMemoryFootprint())\n\tmf.AddChild(\"noncesStore\", s.noncesStore.GetMemoryFootprint())\n\tmf.AddChild(\"balancesStore\", s.balancesStore.GetMemoryFootprint())\n\tmf.AddChild(\"valuesStore\", s.valuesStore.GetMemoryFootprint())\n\tmf.AddChild(\"codesDepot\", s.codesDepot.GetMemoryFootprint())\n\tmf.AddChild(\"codeHashesStore\", s.codeHashesStore.GetMemoryFootprint())\n\tmf.AddChild(\"addressToSlots\", s.addressToSlots.GetMemoryFootprint())\n\treturn mf\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/gostate/go_schema2.go b/go/state/gostate/go_schema2.go
--- a/go/state/gostate/go_schema2.go	(revision 15f8d5ffcf4ae609929d283d72e682431dbc3dd5)
+++ b/go/state/gostate/go_schema2.go	(date 1718001856872)
@@ -12,6 +12,7 @@
 
 import (
 	"crypto/sha256"
+	"errors"
 	"hash"
 	"io"
 
@@ -175,8 +176,23 @@
 }
 
 func (s *GoSchema2) HasEmptyStorage(address common.Address) (bool, error) {
-	//TODO implement me
-	panic("implement me")
+	addressIdx, err := s.addressIndex.Get(address)
+	if err != nil {
+		if errors.Is(err, index.ErrNotFound) {
+			return true, nil
+		}
+		return false, err
+	}
+
+	_, err = s.slotIndex.Get(common.SlotIdxKey[uint32]{AddressIdx: addressIdx})
+	if err != nil {
+		if errors.Is(err, index.ErrNotFound) {
+			return true, nil
+		}
+		return false, err
+	}
+
+	return false, nil
 }
 
 func (s *GoSchema2) GetCode(address common.Address) (value []byte, err error) {
Index: go/state/gostate/go_schema1.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage gostate\n\nimport (\n\t\"crypto/sha256\"\n\t\"hash\"\n\t\"io\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/depot\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/index\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/multimap\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/store\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\n// GoSchema1 maintains all persistent state of the blockchain. In particular,\n// it maintains the balance of accounts, accounts nonces, and storage.\n//\n// It uses addressIndex to map an address to an id,\n// keyIndex to map a slot key to a key id\n// and this couple of ids is mapped by slotIndex to the id into the valuesStore,\n// where are slots values stored.\n//\n// It uses a MultiMap to keep track of slots, which must be reset, when a contract is self-destructed.\ntype GoSchema1 struct {\n\taddressIndex    index.Index[common.Address, uint32]\n\tkeyIndex        index.Index[common.Key, uint32]\n\tslotIndex       index.Index[common.SlotIdx[uint32], uint32]\n\taccountsStore   store.Store[uint32, common.AccountState]\n\tnoncesStore     store.Store[uint32, common.Nonce]\n\tbalancesStore   store.Store[uint32, common.Balance]\n\tvaluesStore     store.Store[uint32, common.Value]\n\tcodesDepot      depot.Depot[uint32]\n\tcodeHashesStore store.Store[uint32, common.Hash]\n\taddressToSlots  multimap.MultiMap[uint32, uint32]\n\thasher          hash.Hash\n}\n\nfunc (s *GoSchema1) CreateAccount(address common.Address) (err error) {\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = s.accountsStore.Set(idx, common.Exists)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.clearAccount(idx)\n}\n\nfunc (s *GoSchema1) Exists(address common.Address) (bool, error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\tstate, err := s.accountsStore.Get(idx)\n\treturn state == common.Exists, err\n}\n\nfunc (s *GoSchema1) DeleteAccount(address common.Address) error {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\terr = s.accountsStore.Set(idx, common.Unknown)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.clearAccount(idx)\n}\n\nfunc (s *GoSchema1) clearAccount(idx uint32) error {\n\tslotIdxs, err := s.addressToSlots.GetAll(idx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, slotIdx := range slotIdxs {\n\t\tif err := s.valuesStore.Set(slotIdx, common.Value{}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.addressToSlots.RemoveAll(idx)\n}\n\nfunc (s *GoSchema1) GetBalance(address common.Address) (balance common.Balance, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Balance{}, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.balancesStore.Get(idx)\n}\n\nfunc (s *GoSchema1) SetBalance(address common.Address, balance common.Balance) (err error) {\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.balancesStore.Set(idx, balance)\n}\n\nfunc (s *GoSchema1) GetNonce(address common.Address) (nonce common.Nonce, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Nonce{}, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.noncesStore.Get(idx)\n}\n\nfunc (s *GoSchema1) SetNonce(address common.Address, nonce common.Nonce) (err error) {\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.noncesStore.Set(idx, nonce)\n}\n\nfunc (s *GoSchema1) GetStorage(address common.Address, key common.Key) (value common.Value, err error) {\n\taddressIdx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Value{}, nil\n\t\t}\n\t\treturn\n\t}\n\tkeyIdx, err := s.keyIndex.Get(key)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Value{}, nil\n\t\t}\n\t\treturn\n\t}\n\tslotIdx, err := s.slotIndex.Get(common.SlotIdx[uint32]{AddressIdx: addressIdx, KeyIdx: keyIdx})\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn common.Value{}, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.valuesStore.Get(slotIdx)\n}\n\nfunc (s *GoSchema1) SetStorage(address common.Address, key common.Key, value common.Value) error {\n\taddressIdx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tkeyIdx, err := s.keyIndex.GetOrAdd(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\tslotIdx, err := s.slotIndex.GetOrAdd(common.SlotIdx[uint32]{AddressIdx: addressIdx, KeyIdx: keyIdx})\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = s.valuesStore.Set(slotIdx, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif value == (common.Value{}) {\n\t\terr = s.addressToSlots.Remove(addressIdx, slotIdx)\n\t} else {\n\t\terr = s.addressToSlots.Add(addressIdx, slotIdx)\n\t}\n\treturn err\n}\n\nfunc (s *GoSchema1) HasEmptyStorage(address common.Address) (bool, error) {\n\t//TODO implement me\n\tpanic(\"implement me\")\n}\n\nfunc (s *GoSchema1) GetCode(address common.Address) (value []byte, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.codesDepot.Get(idx)\n}\n\nfunc (s *GoSchema1) GetCodeSize(address common.Address) (size int, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn\n\t}\n\treturn s.codesDepot.GetSize(idx)\n}\n\nfunc (s *GoSchema1) SetCode(address common.Address, code []byte) (err error) {\n\tvar codeHash common.Hash\n\tif code != nil { // codeHash is zero for empty code\n\t\tif s.hasher == nil {\n\t\t\ts.hasher = sha3.NewLegacyKeccak256()\n\t\t}\n\t\tcodeHash = common.GetHash(s.hasher, code)\n\t}\n\n\tidx, err := s.addressIndex.GetOrAdd(address)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = s.codesDepot.Set(idx, code)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn s.codeHashesStore.Set(idx, codeHash)\n}\n\nfunc (s *GoSchema1) GetCodeHash(address common.Address) (hash common.Hash, err error) {\n\tidx, err := s.addressIndex.Get(address)\n\tif err != nil {\n\t\tif err == index.ErrNotFound {\n\t\t\treturn emptyCodeHash, nil\n\t\t}\n\t\treturn\n\t}\n\thash, err = s.codeHashesStore.Get(idx)\n\tif err != nil {\n\t\treturn hash, err\n\t}\n\t// Stores use the default value in cases where there is no value present. Thus,\n\t// when returning a zero hash, we need to check whether it is indeed the case\n\t// that this is the hash of the code or whether we should actually return the\n\t// hash of the empty code.\n\tif (hash == common.Hash{}) {\n\t\tsize, err := s.GetCodeSize(address)\n\t\tif err != nil {\n\t\t\treturn hash, err\n\t\t}\n\t\tif size == 0 {\n\t\t\treturn emptyCodeHash, nil\n\t\t}\n\t}\n\treturn hash, nil\n}\n\nfunc (s *GoSchema1) GetHash() (hash common.Hash, err error) {\n\tsources := []common.HashProvider{\n\t\ts.addressIndex,\n\t\ts.keyIndex,\n\t\ts.slotIndex,\n\t\ts.balancesStore,\n\t\ts.noncesStore,\n\t\ts.valuesStore,\n\t\ts.accountsStore,\n\t\ts.codesDepot,\n\t\t// codeHashesStore omitted intentionally\n\t\t// addressToSlots omitted intentionally\n\t}\n\n\th := sha256.New()\n\tfor _, source := range sources {\n\t\tif hash, err = source.GetStateHash(); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif _, err = h.Write(hash[:]); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tcopy(hash[:], h.Sum(nil))\n\treturn hash, nil\n}\n\nfunc (s *GoSchema1) Apply(block uint64, update common.Update) (archiveUpdateHints common.Releaser, err error) {\n\tif err := update.Normalize(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn nil, update.ApplyTo(s)\n}\n\nfunc (s *GoSchema1) Flush() (lastErr error) {\n\tflushables := []common.Flusher{\n\t\ts.addressIndex,\n\t\ts.keyIndex,\n\t\ts.slotIndex,\n\t\ts.accountsStore,\n\t\ts.noncesStore,\n\t\ts.balancesStore,\n\t\ts.valuesStore,\n\t\ts.codesDepot,\n\t\ts.codeHashesStore,\n\t\ts.addressToSlots,\n\t}\n\n\tfor _, flushable := range flushables {\n\t\tif err := flushable.Flush(); err != nil {\n\t\t\tlastErr = err\n\t\t}\n\t}\n\n\treturn lastErr\n}\n\nfunc (s *GoSchema1) Close() (lastErr error) {\n\tcloseables := []io.Closer{\n\t\ts.addressIndex,\n\t\ts.keyIndex,\n\t\ts.slotIndex,\n\t\ts.accountsStore,\n\t\ts.noncesStore,\n\t\ts.balancesStore,\n\t\ts.valuesStore,\n\t\ts.codesDepot,\n\t\ts.codeHashesStore,\n\t\ts.addressToSlots,\n\t}\n\n\tfor _, closeable := range closeables {\n\t\tif err := closeable.Close(); err != nil {\n\t\t\tlastErr = err\n\t\t}\n\t}\n\n\treturn lastErr\n}\n\nfunc (s *GoSchema1) GetSnapshotableComponents() []backend.Snapshotable {\n\treturn nil // = snapshotting not supported\n}\n\nfunc (s *GoSchema1) RunPostRestoreTasks() error {\n\treturn backend.ErrSnapshotNotSupported\n}\n\n// GetMemoryFootprint provides sizes of individual components of the state in the memory\nfunc (s *GoSchema1) GetMemoryFootprint() *common.MemoryFootprint {\n\tmf := common.NewMemoryFootprint(0)\n\tmf.AddChild(\"addressIndex\", s.addressIndex.GetMemoryFootprint())\n\tmf.AddChild(\"keyIndex\", s.keyIndex.GetMemoryFootprint())\n\tmf.AddChild(\"slotIndex\", s.slotIndex.GetMemoryFootprint())\n\tmf.AddChild(\"accountsStore\", s.accountsStore.GetMemoryFootprint())\n\tmf.AddChild(\"noncesStore\", s.noncesStore.GetMemoryFootprint())\n\tmf.AddChild(\"balancesStore\", s.balancesStore.GetMemoryFootprint())\n\tmf.AddChild(\"valuesStore\", s.valuesStore.GetMemoryFootprint())\n\tmf.AddChild(\"codesDepot\", s.codesDepot.GetMemoryFootprint())\n\tmf.AddChild(\"codeHashesStore\", s.codeHashesStore.GetMemoryFootprint())\n\tmf.AddChild(\"addressToSlots\", s.addressToSlots.GetMemoryFootprint())\n\treturn mf\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/gostate/go_schema1.go b/go/state/gostate/go_schema1.go
--- a/go/state/gostate/go_schema1.go	(revision 15f8d5ffcf4ae609929d283d72e682431dbc3dd5)
+++ b/go/state/gostate/go_schema1.go	(date 1717924126762)
@@ -12,6 +12,7 @@
 
 import (
 	"crypto/sha256"
+	"errors"
 	"hash"
 	"io"
 
@@ -188,8 +189,23 @@
 }
 
 func (s *GoSchema1) HasEmptyStorage(address common.Address) (bool, error) {
-	//TODO implement me
-	panic("implement me")
+	addressIdx, err := s.addressIndex.Get(address)
+	if err != nil {
+		if errors.Is(err, index.ErrNotFound) {
+			return true, nil
+		}
+		return false, err
+	}
+
+	_, err = s.slotIndex.Get(common.SlotIdx[uint32]{AddressIdx: addressIdx})
+	if err != nil {
+		if errors.Is(err, index.ErrNotFound) {
+			return true, nil
+		}
+		return false, err
+	}
+
+	return false, nil
 }
 
 func (s *GoSchema1) GetCode(address common.Address) (value []byte, err error) {
