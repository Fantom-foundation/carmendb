Index: go/carmen/transaction.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage carmen\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n)\n\ntype transactionContext struct {\n\tblockContext *commonContext\n\tstate        state.VmStateDB\n}\n\nfunc (t *transactionContext) CreateAccount(address Address) {\n\tif t.state != nil {\n\t\tt.state.CreateAccount(common.Address(address))\n\t}\n}\n\nfunc (t *transactionContext) Exist(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.Exist(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) Empty(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.Empty(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) SelfDestruct(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.Suicide(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) HasSelfDestructed(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.HasSuicided(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) GetBalance(address Address) Amount {\n\tif t.state != nil {\n\t\tamount, err := NewAmountFromBigInt(t.state.GetBalance(common.Address(address)))\n\t\tif err != nil {\n\t\t\treturn NewAmount()\n\t\t}\n\t\treturn amount\n\t}\n\treturn NewAmount()\n}\n\nfunc (t *transactionContext) AddBalance(address Address, value Amount) {\n\tif t.state != nil {\n\t\tt.state.AddBalance(common.Address(address), value.ToBig())\n\t}\n}\n\nfunc (t *transactionContext) SubBalance(address Address, value Amount) {\n\tif t.state != nil {\n\t\tt.state.SubBalance(common.Address(address), value.ToBig())\n\t}\n}\n\nfunc (t *transactionContext) GetNonce(address Address) uint64 {\n\tif t.state != nil {\n\t\treturn t.state.GetNonce(common.Address(address))\n\t}\n\treturn 0\n}\n\nfunc (t *transactionContext) SetNonce(address Address, nonce uint64) {\n\tif t.state != nil {\n\t\tt.state.SetNonce(common.Address(address), nonce)\n\t}\n}\n\nfunc (t *transactionContext) GetCommittedState(address Address, key Key) Value {\n\tif t.state != nil {\n\t\treturn Value(t.state.GetCommittedState(common.Address(address), common.Key(key)))\n\t}\n\treturn Value{}\n}\n\nfunc (t *transactionContext) GetState(address Address, key Key) Value {\n\tif t.state != nil {\n\t\treturn Value(t.state.GetState(common.Address(address), common.Key(key)))\n\t}\n\treturn Value{}\n}\n\nfunc (t *transactionContext) SetState(address Address, key Key, value Value) {\n\tif t.state != nil {\n\t\tt.state.SetState(common.Address(address), common.Key(key), common.Value(value))\n\t}\n}\n\nfunc (t *transactionContext) GetTransientState(address Address, key Key) Value {\n\tif t.state != nil {\n\t\treturn Value(t.state.GetTransientState(common.Address(address), common.Key(key)))\n\t}\n\n\treturn Value{}\n}\n\nfunc (t *transactionContext) SetTransientState(address Address, key Key, value Value) {\n\tif t.state != nil {\n\t\tt.state.SetTransientState(common.Address(address), common.Key(key), common.Value(value))\n\t}\n}\n\nfunc (t *transactionContext) GetCode(address Address) []byte {\n\tif t.state != nil {\n\t\treturn t.state.GetCode(common.Address(address))\n\t}\n\treturn []byte{}\n}\n\nfunc (t *transactionContext) SetCode(address Address, code []byte) {\n\tif t.state != nil {\n\t\tt.state.SetCode(common.Address(address), code)\n\t}\n}\n\nfunc (t *transactionContext) GetCodeHash(address Address) Hash {\n\tif t.state != nil {\n\t\treturn Hash(t.state.GetCodeHash(common.Address(address)))\n\t}\n\treturn Hash{}\n}\n\nfunc (t *transactionContext) GetCodeSize(address Address) int {\n\tif t.state != nil {\n\t\treturn t.state.GetCodeSize(common.Address(address))\n\t}\n\treturn 0\n}\n\nfunc (t *transactionContext) AddRefund(value uint64) {\n\tif t.state != nil {\n\t\tt.state.AddRefund(value)\n\t}\n}\n\nfunc (t *transactionContext) SubRefund(value uint64) {\n\tif t.state != nil {\n\t\tt.state.SubRefund(value)\n\t}\n}\n\nfunc (t *transactionContext) GetRefund() uint64 {\n\tif t.state != nil {\n\t\treturn t.state.GetRefund()\n\t}\n\treturn 0\n}\n\nfunc (t *transactionContext) AddLog(log *Log) {\n\tif t.state != nil && log != nil {\n\t\ttopics := make([]common.Hash, 0, len(log.Topics))\n\t\tfor _, topic := range log.Topics {\n\t\t\ttopics = append(topics, common.Hash(topic))\n\t\t}\n\t\tt.state.AddLog(&common.Log{\n\t\t\tAddress: common.Address(log.Address),\n\t\t\tTopics:  topics,\n\t\t\tData:    log.Data,\n\t\t\tIndex:   log.Index,\n\t\t})\n\t}\n}\n\nfunc (t *transactionContext) GetLogs() []*Log {\n\tif t.state != nil {\n\t\tlogs := t.state.GetLogs()\n\t\tres := make([]*Log, 0, len(logs))\n\t\tfor _, log := range logs {\n\t\t\ttopics := make([]Hash, 0, len(log.Topics))\n\t\t\tfor _, topic := range log.Topics {\n\t\t\t\ttopics = append(topics, Hash(topic))\n\t\t\t}\n\n\t\t\tres = append(res, &Log{\n\t\t\t\tAddress: Address(log.Address),\n\t\t\t\tTopics:  topics,\n\t\t\t\tData:    log.Data,\n\t\t\t\tIndex:   log.Index,\n\t\t\t})\n\t\t}\n\t\treturn res\n\t}\n\treturn []*Log{}\n}\n\nfunc (t *transactionContext) ClearAccessList() {\n\tif t.state != nil {\n\t\tt.state.ClearAccessList()\n\t}\n}\n\nfunc (t *transactionContext) AddAddressToAccessList(address Address) {\n\tif t.state != nil {\n\t\tt.state.AddAddressToAccessList(common.Address(address))\n\t}\n}\n\nfunc (t *transactionContext) AddSlotToAccessList(address Address, key Key) {\n\tif t.state != nil {\n\t\tt.state.AddSlotToAccessList(common.Address(address), common.Key(key))\n\t}\n}\n\nfunc (t *transactionContext) IsAddressInAccessList(address Address) bool {\n\tif t.state != nil {\n\t\treturn t.state.IsAddressInAccessList(common.Address(address))\n\t}\n\treturn false\n}\n\nfunc (t *transactionContext) IsSlotInAccessList(address Address, key Key) (addressPresent bool, slotPresent bool) {\n\tif t.state != nil {\n\t\treturn t.state.IsSlotInAccessList(common.Address(address), common.Key(key))\n\t}\n\treturn false, false\n}\n\nfunc (t *transactionContext) Snapshot() int {\n\tif t.state != nil {\n\t\treturn t.state.Snapshot()\n\t}\n\treturn -1\n}\n\nfunc (t *transactionContext) RevertToSnapshot(snapshot int) {\n\tif t.state != nil {\n\t\tt.state.RevertToSnapshot(snapshot)\n\t}\n}\n\nfunc (t *transactionContext) GetStateHash() Hash {\n\treturn Hash(t.state.GetHash())\n}\n\nfunc (t *transactionContext) Commit() error {\n\tif t.state == nil {\n\t\treturn fmt.Errorf(\"transaction context is invalid\")\n\t}\n\tt.state.EndTransaction() // < commits changes\n\treturn t.end()           // < releases resources\n}\n\nfunc (t *transactionContext) Abort() error {\n\tif t.state == nil {\n\t\treturn nil\n\t}\n\tt.state.AbortTransaction()\n\treturn t.end()\n}\n\nfunc (t *transactionContext) end() error {\n\t// inform block context of ended transaction\n\tt.blockContext.releaseTxsContext()\n\tt.blockContext = nil\n\terr := t.state.Check()\n\tt.state = nil\n\treturn err\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/carmen/transaction.go b/go/carmen/transaction.go
--- a/go/carmen/transaction.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/carmen/transaction.go	(date 1718181014428)
@@ -14,6 +14,7 @@
 	"fmt"
 
 	"github.com/Fantom-foundation/Carmen/go/common"
+	"github.com/Fantom-foundation/Carmen/go/common/tribool"
 	"github.com/Fantom-foundation/Carmen/go/state"
 )
 
@@ -106,6 +107,13 @@
 	return Value{}
 }
 
+func (t *transactionContext) HasEmptyStorage(address Address) tribool.Tribool {
+	if t.state != nil {
+		return t.state.HasEmptyStorage(common.Address(address))
+	}
+	return tribool.Unknown()
+}
+
 func (t *transactionContext) SetState(address Address, key Key, value Value) {
 	if t.state != nil {
 		t.state.SetState(common.Address(address), common.Key(key), common.Value(value))
