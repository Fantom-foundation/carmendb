Index: go/carmen/database_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage carmen\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n\t\"go.uber.org/mock/gomock\"\n)\n\n// openTestDatabase creates database with test configuration in a test directory.\nfunc openTestDatabase(t *testing.T) (Database, error) {\n\treturn OpenDatabase(t.TempDir(), testConfig, testProperties)\n}\n\nfunc TestDatabase_OpenWorksForFreshDirectory(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_OpenFailsForInvalidDirectory(t *testing.T) {\n\tpath := filepath.Join(t.TempDir(), \"some_file.dat\")\n\tif err := os.WriteFile(path, []byte(\"hello\"), 0600); err != nil {\n\t\tt.Fatalf(\"failed to create test file: %v\", err)\n\t}\n\t_, err := OpenDatabase(path, testConfig, testProperties)\n\tif err == nil {\n\t\tt.Fatalf(\"expected an error, got nothing\")\n\t}\n}\n\nfunc TestDatabase_CloseTwice_SecondCallFails(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\tif err := db.Close(); err == nil {\n\t\tt.Fatalf(\"closing already closed database should fail\")\n\t}\n}\n\nfunc TestDatabase_CloseFails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstateDB.EXPECT().Close().AnyTimes().Return(injectedErr)\n\tstateDB.EXPECT().Flush().AnyTimes().Return(nil)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tif err := db.Close(); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"unexpected error: %v != %v\", err, injectedErr)\n\t}\n}\n\nfunc TestDatabase_FlushFails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstateDB.EXPECT().Flush().AnyTimes().Return(injectedErr)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tif err := db.Flush(); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"unexpected error: %s != %v\", err, injectedErr)\n\t}\n\n\tif err := db.Close(); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"unexpected error: %s != %v\", err, injectedErr)\n\t}\n}\n\nfunc TestDatabase_QueryBlock_UnderlyingDB_Fails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstate.EXPECT().GetArchiveState(gomock.Any()).Return(nil, injectedErr)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tif err := db.QueryBlock(0, func(context HistoricBlockContext) error {\n\t\treturn nil\n\t}); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"archive query should fail\")\n\t}\n}\n\nfunc TestDatabase_QueryHeadState_UnderlyingDBQuery_Fails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstate.EXPECT().GetHash().Return(common.Hash{}, injectedErr)\n\tstate.EXPECT().Check()\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\terr := db.QueryHeadState(func(context QueryContext) {\n\t\tcontext.GetStateHash()\n\t})\n\tif !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"head state query should have failed, got %v\", err)\n\t}\n}\n\nfunc TestDatabase_QueryHeadState_UnderlyingDB_Fails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstate.EXPECT().GetHash().Return(common.Hash{}, nil)\n\tstate.EXPECT().Check().Return(injectedErr)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\terr := db.QueryHeadState(func(context QueryContext) {\n\t\tcontext.GetStateHash()\n\t})\n\tif !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"head state query should have failed, got %v\", err)\n\t}\n}\n\nfunc TestDatabase_GetBlockHeight_UnderlyingDB_Fails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstateDB.EXPECT().GetArchiveBlockHeight().Return(uint64(0), true, injectedErr)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tif _, err := db.GetArchiveBlockHeight(); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"archive query should fail\")\n\t}\n}\n\nfunc TestDatabase_GetBlockHeight_EmptyArchive(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tstateDB.EXPECT().GetArchiveBlockHeight().Return(uint64(0), true, nil)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tblock, err := db.GetArchiveBlockHeight()\n\tif err != nil {\n\t\tt.Errorf(\"cannot get block height: %v\", err)\n\t}\n\n\tif block >= 0 {\n\t\tt.Errorf(\"non archive database should return negative block number, was: %d\", block)\n\t}\n}\n\nfunc TestDatabase_GetHistoricStateHash_UnderlyingDB_Fails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstate.EXPECT().GetArchiveState(gomock.Any()).Return(nil, injectedErr)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tif _, err := db.GetHistoricStateHash(0); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"archive query should fail\")\n\t}\n}\n\nfunc TestDatabase_GetHistoricStateHash_UnderlyingDB_FailsGettingHash(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tst := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tsubSt := state.NewMockState(ctrl)\n\tsubSt.EXPECT().GetHash().Return(common.Hash{}, injectedErr)\n\tsubSt.EXPECT().Check().Times(2).Return(nil)\n\n\tst.EXPECT().GetArchiveState(gomock.Any()).Return(subSt, nil)\n\n\tdb := &database{\n\t\tdb:    st,\n\t\tstate: stateDB,\n\t}\n\n\tif _, err := db.GetHistoricStateHash(0); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"archive query should fail\")\n\t}\n}\n\nfunc TestDatabase_GetHistoricContext_UnderlyingDB_Fails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstate.EXPECT().GetArchiveState(gomock.Any()).Return(nil, injectedErr)\n\n\tdb := &database{\n\t\tdb:    state,\n\t\tstate: stateDB,\n\t}\n\n\tif _, err := db.GetHistoricContext(0); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"archive query should fail\")\n\t}\n}\n\nfunc TestDatabase_OpeningArchiveFails(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tstateDB := state.NewMockStateDB(ctrl)\n\tstate := state.NewMockState(ctrl)\n\tstate.EXPECT().Close()\n\n\tinjectedErr := fmt.Errorf(\"injectedErr\")\n\tstateDB.EXPECT().GetArchiveBlockHeight().Return(uint64(0), false, injectedErr)\n\tstateDB.EXPECT().Close()\n\n\tif _, err := openStateDb(state, stateDB); !errors.Is(err, injectedErr) {\n\t\tt.Errorf(\"opening archive should fail\")\n\t}\n}\n\nfunc TestDatabase_OpenFailsForInvalidProperty(t *testing.T) {\n\ttests := map[string]struct {\n\t\tproperty Property\n\t\tvalue    string\n\t}{\n\t\t\"liveCache-not-an-int\": {\n\t\t\tproperty: LiveDBCache,\n\t\t\tvalue:    \"hello\",\n\t\t},\n\t\t\"archiveCache-not-an-int\": {\n\t\t\tproperty: ArchiveCache,\n\t\t\tvalue:    \"hello\",\n\t\t},\n\t\t\"StorageCache-not-an-int\": {\n\t\t\tproperty: StorageCache,\n\t\t\tvalue:    \"hello\",\n\t\t},\n\t}\n\n\tfor name, test := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tproperties := Properties{}\n\t\t\tproperties[test.property] = test.value\n\t\t\t_, err := OpenDatabase(t.TempDir(), testConfig, properties)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error, got nothing\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHeadBlockContext_CanCreateSequenceOfBlocks(t *testing.T) {\n\tfor _, config := range []Configuration{testConfig, testNonArchiveConfig} {\n\t\tt.Run(fmt.Sprintf(\"%v\", config), func(t *testing.T) {\n\t\t\tdb, err := OpenDatabase(t.TempDir(), config, testProperties)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t\t\t}\n\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tblock, err := db.BeginBlock(uint64(i))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to create block %d: %v\", i, err)\n\t\t\t\t}\n\t\t\t\tif err := block.Abort(); err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to abort block %d: %v\", i, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := db.Close(); err != nil {\n\t\t\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDatabase_CannotStartMultipleBlocksAtOnce(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tblock, err := db.BeginBlock(12)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start block: %v\", err)\n\t}\n\n\t_, err = db.BeginBlock(14)\n\tif err == nil {\n\t\tt.Fatalf(\"opening two head blocks at the same time should fail\")\n\t}\n\n\tif err := block.Abort(); err != nil {\n\t\tt.Fatalf(\"failed to abort head block: %v\", err)\n\t}\n\n\tblock, err = db.BeginBlock(12)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start block: %v\", err)\n\t}\n\n\tif err := block.Abort(); err != nil {\n\t\tt.Fatalf(\"failed to abort head block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_BulkLoadProducesBlocks(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tload, err := db.StartBulkLoad(12)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to start bulk-load: %v\", err)\n\t}\n\n\tload.CreateAccount(Address{1})\n\tload.SetNonce(Address{1}, 12)\n\tload.CreateAccount(Address{2})\n\tload.SetNonce(Address{2}, 14)\n\n\tif err := load.Finalize(); err != nil {\n\t\tt.Fatalf(\"failed to finalize bulk load: %v\", err)\n\t}\n\n\terr = errors.Join(\n\t\tdb.QueryBlock(11, func(bc HistoricBlockContext) error {\n\t\t\treturn errors.Join(\n\t\t\t\tbc.RunTransaction(func(tc TransactionContext) error {\n\t\t\t\t\tif tc.Exist(Address{1}) {\n\t\t\t\t\t\tt.Errorf(\"account 1 should not exist\")\n\t\t\t\t\t}\n\t\t\t\t\tif tc.Exist(Address{2}) {\n\t\t\t\t\t\tt.Errorf(\"account 2 should not exist\")\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t)\n\t\t}),\n\t\tdb.QueryBlock(12, func(bc HistoricBlockContext) error {\n\t\t\treturn errors.Join(\n\t\t\t\tbc.RunTransaction(func(tc TransactionContext) error {\n\t\t\t\t\tif !tc.Exist(Address{1}) {\n\t\t\t\t\t\tt.Errorf(\"account 1 should exist\")\n\t\t\t\t\t}\n\t\t\t\t\tif want, got := uint64(12), tc.GetNonce(Address{1}); want != got {\n\t\t\t\t\t\tt.Errorf(\"unexpected nonce, wanted %v, got %v\", want, got)\n\t\t\t\t\t}\n\t\t\t\t\tif !tc.Exist(Address{2}) {\n\t\t\t\t\t\tt.Errorf(\"account 2 should exist\")\n\t\t\t\t\t}\n\t\t\t\t\tif want, got := uint64(14), tc.GetNonce(Address{2}); want != got {\n\t\t\t\t\t\tt.Errorf(\"unexpected nonce, wanted %v, got %v\", want, got)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}),\n\t\t\t)\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error during query evaluation: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_BeginBlock_InvalidBlock(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tbctx, err := db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Commit(); err != nil {\n\t\tt.Fatalf(\"cannot commit block: %v\", err)\n\t}\n\n\t// cannot start the same block\n\t_, err = db.BeginBlock(5)\n\tif err == nil {\n\t\tt.Errorf(\"beginning duplicated block should fail\")\n\t}\n\n\t// cannot start older block\n\t_, err = db.BeginBlock(3)\n\tif err == nil {\n\t\tt.Errorf(\"beginning older block should fail\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_BeginBlock_InvalidBlock_ReopenDB(t *testing.T) {\n\tdir := t.TempDir()\n\tdb, err := OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tbctx, err := db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Commit(); err != nil {\n\t\tt.Fatalf(\"cannot commit block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// cannot start the same block\n\t_, err = db.BeginBlock(5)\n\tif err == nil {\n\t\tt.Errorf(\"beginning duplicated block should fail\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// cannot start older block\n\t_, err = db.BeginBlock(3)\n\tif err == nil {\n\t\tt.Errorf(\"beginning older block should fail\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_BeginBlock_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\t// cannot start the block\n\t_, err = db.BeginBlock(5)\n\tif err == nil {\n\t\tt.Errorf(\"beginning block should fail\")\n\t}\n}\n\nfunc TestDatabase_BeginBlock_CanStartAbortedBlock(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tbctx, err := db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Abort(); err != nil {\n\t\tt.Fatalf(\"cannot abort block: %v\", err)\n\t}\n\n\t// can start the same block\n\tbctx, err = db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Errorf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Commit(); err != nil {\n\t\tt.Fatalf(\"cannot commit block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_BeginBlock_CanStartAbortedBlock_ReopenDB(t *testing.T) {\n\tdir := t.TempDir()\n\tdb, err := OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tbctx, err := db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Abort(); err != nil {\n\t\tt.Fatalf(\"cannot abort block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// can start the same block\n\tbctx, err = db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Errorf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Commit(); err != nil {\n\t\tt.Fatalf(\"cannot commit block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// can start the next block\n\tbctx, err = db.BeginBlock(6)\n\tif err != nil {\n\t\tt.Errorf(\"cannot begin block: %v\", err)\n\t}\n\tif err := bctx.Commit(); err != nil {\n\t\tt.Fatalf(\"cannot commit block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_InvalidBlock(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t}\n\n\t// cannot start the same block\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err == nil {\n\t\tt.Errorf(\"adding duplicated block should fail\")\n\t}\n\n\t// cannot start older block\n\tif err := db.AddBlock(3, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err == nil {\n\t\tt.Errorf(\"adding older block should fail\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_ReopenDB(t *testing.T) {\n\tdir := t.TempDir()\n\tdb, err := OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// cannot start the same block\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err == nil {\n\t\tt.Errorf(\"adding duplicated block should fail\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// cannot start older block\n\tif err := db.AddBlock(3, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err == nil {\n\t\tt.Errorf(\"adding older block should fail\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_CanStartAbortedBlock(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn fmt.Errorf(\"injectedError\")\n\t}); err == nil {\n\t\tt.Fatalf(\"block should be aborted\")\n\t}\n\n\t// can start the same block\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Errorf(\"cannot add block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_CanStartAbortedBlock_ReopenDB(t *testing.T) {\n\tdir := t.TempDir()\n\tdb, err := OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn fmt.Errorf(\"injectedError\")\n\t}); err == nil {\n\t\tt.Fatalf(\"block should be aborted\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tdb, err = OpenDatabase(dir, testConfig, testProperties)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// can start the same block\n\tif err := db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Errorf(\"cannot add block: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\t// cannot start the block\n\terr = db.AddBlock(5, func(context HeadBlockContext) error {\n\t\treturn nil\n\t})\n\tif err == nil {\n\t\tt.Errorf(\"adding block should fail\")\n\t}\n}\n\nfunc TestDatabase_CloseDB_Uncommitted_Block(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatalf(\"cannot abort ctx: %v\", err)\n\t\t}\n\t}()\n\n\tctx, err := db.BeginBlock(5)\n\tif err != nil {\n\t\tt.Errorf(\"cannot begin block: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := ctx.Abort(); err != nil {\n\t\t\tt.Fatalf(\"cannot abort ctx: %v\", err)\n\t\t}\n\t}()\n\n\tif err := db.Close(); !errors.Is(err, errBlockContextRunning) {\n\t\tt.Fatalf(\"closing database should fail while block is not committed\")\n\t}\n\n}\n\nfunc TestDatabase_CloseDB_Unfinished_Queries(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.AddBlock(0, func(context HeadBlockContext) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t}\n\n\tif err := db.Flush(); err != nil {\n\t\tt.Fatalf(\"cannot flush db: %v\", err)\n\t}\n\n\tconst loops = 10\n\tctxs := make([]HistoricBlockContext, 0, loops)\n\tfor i := 0; i < loops; i++ {\n\t\tctx, err := db.GetHistoricContext(0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"cannot get history: %v\", err)\n\t\t}\n\t\tctxs = append(ctxs, ctx)\n\t}\n\n\t// each close should fail as there are running queries\n\tfor i := 0; i < loops; i++ {\n\t\tif err := db.Close(); !errors.Is(err, errBlockContextRunning) {\n\t\t\tt.Fatalf(\"closing database should fail while block is not committed\")\n\t\t}\n\t\tif err := ctxs[i].Close(); err != nil {\n\t\t\tt.Fatalf(\"cannot close query: %v\", err)\n\t\t}\n\t}\n\n\t// all history queries closed, db can be closed\n\tif err := db.Close(); err != nil {\n\t\tt.Errorf(\"db cannot be closed: %v\", err)\n\t}\n}\n\nfunc TestDatabase_BeginBlock_Parallel(t *testing.T) {\n\tconst loops = 100\n\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tsuccess := &atomic.Int32{}\n\twg := &sync.WaitGroup{}\n\twg.Add(loops)\n\tfor i := 0; i < loops; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tbctx, err := db.BeginBlock(uint64(i))\n\t\t\t// once the block could be created, it must be able to commit\n\t\t\tif err == nil {\n\t\t\t\tif err := bctx.Commit(); err != nil {\n\t\t\t\t\tt.Errorf(\"cannot commit block: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tsuccess.Add(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tif success.Load() == 0 {\n\t\tt.Errorf(\"no block was added\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_Parallel(t *testing.T) {\n\tconst loops = 100\n\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tsuccess := &atomic.Int32{}\n\twg := &sync.WaitGroup{}\n\twg.Add(loops)\n\tfor i := 0; i < loops; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\terr := db.AddBlock(uint64(i), func(context HeadBlockContext) error {\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err == nil {\n\t\t\t\tsuccess.Add(1)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tif success.Load() == 0 {\n\t\tt.Errorf(\"no block was added\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_GetHistoricBlock_Parallel(t *testing.T) {\n\tconst loops = 100\n\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// init a few blocks\n\tfor i := 0; i < loops; i++ {\n\t\tif err := db.AddBlock(uint64(i), func(context HeadBlockContext) error {\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t\t}\n\t}\n\n\tif err := db.Flush(); err != nil {\n\t\tt.Fatalf(\"cannot flush db: %v\", err)\n\t}\n\n\twg := &sync.WaitGroup{}\n\twg.Add(loops)\n\tfor i := 0; i < loops; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tbctx, err := db.GetHistoricContext(uint64(i))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"cannot get historic block: %v\", err)\n\t\t\t}\n\t\t\tif err := bctx.Close(); err != nil {\n\t\t\t\tt.Errorf(\"cannot commit block: %v\", err)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_QueryBlock_Parallel(t *testing.T) {\n\tconst loops = 100\n\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// init a few blocks\n\tfor i := 0; i < loops; i++ {\n\t\tif err := db.AddBlock(uint64(i), func(context HeadBlockContext) error {\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t\t}\n\t}\n\n\tif err := db.Flush(); err != nil {\n\t\tt.Fatalf(\"cannot flush db: %v\", err)\n\t}\n\n\twg := &sync.WaitGroup{}\n\twg.Add(loops)\n\tfor i := 0; i < loops; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := db.QueryBlock(uint64(i), func(context HistoricBlockContext) error {\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Errorf(\"cannot query block: %v\", err)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_AddBlock_QueryBlock_Parallel(t *testing.T) {\n\tconst loops = 100\n\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\t// init a few blocks\n\tfor i := 0; i < loops; i++ {\n\t\tif err := db.AddBlock(uint64(i), func(context HeadBlockContext) error {\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t\t}\n\t}\n\n\tif err := db.Flush(); err != nil {\n\t\tt.Fatalf(\"cannot flush db: %v\", err)\n\t}\n\n\t// keep adding more blocks while querying already created once\n\twg := &sync.WaitGroup{}\n\twg.Add(loops)\n\tfor i := 0; i < loops; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := db.QueryBlock(uint64(i), func(context HistoricBlockContext) error {\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Errorf(\"cannot query block: %v\", err)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Add(loops)\n\tadded := &atomic.Int32{}\n\tfor i := 0; i < loops; i++ {\n\t\tgo func(block int) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := db.AddBlock(uint64(block), func(context HeadBlockContext) error {\n\t\t\t\treturn nil\n\t\t\t}); err == nil {\n\t\t\t\tadded.Add(1)\n\t\t\t}\n\t\t}(i + loops)\n\t}\n\n\twg.Wait()\n\n\tif added.Load() == 0 {\n\t\tt.Errorf(\"no block was added\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_QueryBlock_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tif err := db.QueryBlock(0, func(context HistoricBlockContext) error {\n\t\treturn nil\n\t}); !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"should not be able to query closed database\")\n\t}\n}\n\nfunc TestDatabase_QueryHeadState_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tif err := db.QueryHeadState(nil); !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"should not be able to query closed database\")\n\t}\n}\n\nfunc TestDatabase_GetBlockHeight_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tif _, err := db.GetArchiveBlockHeight(); !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"should not be able to query closed database\")\n\t}\n}\n\nfunc TestDatabase_GetHistoricStateHash_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tif _, err := db.GetHistoricStateHash(0); !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"should not be able to query closed database\")\n\t}\n}\n\nfunc TestDatabase_GetHistoricContext_NonExistingBlock(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatalf(\"cannot close db: %v\", err)\n\t\t}\n\t}()\n\n\tif _, err := db.GetHistoricContext(100); err == nil {\n\t\tt.Errorf(\"should not be able to query non-existing block\")\n\t}\n}\n\nfunc TestDatabase_GetHistoricContext_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tif _, err := db.GetHistoricContext(0); !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"should not be able to query closed database\")\n\t}\n}\n\nfunc TestDatabase_Historic_Block_Available(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\taddr := Address{1}\n\tif err := db.AddBlock(0, func(context HeadBlockContext) error {\n\t\tif err := context.RunTransaction(func(context TransactionContext) error {\n\t\t\tcontext.CreateAccount(addr)\n\t\t\tcontext.AddBalance(addr, NewAmount(1000))\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"cannot commit transaction: %v\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t}\n\n\tconst loops = 10\n\tfor i := 1; i < loops; i++ {\n\t\t// cannot start the same block\n\t\tif err := db.AddBlock(uint64(i), func(context HeadBlockContext) error {\n\t\t\tif err := context.RunTransaction(func(context TransactionContext) error {\n\t\t\t\tcontext.AddBalance(addr, NewAmount(100))\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatalf(\"cannot commit transaction: %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t\t}\n\t}\n\n\tif err := db.Flush(); err != nil {\n\t\tt.Fatalf(\"cannot flush db: %v\", err)\n\t}\n\n\tvar transactions int\n\t// query historic blocks\n\tfor i := 0; i < loops; i++ {\n\t\terr := db.QueryBlock(uint64(i), func(context HistoricBlockContext) error {\n\t\t\tif err := context.RunTransaction(func(context TransactionContext) error {\n\t\t\t\tif got, want := context.GetBalance(addr), NewAmount(uint64(i*100)+1000); got != want {\n\t\t\t\t\tt.Errorf(\"balance does not match for block: %d, got: %d != wanted: %d\", i, got, want)\n\t\t\t\t}\n\t\t\t\ttransactions++\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Errorf(\"cannot run transaction: %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to query block %d: %v\", i, err)\n\t\t}\n\t}\n\n\tif transactions != loops {\n\t\tt.Errorf(\"not all historic blocks were visited: %d\", transactions)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_StartBulkLoad_Can_Run_Consecutive(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tfor i := 0; i < 20; i++ {\n\t\tctx, err := db.StartBulkLoad(uint64(i))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"cannot start bulk load: %v\", err)\n\t\t}\n\t\tif err := ctx.Finalize(); err != nil {\n\t\t\tt.Errorf(\"cannot finish bulk load: %v\", err)\n\t\t}\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_StartBulkLoad_ClosedDB(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\tif _, err := db.StartBulkLoad(0); !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"should not be able to query closed database\")\n\t}\n}\n\nfunc TestDatabase_StartBulkLoad_Cannot_Start_Twice(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tctx, err := db.StartBulkLoad(0)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot start bulk load: %v\", err)\n\t}\n\n\tif _, err := db.StartBulkLoad(0); !errors.Is(err, errBlockContextRunning) {\n\t\tt.Errorf(\"should not be able to run bulk load\")\n\t}\n\n\tif err := ctx.Finalize(); err != nil {\n\t\tt.Fatalf(\"cannot finish bulk load: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_StartBulkLoad_Cannot_Start_Wrong_Block(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tctx, err := db.StartBulkLoad(10)\n\tif err != nil {\n\t\tt.Errorf(\"cannot start bulk load: %v\", err)\n\t}\n\tif err := ctx.Finalize(); err != nil {\n\t\tt.Errorf(\"cannot finish bulk load: %v\", err)\n\t}\n\n\tif _, err := db.StartBulkLoad(3); err == nil {\n\t\tt.Errorf(\"block should be out of range\")\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n}\n\nfunc TestDatabase_StartBulkLoad_Cannot_Finalize_Twice(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatalf(\"cannot close db: %v\", err)\n\t\t}\n\t}()\n\n\tctx, err := db.StartBulkLoad(0)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot start bulk load: %v\", err)\n\t}\n\n\tif err := ctx.Finalize(); err != nil {\n\t\tt.Fatalf(\"cannot finish bulk load: %v\", err)\n\t}\n\n\tif err := ctx.Finalize(); err == nil {\n\t\tt.Errorf(\"second call to finalize should fail\")\n\t}\n}\n\nfunc TestDatabase_Async_AddBlock_QueryHistory_Close_ShouldNotThrowUnexpectedError(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\taddBlock := func(block uint64) error {\n\t\treturn db.AddBlock(block, func(context HeadBlockContext) error {\n\t\t\tif err := context.RunTransaction(func(context TransactionContext) error {\n\t\t\t\taddr := Address{byte(block)}\n\t\t\t\tcontext.CreateAccount(addr)\n\t\t\t\tcontext.AddBalance(addr, NewAmount(100))\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatalf(\"cannot commit transaction: %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\n\t// init a few blocks\n\tconst loops = 10\n\tfor i := 0; i < loops; i++ {\n\t\tif err := addBlock(uint64(i)); err != nil {\n\t\t\tt.Fatalf(\"cannot add block: %v\", err)\n\t\t}\n\t}\n\n\tif err := db.Flush(); err != nil {\n\t\tt.Fatalf(\"cannot flush: %v\", err)\n\t}\n\n\tminHeadUpdates := &atomic.Int32{}\n\tminHeadUpdates.Add(100)\n\n\tminHistoricQueries := &atomic.Int32{}\n\tminHistoricQueries.Add(100)\n\n\t// run parallel update to the head state\n\tgo func() {\n\t\tblock := loops\n\t\tfor {\n\t\t\tif err := addBlock(uint64(block)); err != nil {\n\t\t\t\tif errors.Is(err, errDbClosed) {\n\t\t\t\t\tbreak // this is ok, db was closed in parallel\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock++\n\t\t\tminHeadUpdates.Add(-1)\n\t\t}\n\t}()\n\n\t// parallel queries to existing blocks\n\tgo func() {\n\t\tfor {\n\t\t\tif _, err := db.GetArchiveBlockHeight(); err != nil {\n\t\t\t\tif errors.Is(err, errDbClosed) {\n\t\t\t\t\tbreak // this is ok, db was closed in parallel\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tminHistoricQueries.Add(-1)\n\t\t}\n\t}()\n\tgo func() {\n\t\tvar block uint64\n\t\tfor {\n\t\t\tctx, err := db.GetHistoricContext(block % loops)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, errDbClosed) {\n\t\t\t\t\tbreak // this is ok, db was closed in parallel\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := ctx.Close(); err != nil {\n\t\t\t\tt.Errorf(\"cannot close context: %v\", err)\n\t\t\t}\n\t\t\tblock++\n\t\t\tminHistoricQueries.Add(-1)\n\t\t}\n\t}()\n\tgo func() {\n\t\tvar block uint64\n\t\tfor {\n\t\t\tif _, err := db.GetHistoricStateHash(block % loops); err != nil {\n\t\t\t\tif errors.Is(err, errDbClosed) {\n\t\t\t\t\tbreak // this is ok, db was closed in parallel\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock++\n\t\t\tminHistoricQueries.Add(-1)\n\t\t}\n\t}()\n\tgo func() {\n\t\tvar block uint64\n\t\tfor {\n\t\t\tif err := db.QueryBlock(block%loops, func(context HistoricBlockContext) error {\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tif errors.Is(err, errDbClosed) {\n\t\t\t\t\tbreak // this is ok, db was closed in parallel\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tblock++\n\t\t\tminHistoricQueries.Add(-1)\n\t\t}\n\t}()\n\n\t// make sure some queries happen before an attempt to close\n\tfor minHeadUpdates.Load() > 0 || minHistoricQueries.Load() > 0 {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\t// parallel close of the database\n\t// should not cause other than expected error\n\tfor {\n\t\tif err := db.Close(); err == nil {\n\t\t\tbreak // db was closed, we are done\n\t\t} else {\n\t\t\t// concurrent access is ok, just repeat attempt to close again\n\t\t\tif !errors.Is(err, errBlockContextRunning) {\n\t\t\t\tt.Errorf(\"failed to close database: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDatabase_Async_QueryHead_Accesses_ConsistentState(t *testing.T) {\n\t// This test case checks that query operations see a consistent state\n\t// when running concurrent updates.\n\tconst (\n\t\tnumReaders = 10\n\t\tnumBlocks  = 100\n\t)\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatalf(\"cannot close db: %v\", err)\n\t\t}\n\t}()\n\n\taddr1 := Address{1}\n\taddr2 := Address{2}\n\n\t// Have a few goroutines testing that nonces are in sync.\n\tvar group sync.WaitGroup\n\tgroup.Add(numReaders)\n\tfor i := 0; i < numReaders; i++ {\n\t\tgo func() {\n\t\t\tdefer group.Done()\n\t\t\tnonce := uint64(0)\n\t\t\tfor nonce < numBlocks {\n\t\t\t\terr := db.QueryHeadState(func(ctxt QueryContext) {\n\t\t\t\t\t// Readers should always see the same nonces.\n\t\t\t\t\tn1 := ctxt.GetNonce(addr1)\n\t\t\t\t\tn2 := ctxt.GetNonce(addr2)\n\t\t\t\t\tif n1 != n2 {\n\t\t\t\t\t\tt.Errorf(\"nonces out of sync: %d vs %d\", n1, n2)\n\t\t\t\t\t}\n\t\t\t\t\tnonce = n1\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"failed to query head: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Add blocks updating nonces in sync.\n\tfor i := 1; i <= numBlocks; i++ {\n\t\tblock := uint64(i)\n\t\terr := db.AddBlock(block, func(context HeadBlockContext) error {\n\t\t\tif err := context.RunTransaction(func(context TransactionContext) error {\n\t\t\t\t// In all blocks the nonces of both accounts are identical.\n\t\t\t\tcontext.SetNonce(addr1, block)\n\t\t\t\tcontext.SetNonce(addr2, block)\n\t\t\t\treturn nil\n\t\t\t}); err != nil {\n\t\t\t\tt.Fatalf(\"cannot commit transaction: %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to add block %d: %v\", i, err)\n\t\t}\n\t}\n\n\tgroup.Wait()\n}\n\nfunc TestDatabase_ActiveHeadQueryBlockDataBaseClose(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tqueryStarted := make(chan bool)\n\tdone := &atomic.Bool{}\n\tgo db.QueryHeadState(func(QueryContext) {\n\t\tdefer wg.Done()\n\t\tqueryStarted <- true\n\t\t// keep this alive to block the closing of the database\n\t\ttime.Sleep(time.Second)\n\t\tdone.Store(true)\n\t})\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t<-queryStarted\n\t\t// This should block until all queries are done\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Errorf(\"cannot close db: %v\", err)\n\t\t}\n\t\tif !done.Load() {\n\t\t\tt.Errorf(\"finished closing before queries are complete\")\n\t\t}\n\t}()\n\n\twg.Wait()\n}\n\nfunc TestDatabase_QueryCannotBeStartedOnClosedDatabase(t *testing.T) {\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open database: %v\", err)\n\t}\n\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close database: %v\", err)\n\t}\n\n\terr = db.QueryHeadState(func(QueryContext) {})\n\tif !errors.Is(err, errDbClosed) {\n\t\tt.Errorf(\"Starting a query on a closed database should have failed, got %v\", err)\n\t}\n}\n\nfunc TestDatabase_ArchiveCanBeAccessedAsync(t *testing.T) {\n\tconst numBlocks = 1000\n\taddr1 := Address{1}\n\n\tdb, err := openTestDatabase(t)\n\tif err != nil {\n\t\tt.Fatalf(\"cannot open database: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatalf(\"cannot close db: %v\", err)\n\t\t}\n\t}()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\t// query archive\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\theight, err := db.GetArchiveBlockHeight()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"cannot get archive height: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif height >= 0 {\n\t\t\t\tctx, err := db.GetHistoricContext(uint64(height))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"cannot get historic context: height: %d,  %v\", height, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err := ctx.Close(); err != nil {\n\t\t\t\t\tt.Errorf(\"cannot close ctx: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif height >= numBlocks {\n\t\t\t\treturn // we are done, all blocks ready in the archive -> no error so far\n\t\t\t}\n\t\t}\n\t}()\n\n\t// add blocks\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 1; i <= numBlocks; i++ {\n\t\t\tblock := uint64(i)\n\t\t\terr := db.AddBlock(block, func(context HeadBlockContext) error {\n\t\t\t\tif err := context.RunTransaction(func(context TransactionContext) error {\n\t\t\t\t\t// In all blocks, the nonces of both accounts are identical.\n\t\t\t\t\tcontext.SetNonce(addr1, block)\n\t\t\t\t\treturn nil\n\t\t\t\t}); err != nil {\n\t\t\t\t\tt.Errorf(\"cannot commit transaction: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to add block %d: %v\", i, err)\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait()\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/carmen/database_test.go b/go/carmen/database_test.go
--- a/go/carmen/database_test.go	(revision d08cfe185f06b6745d25e9cf6140326252e1685c)
+++ b/go/carmen/database_test.go	(date 1718700353470)
@@ -1640,3 +1640,40 @@
 
 	wg.Wait()
 }
+
+func TestDatabase_HasEmptyStorage(t *testing.T) {
+	ctrl := gomock.NewController(t)
+	stateDB := state.NewMockStateDB(ctrl)
+	state := state.NewMockState(ctrl)
+	addr := Address{0x1}
+
+	state.EXPECT().HasEmptyStorage(common.Address(addr))
+	state.EXPECT().Check()
+	stateDB.EXPECT().HasEmptyStorage(common.Address(addr))
+
+	db := &database{
+		db:    state,
+		state: stateDB,
+	}
+
+	defer db.Close()
+
+	err := db.QueryHeadState(func(context QueryContext) {
+		context.HasEmptyStorage(addr)
+	})
+	if err != nil {
+		t.Fatalf("unexpected err: %v", err)
+	}
+
+	bCtx, err := db.BeginBlock(1)
+	if err != nil {
+		t.Fatalf("unexpected err: %v", err)
+	}
+
+	tCtx, err := bCtx.BeginTransaction()
+	if err != nil {
+		t.Fatalf("unexpected err: %v", err)
+	}
+
+	tCtx.HasEmptyStorage(addr)
+}
