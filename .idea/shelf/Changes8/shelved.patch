Index: go/state/cppstate/cpp_state.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage cppstate\n\n//go:generate sh ../../lib/build_libcarmen.sh\n\n/*\n#cgo CFLAGS: -I${SRCDIR}/../../../cpp\n#cgo LDFLAGS: -L${SRCDIR}/../../lib -lcarmen\n#cgo LDFLAGS: -Wl,-rpath,${SRCDIR}/../../lib\n#include <stdlib.h>\n#include \"state/c_state.h\"\n*/\nimport \"C\"\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"unsafe\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n)\n\nconst CodeCacheSize = 8_000 // ~ 200 MiB of memory for go-side code cache\nconst CodeMaxSize = 25000   // Contract limit is 24577\n\n// CppState implements the state interface by forwarding all calls to a C++ based implementation.\ntype CppState struct {\n\t// A pointer to an owned C++ object containing the actual state information.\n\tstate unsafe.Pointer\n\t// cache of contract codes\n\tcodeCache *common.LruCache[common.Address, []byte]\n}\n\nfunc newState(impl C.enum_StateImpl, params state.Parameters) (state.State, error) {\n\tif err := os.MkdirAll(filepath.Join(params.Directory, \"live\"), 0700); err != nil {\n\t\treturn nil, err\n\t}\n\tdir := C.CString(params.Directory)\n\tdefer C.free(unsafe.Pointer(dir))\n\n\tarchive := 0\n\tswitch params.Archive {\n\tcase state.ArchiveType(\"\"), state.NoArchive:\n\t\tarchive = 0\n\tcase state.LevelDbArchive:\n\t\tarchive = 1\n\tcase state.SqliteArchive:\n\t\tarchive = 2\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"%w: unsupported archive type %v\", state.UnsupportedConfiguration, params.Archive)\n\t}\n\n\tst := C.Carmen_OpenState(C.C_Schema(params.Schema), impl, C.enum_StateImpl(archive), dir, C.int(len(params.Directory)))\n\tif st == unsafe.Pointer(nil) {\n\t\treturn nil, fmt.Errorf(\"%w: failed to create C++ state instance for parameters %v\", state.UnsupportedConfiguration, params)\n\t}\n\n\treturn state.WrapIntoSyncedState(&CppState{\n\t\tstate:     st,\n\t\tcodeCache: common.NewLruCache[common.Address, []byte](CodeCacheSize),\n\t}), nil\n}\n\nfunc newInMemoryState(params state.Parameters) (state.State, error) {\n\treturn newState(C.kState_Memory, params)\n}\n\nfunc newFileBasedState(params state.Parameters) (state.State, error) {\n\treturn newState(C.kState_File, params)\n}\n\nfunc newLevelDbBasedState(params state.Parameters) (state.State, error) {\n\treturn newState(C.kState_LevelDb, params)\n}\n\nfunc (cs *CppState) CreateAccount(address common.Address) error {\n\tupdate := common.Update{}\n\tupdate.AppendCreateAccount(address)\n\treturn cs.Apply(0, update)\n}\n\nfunc (cs *CppState) Exists(address common.Address) (bool, error) {\n\tvar res common.AccountState\n\tC.Carmen_GetAccountState(cs.state, unsafe.Pointer(&address[0]), unsafe.Pointer(&res))\n\treturn res == common.Exists, nil\n}\n\nfunc (cs *CppState) DeleteAccount(address common.Address) error {\n\tupdate := common.Update{}\n\tupdate.AppendDeleteAccount(address)\n\treturn cs.Apply(0, update)\n}\n\nfunc (cs *CppState) GetBalance(address common.Address) (common.Balance, error) {\n\tvar balance common.Balance\n\tC.Carmen_GetBalance(cs.state, unsafe.Pointer(&address[0]), unsafe.Pointer(&balance[0]))\n\treturn balance, nil\n}\n\nfunc (cs *CppState) SetBalance(address common.Address, balance common.Balance) error {\n\tupdate := common.Update{}\n\tupdate.AppendBalanceUpdate(address, balance)\n\treturn cs.Apply(0, update)\n}\n\nfunc (cs *CppState) GetNonce(address common.Address) (common.Nonce, error) {\n\tvar nonce common.Nonce\n\tC.Carmen_GetNonce(cs.state, unsafe.Pointer(&address[0]), unsafe.Pointer(&nonce[0]))\n\treturn nonce, nil\n}\n\nfunc (cs *CppState) SetNonce(address common.Address, nonce common.Nonce) error {\n\tupdate := common.Update{}\n\tupdate.AppendNonceUpdate(address, nonce)\n\treturn cs.Apply(0, update)\n}\n\nfunc (cs *CppState) GetStorage(address common.Address, key common.Key) (common.Value, error) {\n\tvar value common.Value\n\tC.Carmen_GetStorageValue(cs.state, unsafe.Pointer(&address[0]), unsafe.Pointer(&key[0]), unsafe.Pointer(&value[0]))\n\treturn value, nil\n}\n\nfunc (cs *CppState) SetStorage(address common.Address, key common.Key, value common.Value) error {\n\tupdate := common.Update{}\n\tupdate.AppendSlotUpdate(address, key, value)\n\treturn cs.Apply(0, update)\n}\n\nfunc (cs *CppState) GetCode(address common.Address) ([]byte, error) {\n\t// Try to obtain the code from the cache\n\tcode, exists := cs.codeCache.Get(address)\n\tif exists {\n\t\treturn code, nil\n\t}\n\n\t// Load the code from C++\n\tcode = make([]byte, CodeMaxSize)\n\tvar size C.uint32_t = CodeMaxSize\n\tC.Carmen_GetCode(cs.state, unsafe.Pointer(&address[0]), unsafe.Pointer(&code[0]), &size)\n\tif size >= CodeMaxSize {\n\t\treturn nil, fmt.Errorf(\"unable to load contract exceeding maximum capacity of %d\", CodeMaxSize)\n\t}\n\tif size > 0 {\n\t\tcode = code[0:size]\n\t} else {\n\t\tcode = nil\n\t}\n\tcs.codeCache.Set(address, code)\n\treturn code, nil\n}\n\nfunc (cs *CppState) SetCode(address common.Address, code []byte) error {\n\tupdate := common.Update{}\n\tupdate.AppendCodeUpdate(address, code)\n\treturn cs.Apply(0, update)\n}\n\nfunc (cs *CppState) GetCodeHash(address common.Address) (common.Hash, error) {\n\tvar hash common.Hash\n\tC.Carmen_GetCodeHash(cs.state, unsafe.Pointer(&address[0]), unsafe.Pointer(&hash[0]))\n\treturn hash, nil\n}\n\nfunc (cs *CppState) GetCodeSize(address common.Address) (int, error) {\n\tvar size C.uint32_t\n\tC.Carmen_GetCodeSize(cs.state, unsafe.Pointer(&address[0]), &size)\n\treturn int(size), nil\n}\n\nfunc (cs *CppState) GetHash() (common.Hash, error) {\n\tvar hash common.Hash\n\tC.Carmen_GetHash(cs.state, unsafe.Pointer(&hash[0]))\n\treturn hash, nil\n}\n\nfunc (cs *CppState) Apply(block uint64, update common.Update) error {\n\tif update.IsEmpty() {\n\t\treturn nil\n\t}\n\tif err := update.Normalize(); err != nil {\n\t\treturn err\n\t}\n\tdata := update.ToBytes()\n\tdataPtr := unsafe.Pointer(&data[0])\n\tC.Carmen_Apply(cs.state, C.uint64_t(block), dataPtr, C.uint64_t(len(data)))\n\t// Apply code changes to Go-sided code cache.\n\tfor _, change := range update.Codes {\n\t\tcs.codeCache.Set(change.Account, change.Code)\n\t}\n\treturn nil\n}\n\nfunc (cs *CppState) Flush() error {\n\tC.Carmen_Flush(cs.state)\n\treturn nil\n}\n\nfunc (cs *CppState) Close() error {\n\tif cs.state != nil {\n\t\tC.Carmen_Close(cs.state)\n\t\tC.Carmen_ReleaseState(cs.state)\n\t\tcs.state = nil\n\t}\n\treturn nil\n}\n\nfunc (s *CppState) GetProof() (backend.Proof, error) {\n\treturn nil, backend.ErrSnapshotNotSupported\n}\n\nfunc (s *CppState) CreateSnapshot() (backend.Snapshot, error) {\n\treturn nil, backend.ErrSnapshotNotSupported\n}\n\nfunc (s *CppState) Restore(data backend.SnapshotData) error {\n\treturn backend.ErrSnapshotNotSupported\n}\n\nfunc (s *CppState) GetSnapshotVerifier(metadata []byte) (backend.SnapshotVerifier, error) {\n\treturn nil, backend.ErrSnapshotNotSupported\n}\n\nfunc (cs *CppState) GetMemoryFootprint() *common.MemoryFootprint {\n\tif cs.state == nil {\n\t\treturn common.NewMemoryFootprint(unsafe.Sizeof(*cs))\n\t}\n\n\t// Fetch footprint data from C++.\n\tvar buffer *C.char\n\tvar size C.uint64_t\n\tC.Carmen_GetMemoryFootprint(cs.state, &buffer, &size)\n\tdefer func() {\n\t\tC.free(unsafe.Pointer(buffer))\n\t}()\n\n\tdata := C.GoBytes(unsafe.Pointer(buffer), C.int(size))\n\n\t// Use an index map mapping object IDs to memory footprints to facilitate\n\t// sharing of sub-structures.\n\tindex := map[objectId]*common.MemoryFootprint{}\n\tres, unusedData := parseCMemoryFootprint(data, index)\n\tif len(unusedData) != 0 {\n\t\tpanic(\"Failed to consume all of the provided footprint data\")\n\t}\n\n\tres.AddChild(\"goCodeCache\", cs.codeCache.GetDynamicMemoryFootprint(func(code []byte) uintptr {\n\t\treturn uintptr(cap(code)) // memory consumed by the code slice\n\t}))\n\treturn res\n}\n\nfunc (cs *CppState) GetArchiveState(block uint64) (state.State, error) {\n\treturn &CppState{\n\t\tstate:     C.Carmen_GetArchiveState(cs.state, C.uint64_t(block)),\n\t\tcodeCache: common.NewLruCache[common.Address, []byte](CodeCacheSize),\n\t}, nil\n}\n\nfunc (cs *CppState) GetArchiveBlockHeight() (uint64, bool, error) {\n\treturn 0, false, state.NoArchiveError\n}\n\nfunc (cs *CppState) Check() error {\n\t// TODO: implement, see https://github.com/Fantom-foundation/Carmen/issues/313\n\treturn nil\n}\n\ntype objectId struct {\n\tobj_loc, obj_type uint64\n}\n\nfunc (o *objectId) isUnique() bool {\n\treturn o.obj_loc == 0 && o.obj_type == 0\n}\n\nfunc readUint32(data []byte) (uint32, []byte) {\n\treturn binary.LittleEndian.Uint32(data[:4]), data[4:]\n}\n\nfunc readUint64(data []byte) (uint64, []byte) {\n\treturn binary.LittleEndian.Uint64(data[:8]), data[8:]\n}\n\nfunc readObjectId(data []byte) (objectId, []byte) {\n\tobj_loc, data := readUint64(data)\n\tobj_type, data := readUint64(data)\n\treturn objectId{obj_loc, obj_type}, data\n}\n\nfunc readString(data []byte) (string, []byte) {\n\tlength, data := readUint32(data)\n\treturn string(data[:length]), data[length:]\n}\n\nfunc parseCMemoryFootprint(data []byte, index map[objectId]*common.MemoryFootprint) (*common.MemoryFootprint, []byte) {\n\t// 1) read object ID\n\tobjId, data := readObjectId(data)\n\n\t// 2) read memory usage\n\tmemUsage, data := readUint64(data)\n\tres := common.NewMemoryFootprint(uintptr(memUsage))\n\n\t// 3) read number of sub-components\n\tnum_components, data := readUint32(data)\n\n\t// 4) read sub-components\n\tfor i := 0; i < int(num_components); i++ {\n\t\tvar label string\n\t\tlabel, data = readString(data)\n\t\tvar child *common.MemoryFootprint\n\t\tchild, data = parseCMemoryFootprint(data, index)\n\t\tres.AddChild(label, child)\n\t}\n\n\t// Unique objects are not cached since they shall not be reused.\n\tif objId.isUnique() {\n\t\treturn res, data\n\t}\n\n\t// Return representative instance based on object ID.\n\tif represent, exists := index[objId]; exists {\n\t\treturn represent, data\n\t}\n\tindex[objId] = res\n\treturn res, data\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/cppstate/cpp_state.go b/go/state/cppstate/cpp_state.go
--- a/go/state/cppstate/cpp_state.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/state/cppstate/cpp_state.go	(date 1718180581592)
@@ -140,6 +140,10 @@
 	return cs.Apply(0, update)
 }
 
+func (cs *CppState) HasEmptyStorage(address common.Address) (bool, error) {
+	panic("HasEmptyStorage: not yet implemented for Cpp State")
+}
+
 func (cs *CppState) GetCode(address common.Address) ([]byte, error) {
 	// Try to obtain the code from the cache
 	code, exists := cs.codeCache.Get(address)
Index: go/state/gostate/archive_state.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage gostate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"unsafe\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/archive\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\n// ArchiveState represents a historical State. Loads data from the Archive.\ntype ArchiveState struct {\n\tarchive      archive.Archive\n\tblock        uint64\n\tarchiveError error\n}\n\nfunc (s *ArchiveState) Exists(address common.Address) (bool, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn false, err\n\t}\n\n\texists, err := s.archive.Exists(s.block, address)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t}\n\treturn exists, s.archiveError\n}\n\nfunc (s *ArchiveState) GetBalance(address common.Address) (common.Balance, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn common.Balance{}, err\n\t}\n\n\tbalance, err := s.archive.GetBalance(s.block, address)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t}\n\treturn balance, s.archiveError\n}\n\nfunc (s *ArchiveState) GetNonce(address common.Address) (common.Nonce, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn common.Nonce{}, err\n\t}\n\n\tnonce, err := s.archive.GetNonce(s.block, address)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t}\n\treturn nonce, s.archiveError\n}\n\nfunc (s *ArchiveState) GetStorage(address common.Address, key common.Key) (common.Value, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn common.Value{}, err\n\t}\n\n\tstorage, err := s.archive.GetStorage(s.block, address, key)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t}\n\treturn storage, s.archiveError\n}\n\nfunc (s *ArchiveState) GetCode(address common.Address) ([]byte, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn []byte{}, err\n\t}\n\n\tcode, err := s.archive.GetCode(s.block, address)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t}\n\treturn code, s.archiveError\n}\n\nfunc (s *ArchiveState) GetCodeSize(address common.Address) (size int, err error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn 0, err\n\t}\n\n\tcode, err := s.archive.GetCode(s.block, address)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t\treturn 0, s.archiveError\n\t}\n\treturn len(code), s.archiveError\n}\n\nfunc (s *ArchiveState) GetCodeHash(address common.Address) (hash common.Hash, err error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\n\tcode, err := s.archive.GetCode(s.block, address)\n\tif err != nil || len(code) == 0 {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t\treturn emptyCodeHash, s.archiveError\n\t}\n\thasher := sha3.NewLegacyKeccak256()\n\tcodeHash := common.GetHash(hasher, code)\n\treturn codeHash, s.archiveError\n}\n\nfunc (s *ArchiveState) Apply(block uint64, update common.Update) error {\n\tpanic(\"ArchiveState does not support Apply operation\")\n}\n\nfunc (s *ArchiveState) GetHash() (common.Hash, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\n\thash, err := s.archive.GetHash(s.block)\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t}\n\treturn hash, s.archiveError\n}\n\n// GetMemoryFootprint provides sizes of individual components of the state in the memory\nfunc (s *ArchiveState) GetMemoryFootprint() *common.MemoryFootprint {\n\treturn common.NewMemoryFootprint(unsafe.Sizeof(*s))\n}\n\nfunc (s *ArchiveState) Flush() error {\n\tpanic(\"ArchiveState does not support Flush operation\")\n}\n\nfunc (s *ArchiveState) Close() error {\n\t// no-op in ArchiveState\n\treturn nil\n}\n\nfunc (s *ArchiveState) GetProof() (backend.Proof, error) {\n\treturn nil, backend.ErrSnapshotNotSupported\n}\n\nfunc (s *ArchiveState) CreateSnapshot() (backend.Snapshot, error) {\n\treturn nil, backend.ErrSnapshotNotSupported\n}\n\nfunc (s *ArchiveState) Restore(data backend.SnapshotData) error {\n\treturn backend.ErrSnapshotNotSupported\n}\n\nfunc (s *ArchiveState) GetSnapshotVerifier(metadata []byte) (backend.SnapshotVerifier, error) {\n\treturn nil, backend.ErrSnapshotNotSupported\n}\n\nfunc (s *ArchiveState) GetArchiveState(block uint64) (state.State, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn nil, err\n\t}\n\n\theight, empty, err := s.archive.GetBlockHeight()\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t\treturn nil, errors.Join(fmt.Errorf(\"failed to get block height from the archive: %w\", s.archiveError))\n\t}\n\tif empty || block > height {\n\t\treturn nil, fmt.Errorf(\"block %d is not present in the archive (empty: %v, height %d)\", block, empty, height)\n\t}\n\treturn &ArchiveState{\n\t\tarchive:      s.archive,\n\t\tblock:        block,\n\t\tarchiveError: s.archiveError,\n\t}, s.archiveError\n}\n\nfunc (s *ArchiveState) GetArchiveBlockHeight() (uint64, bool, error) {\n\tif err := s.archiveError; err != nil {\n\t\treturn 0, false, err\n\t}\n\n\theight, empty, err := s.archive.GetBlockHeight()\n\tif err != nil {\n\t\ts.archiveError = errors.Join(s.archiveError, err)\n\t\treturn 0, false, errors.Join(fmt.Errorf(\"failed to get last block in the archive: %w\", s.archiveError))\n\t}\n\treturn height, empty, s.archiveError\n}\n\nfunc (s *ArchiveState) Check() error {\n\treturn s.archiveError\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/gostate/archive_state.go b/go/state/gostate/archive_state.go
--- a/go/state/gostate/archive_state.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/state/gostate/archive_state.go	(date 1718180616730)
@@ -77,6 +77,10 @@
 	return storage, s.archiveError
 }
 
+func (s *ArchiveState) HasEmptyStorage(address common.Address) (bool, error) {
+	panic("HasEmptyStorage: not yet implemented for Archive State")
+}
+
 func (s *ArchiveState) GetCode(address common.Address) ([]byte, error) {
 	if err := s.archiveError; err != nil {
 		return []byte{}, err
Index: go/state/synced_state.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage state\n\nimport (\n\t\"sync\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n)\n\n// syncedState wraps a state implementation with a lock restricting the\n// number of concurrent access to one for the underlying state.\ntype syncedState struct {\n\tstate State\n\tmu    sync.Mutex\n}\n\n// WrapIntoSyncedState wraps the given state into a synchronized state\n// ensuring mutual exclusive access to the underlying state.\nfunc WrapIntoSyncedState(state State) State {\n\tif _, ok := state.(*syncedState); ok {\n\t\treturn state\n\t}\n\treturn &syncedState{\n\t\tstate: state,\n\t}\n}\n\n// UnsafeUnwrapSyncedState obtains a reference to a potentially nested\n// synchronized state from the given state.\n// Note: extracting the state from within a synchronized state breaks\n// the synchronization guarantees for the synced state. Concurrent\n// operations on the given state and the resulting state are no longer\n// mutual exclusive.\nfunc UnsafeUnwrapSyncedState(state State) State {\n\tif syncedState, ok := state.(*syncedState); ok {\n\t\treturn syncedState.state\n\t}\n\treturn state\n}\n\nfunc (s *syncedState) Exists(address common.Address) (bool, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.Exists(address)\n}\n\nfunc (s *syncedState) GetBalance(address common.Address) (common.Balance, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetBalance(address)\n}\n\nfunc (s *syncedState) GetNonce(address common.Address) (common.Nonce, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetNonce(address)\n}\n\nfunc (s *syncedState) GetStorage(address common.Address, key common.Key) (common.Value, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetStorage(address, key)\n}\n\nfunc (s *syncedState) GetCode(address common.Address) ([]byte, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetCode(address)\n}\n\nfunc (s *syncedState) GetCodeSize(address common.Address) (int, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetCodeSize(address)\n}\n\nfunc (s *syncedState) GetCodeHash(address common.Address) (common.Hash, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetCodeHash(address)\n}\n\nfunc (s *syncedState) Apply(block uint64, update common.Update) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.Apply(block, update)\n}\n\nfunc (s *syncedState) GetHash() (common.Hash, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetHash()\n}\n\nfunc (s *syncedState) Flush() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.Flush()\n}\n\nfunc (s *syncedState) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.Close()\n}\n\nfunc (s *syncedState) GetMemoryFootprint() *common.MemoryFootprint {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetMemoryFootprint()\n}\n\nfunc (s *syncedState) GetArchiveState(block uint64) (State, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetArchiveState(block)\n}\n\nfunc (s *syncedState) GetArchiveBlockHeight() (uint64, bool, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetArchiveBlockHeight()\n}\n\nfunc (s *syncedState) Check() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.Check()\n}\n\nfunc (s *syncedState) GetProof() (backend.Proof, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetProof()\n}\n\nfunc (s *syncedState) CreateSnapshot() (backend.Snapshot, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.CreateSnapshot()\n}\n\nfunc (s *syncedState) Restore(data backend.SnapshotData) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.Restore(data)\n}\n\nfunc (s *syncedState) GetSnapshotVerifier(metadata []byte) (backend.SnapshotVerifier, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.state.GetSnapshotVerifier(metadata)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/synced_state.go b/go/state/synced_state.go
--- a/go/state/synced_state.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/state/synced_state.go	(date 1718180534167)
@@ -72,6 +72,12 @@
 	return s.state.GetStorage(address, key)
 }
 
+func (s *syncedState) HasEmptyStorage(address common.Address) (bool, error) {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	return s.state.HasEmptyStorage(address)
+}
+
 func (s *syncedState) GetCode(address common.Address) ([]byte, error) {
 	s.mu.Lock()
 	defer s.mu.Unlock()
Index: go/state/gostate/go_state.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage gostate\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"runtime\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/backend/archive\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n\t\"github.com/Fantom-foundation/Carmen/go/state\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\n// GoState combines a LiveDB and optional Archive implementation into a common\n// Carmen State implementation.\ntype GoState struct {\n\tlive    state.LiveDB\n\tarchive archive.Archive\n\tcleanup []func()\n\n\tstateError error // collect errors occurred during operation\n\n\t// Channels are only present if archive is enabled.\n\tarchiveWriter          chan<- archiveUpdate\n\tarchiveWriterFlushDone <-chan bool\n\tarchiveWriterDone      <-chan bool\n\tarchiveWriterError     <-chan error\n}\n\nfunc newGoState(live state.LiveDB, archive archive.Archive, cleanup []func()) state.State {\n\n\tres := &GoState{\n\t\tlive:    live,\n\t\tarchive: archive,\n\t\tcleanup: cleanup,\n\t}\n\n\t// If there is an archive, start an asynchronous archive writer routine.\n\tif archive != nil {\n\t\tin := make(chan archiveUpdate, 10)\n\t\tflush := make(chan bool)\n\t\tdone := make(chan bool)\n\t\terr := make(chan error, 10)\n\n\t\tgo func() {\n\t\t\truntime.LockOSThread()\n\t\t\tdefer runtime.UnlockOSThread()\n\t\t\tdefer close(flush)\n\t\t\tdefer close(done)\n\t\t\t// Process all incoming updates, no not stop on errors.\n\t\t\tfor update := range in {\n\t\t\t\t// If there is no update, the state is asking for a flush signal.\n\t\t\t\tif update.update == nil {\n\t\t\t\t\tif issue := res.archive.Flush(); issue != nil {\n\t\t\t\t\t\terr <- issue\n\t\t\t\t\t}\n\t\t\t\t\tflush <- true\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, process the update.\n\t\t\t\t\tissue := res.archive.Add(update.block, *update.update, update.updateHints)\n\t\t\t\t\tif issue != nil {\n\t\t\t\t\t\terr <- issue\n\t\t\t\t\t}\n\t\t\t\t\tif update.updateHints != nil {\n\t\t\t\t\t\tupdate.updateHints.Release()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tres.archiveWriter = in\n\t\tres.archiveWriterDone = done\n\t\tres.archiveWriterFlushDone = flush\n\t\tres.archiveWriterError = err\n\t}\n\n\treturn state.WrapIntoSyncedState(res)\n}\n\nvar emptyCodeHash = common.GetHash(sha3.NewLegacyKeccak256(), []byte{})\n\ntype archiveUpdate = struct {\n\tblock       uint64\n\tupdate      *common.Update  // nil to signal a flush\n\tupdateHints common.Releaser // an optional field for passing update hints from the LiveDB to the Archive\n}\n\nfunc (s *GoState) Exists(address common.Address) (bool, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn false, err\n\t}\n\n\texist, err := s.live.Exists(address)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn exist, s.stateError\n}\n\nfunc (s *GoState) GetBalance(address common.Address) (common.Balance, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn common.Balance{}, err\n\t}\n\n\tbalance, err := s.live.GetBalance(address)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn balance, s.stateError\n}\n\nfunc (s *GoState) GetNonce(address common.Address) (common.Nonce, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn common.Nonce{}, err\n\t}\n\n\tnonce, err := s.live.GetNonce(address)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn nonce, s.stateError\n}\n\nfunc (s *GoState) GetStorage(address common.Address, key common.Key) (common.Value, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn common.Value{}, err\n\t}\n\n\tval, err := s.live.GetStorage(address, key)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn val, s.stateError\n}\n\nfunc (s *GoState) GetCode(address common.Address) ([]byte, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn []byte{}, err\n\t}\n\n\tcode, err := s.live.GetCode(address)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn code, s.stateError\n}\n\nfunc (s *GoState) GetCodeSize(address common.Address) (int, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn 0, err\n\t}\n\n\tsize, err := s.live.GetCodeSize(address)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn size, s.stateError\n}\n\nfunc (s *GoState) GetCodeHash(address common.Address) (common.Hash, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\n\th, err := s.live.GetCodeHash(address)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn h, s.stateError\n}\n\nfunc (s *GoState) GetHash() (common.Hash, error) {\n\tif err := s.stateError; err != nil {\n\t\treturn common.Hash{}, err\n\t}\n\n\th, err := s.live.GetHash()\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\treturn h, s.stateError\n}\n\nfunc (s *GoState) Apply(block uint64, update common.Update) error {\n\tif err := s.stateError; err != nil {\n\t\treturn err\n\t}\n\n\t// Apply the changes to the LiveDB.\n\tarchiveUpdateHints, err := s.live.Apply(block, update)\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t\treturn s.stateError\n\t}\n\n\tif s.archive != nil {\n\t\t// Send the update to the writer to be processed asynchronously.\n\t\ts.archiveWriter <- archiveUpdate{block, &update, archiveUpdateHints}\n\n\t\t// Drain potential errors, but do not wait for them.\n\t\tdone := false\n\t\tfor !done {\n\t\t\tselect {\n\t\t\t// In case there was an error, process it.\n\t\t\tcase err := <-s.archiveWriterError:\n\t\t\t\ts.stateError = errors.Join(s.stateError, err)\n\t\t\tdefault:\n\t\t\t\t// all errors consumed, moving on\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\t\tif err := s.stateError; err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if archiveUpdateHints != nil {\n\t\tarchiveUpdateHints.Release()\n\t}\n\treturn nil\n}\n\n// GetMemoryFootprint provides sizes of individual components of the state in the memory\nfunc (s *GoState) GetMemoryFootprint() *common.MemoryFootprint {\n\tmf := common.NewMemoryFootprint(0)\n\tmf.AddChild(\"live\", s.live.GetMemoryFootprint())\n\tif s.archive != nil {\n\t\tmf.AddChild(\"archive\", s.archive.GetMemoryFootprint())\n\t}\n\treturn mf\n}\n\nfunc (s *GoState) Flush() error {\n\tif s.archiveWriter != nil {\n\t\t// Signal to the archive worker that a flush should be conducted.\n\t\ts.archiveWriter <- archiveUpdate{}\n\t}\n\n\terr := s.live.Flush()\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\n\tif s.archiveWriter != nil {\n\t\t// Wait until the flush was processed.\n\t\t<-s.archiveWriterFlushDone\n\t}\n\n\treturn s.Check()\n}\n\nfunc (s *GoState) Close() error {\n\tif err := s.Flush(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.live.Close(); err != nil {\n\t\ts.stateError = errors.Join(s.stateError, err)\n\t}\n\n\t// Shut down archive writer background worker.\n\tif s.archiveWriter != nil {\n\t\t// Close archive stream, signaling writer to shut down.\n\t\tclose(s.archiveWriter)\n\t\t// Wait for the shutdown to be complete.\n\t\t<-s.archiveWriterDone\n\t\ts.archiveWriter = nil\n\t}\n\n\t// Close the archive.\n\tif s.archive != nil {\n\t\tif err := s.archive.Close(); err != nil {\n\t\t\ts.stateError = errors.Join(s.stateError, err)\n\t\t}\n\t}\n\n\tif s.cleanup != nil {\n\t\tfor _, clean := range s.cleanup {\n\t\t\tif clean != nil {\n\t\t\t\tclean()\n\t\t\t}\n\t\t}\n\t}\n\treturn s.Check()\n}\n\nfunc (s *GoState) GetArchiveState(block uint64) (as state.State, err error) {\n\tif s.archive == nil {\n\t\treturn nil, state.NoArchiveError\n\t}\n\tif err := s.stateError; err != nil {\n\t\treturn nil, err\n\t}\n\tlastBlock, empty, err := s.archive.GetBlockHeight()\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, errors.Join(fmt.Errorf(\"failed to get last block in the archive\"), err))\n\t\treturn nil, s.stateError\n\t}\n\tif empty {\n\t\treturn nil, fmt.Errorf(\"block %d is not present in the archive (archive is empty)\", block)\n\t}\n\tif block > lastBlock {\n\t\treturn nil, fmt.Errorf(\"block %d is not present in the archive (non-empty archive, last block %d)\", block, lastBlock)\n\t}\n\treturn &ArchiveState{\n\t\tarchive: s.archive,\n\t\tblock:   block,\n\t}, nil\n}\n\nfunc (s *GoState) GetArchiveBlockHeight() (uint64, bool, error) {\n\tif s.archive == nil {\n\t\treturn 0, false, state.NoArchiveError\n\t}\n\tif err := s.stateError; err != nil {\n\t\treturn 0, false, err\n\t}\n\tlastBlock, empty, err := s.archive.GetBlockHeight()\n\tif err != nil {\n\t\ts.stateError = errors.Join(s.stateError, errors.Join(fmt.Errorf(\"failed to get last block in the archive\"), err))\n\t\treturn 0, false, s.stateError\n\t}\n\treturn lastBlock, empty, nil\n}\n\nfunc (s *GoState) Check() error {\n\t// drain errors from archive if present\n\t// but does not wait\n\tif s.archive != nil {\n\t\tvar done bool\n\t\tfor !done {\n\t\t\tselect {\n\t\t\tcase err := <-s.archiveWriterError:\n\t\t\t\ts.stateError = errors.Join(s.stateError, err)\n\t\t\tdefault:\n\t\t\t\tdone = true\n\t\t\t}\n\t\t}\n\t}\n\treturn s.stateError\n}\n\nfunc (s *GoState) GetProof() (backend.Proof, error) {\n\tcomponents := s.live.GetSnapshotableComponents()\n\tif components == nil {\n\t\treturn nil, backend.ErrSnapshotNotSupported\n\t}\n\tproofs := make([]backend.Proof, 0, len(components))\n\tfor _, component := range components {\n\t\tproof, err := component.GetProof()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproofs = append(proofs, proof)\n\t}\n\treturn backend.GetComposedProof(proofs), nil\n}\n\nfunc (s *GoState) CreateSnapshot() (backend.Snapshot, error) {\n\tcomponents := s.live.GetSnapshotableComponents()\n\tif components == nil {\n\t\treturn nil, backend.ErrSnapshotNotSupported\n\t}\n\tsnapshots := make([]backend.Snapshot, 0, len(components))\n\tfor _, component := range components {\n\t\tsnapshot, err := component.CreateSnapshot()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsnapshots = append(snapshots, snapshot)\n\t}\n\treturn backend.NewComposedSnapshot(snapshots), nil\n}\n\nfunc (s *GoState) Restore(data backend.SnapshotData) error {\n\tcomponents := s.live.GetSnapshotableComponents()\n\tif components == nil {\n\t\treturn backend.ErrSnapshotNotSupported\n\t}\n\tsubdata, _, err := backend.SplitCompositeData(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(subdata) != len(components) {\n\t\treturn fmt.Errorf(\"invalid snapshot data format\")\n\t}\n\tfor i, component := range components {\n\t\tif err := component.Restore(subdata[i]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.live.RunPostRestoreTasks()\n}\n\nfunc (s *GoState) GetSnapshotVerifier(metadata []byte) (backend.SnapshotVerifier, error) {\n\tcomponents := s.live.GetSnapshotableComponents()\n\tif components == nil {\n\t\treturn nil, backend.ErrSnapshotNotSupported\n\t}\n\tsubMetaData, partCounts, err := backend.SplitCompositeMetaData(metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(subMetaData) != len(components) {\n\t\treturn nil, fmt.Errorf(\"invalid snapshot data format\")\n\t}\n\n\tverifiers := make([]backend.SnapshotVerifier, 0, len(components))\n\tfor i, component := range components {\n\t\tverifier, err := component.GetSnapshotVerifier(subMetaData[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tverifiers = append(verifiers, verifier)\n\t}\n\treturn backend.NewComposedSnapshotVerifier(verifiers, partCounts), nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/gostate/go_state.go b/go/state/gostate/go_state.go
--- a/go/state/gostate/go_state.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/state/gostate/go_state.go	(date 1718180817365)
@@ -144,6 +144,10 @@
 	return val, s.stateError
 }
 
+func (s *GoState) HasEmptyStorage(address common.Address) (bool, error) {
+	panic("HasEmptyStorage: not yet implemented for Go Schema")
+}
+
 func (s *GoState) GetCode(address common.Address) ([]byte, error) {
 	if err := s.stateError; err != nil {
 		return []byte{}, err
Index: go/state/state_db.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\n// Deprecated: external users should switch to the carmen package as the new top-level API\npackage state\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"maps\"\n\t\"math/big\"\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n)\n\n//go:generate mockgen -source state_db.go -destination state_db_mock.go -package state\n\n// VmStateDB defines the basic operations that can be conducted on a StateDB as\n// required by an EVM implementation.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype VmStateDB interface {\n\t// Account management.\n\tCreateAccount(common.Address)\n\tExist(common.Address) bool\n\tEmpty(common.Address) bool\n\n\tSuicide(common.Address) bool\n\tHasSuicided(common.Address) bool\n\n\t// Balance\n\tGetBalance(common.Address) *big.Int\n\tAddBalance(common.Address, *big.Int)\n\tSubBalance(common.Address, *big.Int)\n\n\t// Nonce\n\tGetNonce(common.Address) uint64\n\tSetNonce(common.Address, uint64)\n\n\t// Read and update storage.\n\tGetCommittedState(common.Address, common.Key) common.Value\n\tGetState(common.Address, common.Key) common.Value\n\tSetState(common.Address, common.Key, common.Value)\n\tGetTransientState(common.Address, common.Key) common.Value\n\tSetTransientState(common.Address, common.Key, common.Value)\n\n\t// Code management.\n\tGetCode(common.Address) []byte\n\tSetCode(common.Address, []byte)\n\tGetCodeHash(common.Address) common.Hash\n\tGetCodeSize(common.Address) int\n\n\t// Refund tracking.\n\tAddRefund(uint64)\n\tSubRefund(uint64)\n\tGetRefund() uint64\n\n\t// Log management:\n\t// AddLog adds a log into the current transaction.\n\tAddLog(*common.Log)\n\t// GetLogs provides logs produced in the current transaction.\n\tGetLogs() []*common.Log\n\n\t// Access list tracking.\n\tClearAccessList()\n\tAddAddressToAccessList(common.Address)\n\tAddSlotToAccessList(common.Address, common.Key)\n\tIsAddressInAccessList(common.Address) bool\n\tIsSlotInAccessList(common.Address, common.Key) (addressPresent bool, slotPresent bool)\n\n\t// Transaction scope management.\n\tSnapshot() int\n\tRevertToSnapshot(int)\n\n\tBeginTransaction()\n\tEndTransaction()\n\n\t// GetTransactionChanges provides a set of accounts and their slots, which have been\n\t// potentially changed in the current transaction.\n\t// Must be called before EndTransaction call.\n\tGetTransactionChanges() map[common.Address][]common.Key\n\n\t// Deprecated: not necessary, to be removed\n\tAbortTransaction()\n\n\t// GetHash obtains a cryptographically unique hash of the committed state.\n\tGetHash() common.Hash\n\n\t// Check checks the state of the DB and reports an error if issues have been\n\t// encountered. Check should be called periodically to validate all interactions\n\t// with a StateDB instance. If an error is reported, all operations since the\n\t// last successful check need to be considered invalid.\n\tCheck() error\n}\n\n// StateDB serves as the public interface definition of a Carmen StateDB.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype StateDB interface {\n\tVmStateDB\n\n\tBeginBlock()\n\tEndBlock(number uint64)\n\n\tBeginEpoch()\n\tEndEpoch(number uint64)\n\n\t// Flushes committed state to disk.\n\t// Deprecated: these methods shuold not be called, one statedb inst should not close/flush global databsae\n\tFlush() error\n\tClose() error\n\n\t// StartBulkLoad initiates a bulk load operation by-passing internal caching and\n\t// snapshot, transaction, block, or epoch handling to support faster initialization\n\t// of StateDB instances. All updates of a bulk-load call are committed to the DB\n\t// as a single block with the given block number. Bulk-loads may only be started\n\t// outside the scope of any block.\n\tStartBulkLoad(block uint64) BulkLoad\n\n\t// GetArchiveStateDB provides a historical state view for given block.\n\t// An error is returned if the archive is not enabled or if it is empty.\n\tGetArchiveStateDB(block uint64) (NonCommittableStateDB, error)\n\n\t// GetArchiveBlockHeight provides the last block height available in the archive.\n\t// An empty archive is signaled by an extra return value. An error is returned if the\n\t// archive is not enabled or some other issue has occurred.\n\tGetArchiveBlockHeight() (height uint64, empty bool, err error)\n\n\t// GetMemoryFootprint computes an approximation of the memory used by this state.\n\tGetMemoryFootprint() *common.MemoryFootprint\n\n\tResetBlockContext()\n}\n\n// NonCommittableStateDB is the public interface offered for views on states that can not\n// be permanently modified. The prime example for those are views on historic blocks backed\n// by an archive. While volatile transaction internal changes are supported, there is no\n// way offered for committing those.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype NonCommittableStateDB interface {\n\tVmStateDB\n\n\t// Copy creates a copy of the StateDB, including all uncommitted changes.\n\t// Should be used only in-between transactions, as the tx context is not copied.\n\t// Any change to the copy does not affect the original StateDB, except the state caches.\n\t// Available for non-committable states only, as a commit to the backing state\n\t// makes all other StateDBs with the same backing state invalid.\n\tCopy() NonCommittableStateDB\n\n\t// Release should be called whenever this instance is no longer needed to allow\n\t// held resources to be reused for future requests. After the release, no more\n\t// operations may be conducted on this StateDB instance.\n\tRelease()\n}\n\n// BulkLoad serves as the public interface for loading preset data into the state DB.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\ntype BulkLoad interface {\n\tCreateAccount(common.Address)\n\tSetBalance(common.Address, *big.Int)\n\tSetNonce(common.Address, uint64)\n\tSetState(common.Address, common.Key, common.Value)\n\tSetCode(common.Address, []byte)\n\tClose() error\n}\n\n// stateDB is the internal implementation of the StateDB interface.\ntype stateDB struct {\n\t// The underlying state data is read/written to.\n\tstate State\n\n\t// A transaction local cache for account states to avoid double-fetches and support rollbacks.\n\taccounts map[common.Address]*accountState\n\n\t// A transaction local cache of balances to avoid double-fetches and support rollbacks.\n\tbalances map[common.Address]*balanceValue\n\n\t// A transaction local cache of nonces to avoid double-fetches and support rollbacks.\n\tnonces map[common.Address]*nonceValue\n\n\t// A transaction local cache of storage values to avoid double-fetches and support rollbacks.\n\tdata *common.FastMap[slotId, *slotValue]\n\n\t// Transient storage is a temporary storage that gets deleted after each transaction.\n\ttransientStorage *common.FastMap[slotId, common.Value]\n\n\t// A transaction local cache of contract codes and their properties.\n\tcodes map[common.Address]*codeValue\n\n\t// A list of accounts to be deleted at the end of the transaction.\n\taccountsToDelete []common.Address\n\n\t// Tracks the clearing state of individual accounts.\n\tclearedAccounts map[common.Address]accountClearingState\n\n\t// A list of operations undoing modifications applied on the inner state if a snapshot revert needs to be performed.\n\tundo []func()\n\n\t// The refund accumulated in the current transaction.\n\trefund uint64\n\n\t// The list of log messages recorded for the current transaction.\n\tlogs []*common.Log\n\n\t// The amount of logs in the current block.\n\tlogsInBlock uint\n\n\t// A set of accessed addresses in the current transaction.\n\taccessedAddresses map[common.Address]bool\n\n\t// A set of accessed slots in the current transaction.\n\taccessedSlots *common.FastMap[slotId, bool]\n\n\t// A set of slots with current value (possibly) different from the committed value - for needs of committing.\n\twrittenSlots map[*slotValue]bool\n\n\t// A non-transactional local cache of stored storage values.\n\tstoredDataCache *common.LruCache[slotId, storedDataCacheValue]\n\n\t// A non-transactional reincarnation counter for accounts. This is used to efficiently invalidate data in\n\t// the storedDataCache upon account deletion. The maintained values are internal information only.\n\treincarnation map[common.Address]uint64\n\n\t// A list of addresses, which have possibly become empty in the transaction\n\temptyCandidates []common.Address\n\n\t// True, if this state DB is allowed to apply changes to the underlying state, false otherwise.\n\tcanApplyChanges bool\n\n\t// A list of errors encountered during DB interactions.\n\terrors []error\n}\n\ntype accountLifeCycleState int\n\n// The life-cycle states of an account as seen by the StateDB\n//  - unknown     ... the state has not been fetched from the DB; only valid for the original field in the account state\n//  - NonExisting ... the account is known to not exist\n//  - Exists      ... the account is known to exist\n//  - Suicided    ... the account existed during the current transaction, but suicided\n//\n// The following transitions are allowed:\n//\n//    Unknown -- Load --> NonExisting\n//    Unknown -- Load --> Exists\n//\n//    NonExisting -- CreateAccount --> Exists\n//\n//    Exists -- CreateAccount --> Exists\n//    Exists -- Suicide --> Suicided\n//    Exists -- EndTransaction --> NonExisting    // if account was empty\n//\n//    Suicided -- CreateAccount --> Exists\n//    Suicided -- EndTransaction --> NonExisting\n//\n// Accounts with the state Suicided can only exist during a transaction. At the end of a\n// transaction, Suicided accounts transition automatically into NonExisting accounts.\n\nconst (\n\taccountNonExisting    accountLifeCycleState = 1\n\taccountExists         accountLifeCycleState = 2\n\taccountSelfDestructed accountLifeCycleState = 3\n)\n\nfunc (s accountLifeCycleState) String() string {\n\tswitch s {\n\tcase accountNonExisting:\n\t\treturn \"NonExisting\"\n\tcase accountExists:\n\t\treturn \"Exists\"\n\tcase accountSelfDestructed:\n\t\treturn \"Suicided\"\n\t}\n\treturn \"?\"\n}\n\n// accountState maintains the state of an account during a transaction.\ntype accountState struct {\n\t// The committed account state, set to kUnknown if never fetched.\n\toriginal accountLifeCycleState\n\t// The current account state visible to the state DB users.\n\tcurrent accountLifeCycleState\n}\n\ntype accountClearingState int\n\nconst (\n\t// noClearing is the state of an account not be to cleared (make sure this has the default value 0)\n\tnoClearing accountClearingState = 0\n\t// pendingClearing is the state of an account that is scheduled for clearing at the end of the current transaction but should still appear like it exists.\n\tpendingClearing accountClearingState = 1\n\t// cleared is the state of an account that should appear as it has been cleared.\n\tcleared accountClearingState = 2\n\t// same as cleared, but some SetState has been invoked on the account after its cleaning. So the cached state may be tainted.\n\tclearedAndTainted accountClearingState = 3\n)\n\nfunc (s accountClearingState) String() string {\n\tswitch s {\n\tcase noClearing:\n\t\treturn \"noClearing\"\n\tcase pendingClearing:\n\t\treturn \"pendingClearing\"\n\tcase cleared:\n\t\treturn \"cleared\"\n\tcase clearedAndTainted:\n\t\treturn \"clearedAndTainted\"\n\t}\n\treturn \"?\"\n}\n\n// balanceVale maintains a balance during a transaction.\ntype balanceValue struct {\n\t// The committed balance of an account, missing if never fetched.\n\toriginal *big.Int\n\t// The current value of the account balance visible to the state DB users.\n\tcurrent big.Int\n}\n\n// nonceValue maintains a nonce during a transaction.\ntype nonceValue struct {\n\t// The committed nonce of an account, missing if never fetched.\n\toriginal *uint64\n\t// The current nonce of an account visible to the state DB users.\n\tcurrent uint64\n}\n\n// slotId identifies a storage location.\ntype slotId struct {\n\taddr common.Address\n\tkey  common.Key\n}\n\ntype slotHasher struct{}\n\nfunc (h slotHasher) Hash(id slotId) uint16 {\n\treturn uint16(id.addr[19])<<8 | uint16(id.key[31])\n}\n\nfunc (s *slotId) Compare(other *slotId) int {\n\tc := s.addr.Compare(&other.addr)\n\tif c < 0 {\n\t\treturn -1\n\t}\n\tif c > 0 {\n\t\treturn 1\n\t}\n\treturn s.key.Compare(&other.key)\n}\n\n// slotValue maintains the value of a slot.\ntype slotValue struct {\n\t// The value in the DB, missing if never fetched.\n\tstored common.Value\n\t// The value committed by the last completed transaction.\n\tcommitted common.Value\n\t// The current value as visible to the state DB users.\n\tcurrent common.Value\n\t// Whether the stored value is known.\n\tstoredKnown bool\n\t// Whether the committed value is known.\n\tcommittedKnown bool\n}\n\n// codeValue maintains the code associated to a given address.\ntype codeValue struct {\n\tcode      []byte\n\tsize      int\n\thash      *common.Hash\n\tdirty     bool // < set if code has been updated in transaction\n\tcodeValid bool // < set if code is loaded from the state (or written as dirty)\n\tsizeValid bool // < set if size is loaded from the state (or written as dirty)\n}\n\nconst defaultStoredDataCacheSize = 1000000 // ~ 100 MiB of memory for this cache.\nconst nonCommittableStoredDataCacheSize = 100\n\n// storedDataCacheValue maintains the cached version of a value in the store. To\n// support the efficient clearing of values cached for accounts being deleted, an\n// additional account reincarnation counter is added.\ntype storedDataCacheValue struct {\n\tvalue         common.Value // < the cached version of the value in the store\n\treincarnation uint64       // < the reincarnation the cached value belongs to\n}\n\n// CreateStateDBUsing creates a StateDB instance wrapping the given state supporting\n// all operations including end-of-block operations mutating the underlying state.\n// Note: any StateDB instanced becomes invalid if the underlying state is\n// modified by any other StateDB instance or through any other direct modification.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\nfunc CreateStateDBUsing(state State) StateDB {\n\treturn CreateCustomStateDBUsing(state, defaultStoredDataCacheSize)\n}\n\n// CreateCustomStateDBUsing is the same as CreateStateDBUsing but allows the caller to specify\n// the capacity of the stored Data cache used in the resulting instance. The default\n// cache size used by CreateCustomStateDBUsing may be too large if StateDB instances\n// only have a short live time. In such cases, the initialization and destruction of\n// the maintained data cache may dominate execution time.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\nfunc CreateCustomStateDBUsing(state State, storedDataCacheSize int) StateDB {\n\tif storedDataCacheSize <= 0 {\n\t\tstoredDataCacheSize = defaultStoredDataCacheSize\n\t}\n\treturn createStateDBWith(state, storedDataCacheSize, true)\n}\n\n// CreateNonCommittableStateDBUsing creates a read-only StateDB instance wrapping\n// the given state supporting all operations specified by the VmStateDB interface.\n// Note: any StateDB instanced becomes invalid if the underlying state is\n// modified by any other StateDB instance or through any other direct modification.\n//\n// Deprecated: external users should switch to the carmen package as the new top-level API\nfunc CreateNonCommittableStateDBUsing(state State) NonCommittableStateDB {\n\t// Since StateDB instances are big objects costly to create we reuse those using\n\t// a pool of objects. However, instances need to be properly reset.\n\tdb := nonCommittableStateDbPool.Get().(*stateDB)\n\tdb.resetState(state)\n\treturn &nonCommittableStateDB{db}\n}\n\nfunc createStateDBWith(state State, storedDataCacheCapacity int, canApplyChanges bool) *stateDB {\n\treturn &stateDB{\n\t\tstate:             state,\n\t\taccounts:          map[common.Address]*accountState{},\n\t\tbalances:          map[common.Address]*balanceValue{},\n\t\tnonces:            map[common.Address]*nonceValue{},\n\t\tdata:              common.NewFastMap[slotId, *slotValue](slotHasher{}),\n\t\ttransientStorage:  common.NewFastMap[slotId, common.Value](slotHasher{}),\n\t\tstoredDataCache:   common.NewLruCache[slotId, storedDataCacheValue](storedDataCacheCapacity),\n\t\treincarnation:     map[common.Address]uint64{},\n\t\tcodes:             map[common.Address]*codeValue{},\n\t\trefund:            0,\n\t\taccessedAddresses: map[common.Address]bool{},\n\t\taccessedSlots:     common.NewFastMap[slotId, bool](slotHasher{}),\n\t\twrittenSlots:      map[*slotValue]bool{},\n\t\taccountsToDelete:  make([]common.Address, 0, 100),\n\t\tundo:              make([]func(), 0, 100),\n\t\tclearedAccounts:   make(map[common.Address]accountClearingState),\n\t\temptyCandidates:   make([]common.Address, 0, 100),\n\t\tcanApplyChanges:   canApplyChanges,\n\t}\n}\n\nfunc (s *stateDB) setAccountState(addr common.Address, state accountLifeCycleState) {\n\ts.Exist(addr) // < make sure s.accounts[addr] is initialized\n\tval, exists := s.accounts[addr]\n\t// exists will be false when calling s.Exists() did not succeed\n\tif !exists || val.current == state {\n\t\treturn\n\t}\n\toldState := val.current\n\tval.current = state\n\ts.undo = append(s.undo, func() {\n\t\tval.current = oldState\n\t})\n}\n\nfunc (s *stateDB) Exist(addr common.Address) bool {\n\tif val, exists := s.accounts[addr]; exists {\n\t\treturn val.current == accountExists || val.current == accountSelfDestructed // self-destructed accounts still exist till the end of the transaction.\n\t}\n\texists, err := s.state.Exists(addr)\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to get account state for %v: %w\", addr, err))\n\t\treturn false\n\t}\n\tstate := accountNonExisting\n\tif exists {\n\t\tstate = accountExists\n\t}\n\ts.accounts[addr] = &accountState{\n\t\toriginal: state,\n\t\tcurrent:  state,\n\t}\n\treturn exists\n}\n\nfunc (s *stateDB) CreateAccount(addr common.Address) {\n\ts.setNonceInternal(addr, 0)\n\ts.setCodeInternal(addr, []byte{})\n\n\texists := s.Exist(addr)\n\ts.setAccountState(addr, accountExists)\n\n\t// Created because touched - will be deleted at the end of the transaction if it stays empty\n\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\n\t// Initialize the balance with 0, unless the account existed before.\n\t// Thus, accounts previously marked as unknown (default) or deleted\n\t// will get their balance reset. In particular, deleted accounts that\n\t// are restored will have an empty balance. However, for accounts that\n\t// already existed before this create call the balance is preserved.\n\tif !exists {\n\t\ts.resetBalance(addr)\n\t}\n\n\t// Reset storage of the account, to purge any potential former values.\n\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\tif slot.addr == addr {\n\t\t\t// Support rollback of account creation.\n\t\t\tbackup := *value\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\t*value = backup\n\t\t\t})\n\n\t\t\t// Clear cached values.\n\t\t\tvalue.stored = common.Value{}\n\t\t\tvalue.storedKnown = true\n\t\t\tvalue.committed = common.Value{}\n\t\t\tvalue.committedKnown = true\n\t\t\tvalue.current = common.Value{}\n\t\t}\n\t})\n\n\t// Mark account to be treated like if was already committed.\n\toldState := s.clearedAccounts[addr]\n\ts.clearedAccounts[addr] = cleared\n\ts.undo = append(s.undo, func() {\n\t\ts.clearedAccounts[addr] = oldState\n\t})\n}\n\nfunc (s *stateDB) createAccountIfNotExists(addr common.Address) bool {\n\tif s.Exist(addr) {\n\t\treturn false\n\t}\n\ts.setAccountState(addr, accountExists)\n\n\t// Initialize the balance with 0, unless the account existed before.\n\t// Thus, accounts previously marked as unknown (default) or deleted\n\t// will get their balance reset. In particular, deleted accounts that\n\t// are restored will have an empty balance. However, for accounts that\n\t// already existed before this create call the balance is preserved.\n\ts.resetBalance(addr)\n\n\treturn true\n}\n\n// Suicide marks the given account as suicided.\n// This clears the account balance.\n// The account still exist until the state is committed.\nfunc (s *stateDB) Suicide(addr common.Address) bool {\n\tif !s.Exist(addr) {\n\t\treturn false\n\t}\n\n\ts.setAccountState(addr, accountSelfDestructed)\n\n\ts.resetBalance(addr)\n\tdeleteListLength := len(s.accountsToDelete)\n\ts.accountsToDelete = append(s.accountsToDelete, addr)\n\ts.undo = append(s.undo, func() {\n\t\ts.accountsToDelete = s.accountsToDelete[0:deleteListLength]\n\t})\n\n\t// Mark account for clearing to plan its removing on commit and\n\t// to avoid fetching new data into the cache during the ongoing block.\n\toldState := s.clearedAccounts[addr]\n\tif oldState == noClearing {\n\t\ts.clearedAccounts[addr] = pendingClearing\n\t\ts.undo = append(s.undo, func() {\n\t\t\ts.clearedAccounts[addr] = oldState\n\t\t})\n\t}\n\n\treturn true\n}\n\nfunc (s *stateDB) HasSuicided(addr common.Address) bool {\n\tstate := s.accounts[addr]\n\treturn state != nil && state.current == accountSelfDestructed\n}\n\nfunc (s *stateDB) Empty(addr common.Address) bool {\n\t// Defined as balance == nonce == code == 0\n\treturn s.GetBalance(addr).Sign() == 0 && s.GetNonce(addr) == 0 && s.GetCodeSize(addr) == 0\n}\n\nfunc clone(val *big.Int) *big.Int {\n\tres := new(big.Int)\n\tres.Set(val)\n\treturn res\n}\n\nfunc (s *stateDB) GetBalance(addr common.Address) *big.Int {\n\t// Check cache first.\n\tif val, exists := s.balances[addr]; exists {\n\t\treturn clone(&val.current) // Do not hand out a pointer to the internal copy!\n\t}\n\t// Since the value is not present, we need to fetch it from the store.\n\tbalance, err := s.state.GetBalance(addr)\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to load balance for address %v: %w\", addr, err))\n\t\treturn new(big.Int) // We need to return something that allows the VM to continue.\n\t}\n\tres := balance.ToBigInt()\n\ts.balances[addr] = &balanceValue{\n\t\toriginal: res,\n\t\tcurrent:  *res,\n\t}\n\treturn clone(res) // Do not hand out a pointer to the internal copy!\n}\n\nfunc (s *stateDB) AddBalance(addr common.Address, diff *big.Int) {\n\ts.createAccountIfNotExists(addr)\n\n\tif diff == nil || diff.Sign() == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t\treturn\n\t}\n\tif diff.Sign() < 0 {\n\t\ts.SubBalance(addr, diff.Abs(diff))\n\t\treturn\n\t}\n\n\toldValue := s.GetBalance(addr)\n\tnewValue := new(big.Int).Add(oldValue, diff)\n\n\ts.balances[addr].current = *newValue\n\ts.undo = append(s.undo, func() {\n\t\ts.balances[addr].current = *oldValue\n\t})\n}\n\nfunc (s *stateDB) SubBalance(addr common.Address, diff *big.Int) {\n\ts.createAccountIfNotExists(addr)\n\n\tif diff == nil || diff.Sign() == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t\treturn\n\t}\n\tif diff.Sign() < 0 {\n\t\ts.AddBalance(addr, diff.Abs(diff))\n\t\treturn\n\t}\n\n\toldValue := s.GetBalance(addr)\n\tnewValue := new(big.Int).Sub(oldValue, diff)\n\n\tif newValue.Sign() == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n\n\ts.balances[addr].current = *newValue\n\ts.undo = append(s.undo, func() {\n\t\ts.balances[addr].current = *oldValue\n\t})\n}\n\nfunc (s *stateDB) resetBalance(addr common.Address) {\n\tif val, exists := s.balances[addr]; exists {\n\t\tif val.current.Sign() != 0 {\n\t\t\toldValue := val.current\n\t\t\tval.current = *big.NewInt(0)\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\tval.current = oldValue\n\t\t\t})\n\t\t}\n\t} else {\n\t\ts.balances[addr] = &balanceValue{\n\t\t\toriginal: nil,\n\t\t\tcurrent:  *big.NewInt(0),\n\t\t}\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.balances, addr)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) GetNonce(addr common.Address) uint64 {\n\t// Check cache first.\n\tif val, exists := s.nonces[addr]; exists {\n\t\treturn val.current\n\t}\n\n\t// Since the value is not present, we need to fetch it from the store.\n\tnonce, err := s.state.GetNonce(addr)\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to load nonce for address %v: %w\", addr, err))\n\t\treturn 0\n\t}\n\tres := nonce.ToUint64()\n\ts.nonces[addr] = &nonceValue{\n\t\toriginal: &res,\n\t\tcurrent:  res,\n\t}\n\treturn res\n}\n\nfunc (s *stateDB) SetNonce(addr common.Address, nonce uint64) {\n\ts.setNonceInternal(addr, nonce)\n\tif s.createAccountIfNotExists(addr) && nonce == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n}\n\nfunc (s *stateDB) setNonceInternal(addr common.Address, nonce uint64) {\n\tif val, exists := s.nonces[addr]; exists {\n\t\tif val.current != nonce {\n\t\t\toldValue := val.current\n\t\t\tval.current = nonce\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\tval.current = oldValue\n\t\t\t})\n\t\t}\n\t} else {\n\t\ts.nonces[addr] = &nonceValue{\n\t\t\toriginal: nil,\n\t\t\tcurrent:  nonce,\n\t\t}\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.nonces, addr)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) GetCommittedState(addr common.Address, key common.Key) common.Value {\n\t// Check cache first.\n\tsid := slotId{addr, key}\n\tval, exists := s.data.Get(sid)\n\tif exists && val.committedKnown {\n\t\treturn val.committed\n\t}\n\t// If the value is not present, fetch it from the store.\n\treturn s.loadStoredState(sid, val)\n}\n\nfunc (s *stateDB) loadStoredState(sid slotId, val *slotValue) common.Value {\n\tif clearingState, found := s.clearedAccounts[sid.addr]; found && (clearingState == cleared || clearingState == clearedAndTainted) {\n\t\t// If the account has been cleared in a committed transaction within the current block,\n\t\t// the effects are not yet updated in the data base. So it must not be read from the DB\n\t\t// before the next block.\n\t\treturn common.Value{}\n\t}\n\treincarnation := s.reincarnation[sid.addr]\n\tvar stored storedDataCacheValue\n\tstored, found := s.storedDataCache.Get(sid)\n\tif !found {\n\t\tvar err error\n\t\tstored.value, err = s.state.GetStorage(sid.addr, sid.key)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to load storage location %v/%v: %w\", sid.addr, sid.key, err))\n\t\t\treturn common.Value{}\n\t\t}\n\t\tstored.reincarnation = reincarnation\n\t\ts.storedDataCache.Set(sid, stored)\n\t}\n\t// If the cached value is out-dated, the current value is zero. If the same slot would\n\t// have been updated since the clearing, it would have also been updated in the cache.\n\tif stored.reincarnation < reincarnation {\n\t\tstored.value = common.Value{}\n\t}\n\n\t// Remember the stored value for future accesses.\n\tif val != nil {\n\t\tval.committed, val.committedKnown = stored.value, true\n\t\tval.stored, val.storedKnown = stored.value, true\n\t} else {\n\t\ts.data.Put(sid, &slotValue{\n\t\t\tstored:         stored.value,\n\t\t\tcommitted:      stored.value,\n\t\t\tcurrent:        stored.value,\n\t\t\tstoredKnown:    true,\n\t\t\tcommittedKnown: true,\n\t\t})\n\t}\n\treturn stored.value\n}\n\nfunc (s *stateDB) GetState(addr common.Address, key common.Key) common.Value {\n\t// Check whether the slot is already cached/modified.\n\tsid := slotId{addr, key}\n\tif val, exists := s.data.Get(sid); exists {\n\t\treturn val.current\n\t}\n\t// Fetch missing slot values (will also populate the cache).\n\treturn s.loadStoredState(sid, nil)\n}\n\nfunc (s *stateDB) SetState(addr common.Address, key common.Key, value common.Value) {\n\tif s.createAccountIfNotExists(addr) {\n\t\t// The account was implicitly created and may have to be removed at the end of the block.\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n\tsid := slotId{addr, key}\n\tif entry, exists := s.data.Get(sid); exists {\n\t\tif entry.current != value {\n\t\t\toldValue := entry.current\n\t\t\tentry.current = value\n\t\t\ts.writtenSlots[entry] = true\n\t\t\ts.undo = append(s.undo, func() {\n\t\t\t\tentry.current = oldValue\n\t\t\t})\n\t\t}\n\t} else {\n\t\tentry = &slotValue{current: value}\n\t\ts.data.Put(sid, entry)\n\t\ts.writtenSlots[entry] = true\n\t\ts.undo = append(s.undo, func() {\n\t\t\tentry, _ := s.data.Get(sid)\n\t\t\tif entry.committedKnown {\n\t\t\t\tentry.current = entry.committed\n\t\t\t} else {\n\t\t\t\ts.data.Remove(sid)\n\t\t\t}\n\t\t\tdelete(s.writtenSlots, entry)\n\t\t})\n\t}\n\toldState := s.clearedAccounts[addr]\n\tif oldState == cleared {\n\t\ts.clearedAccounts[addr] = clearedAndTainted\n\t\ts.undo = append(s.undo, func() { s.clearedAccounts[addr] = oldState })\n\t}\n}\n\nfunc (s *stateDB) GetTransientState(addr common.Address, key common.Key) common.Value {\n\tsid := slotId{addr, key}\n\tval, _ := s.transientStorage.Get(sid)\n\treturn val\n}\n\nfunc (s *stateDB) SetTransientState(addr common.Address, key common.Key, value common.Value) {\n\tsid := slotId{addr, key}\n\tcurrentValue, _ := s.transientStorage.Get(sid)\n\tif currentValue == value {\n\t\treturn\n\t}\n\n\t// Save previous value for rollbacks\n\toldValue := currentValue\n\ts.undo = append(s.undo, func() {\n\t\ts.transientStorage.Put(sid, oldValue)\n\t})\n\n\ts.transientStorage.Put(sid, value)\n}\n\nfunc (s *stateDB) GetCode(addr common.Address) []byte {\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{}\n\t\ts.codes[addr] = val\n\t}\n\tif !val.codeValid {\n\t\tcode, err := s.state.GetCode(addr)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to obtain code for %v: %w\", addr, err))\n\t\t\treturn nil\n\t\t}\n\t\tval.code, val.codeValid = code, true\n\t\tval.size, val.sizeValid = len(code), true\n\t}\n\treturn val.code\n}\n\nfunc (s *stateDB) SetCode(addr common.Address, code []byte) {\n\ts.createAccountIfNotExists(addr)\n\ts.setCodeInternal(addr, code)\n\tif len(code) == 0 {\n\t\ts.emptyCandidates = append(s.emptyCandidates, addr)\n\t}\n}\n\nfunc (s *stateDB) setCodeInternal(addr common.Address, code []byte) {\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{dirty: true}\n\t\tval.code, val.codeValid = code, true\n\t\tval.size, val.sizeValid = len(code), true\n\t\ts.codes[addr] = val\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.codes, addr)\n\t\t})\n\t} else {\n\t\told := *val\n\t\tval.code, val.codeValid = code, true\n\t\tval.size, val.sizeValid = len(code), true\n\t\tval.hash = nil\n\t\tval.dirty = true\n\t\ts.undo = append(s.undo, func() {\n\t\t\t*(s.codes[addr]) = old\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) GetCodeHash(addr common.Address) common.Hash {\n\t// The hash of the code of a non-existing account is always zero.\n\tif !s.Exist(addr) {\n\t\treturn common.Hash{}\n\t}\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{}\n\t\ts.codes[addr] = val\n\t}\n\tif val.dirty && val.hash == nil {\n\t\t// If the code is dirty (=uncommitted) the hash needs to be computed on the fly.\n\t\thash := common.GetKeccak256Hash(val.code)\n\t\tval.hash = &hash\n\t}\n\tif val.hash == nil {\n\t\t// hash not loaded, code not dirty - needs to load the hash from the state\n\t\thash, err := s.state.GetCodeHash(addr)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to obtain code hash for %v: %w\", addr, err))\n\t\t\treturn common.Hash{}\n\t\t}\n\t\tval.hash = &hash\n\t}\n\treturn *val.hash\n}\n\nfunc (s *stateDB) GetCodeSize(addr common.Address) int {\n\tval, exists := s.codes[addr]\n\tif !exists {\n\t\tval = &codeValue{}\n\t\ts.codes[addr] = val\n\t}\n\tif !val.sizeValid {\n\t\tsize, err := s.state.GetCodeSize(addr)\n\t\tif err != nil {\n\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to obtain code size for %v: %w\", addr, err))\n\t\t\treturn 0\n\t\t}\n\t\tval.size, val.sizeValid = size, true\n\t}\n\treturn val.size\n}\n\nfunc (s *stateDB) AddRefund(amount uint64) {\n\told := s.refund\n\ts.refund += amount\n\ts.undo = append(s.undo, func() {\n\t\ts.refund = old\n\t})\n}\nfunc (s *stateDB) SubRefund(amount uint64) {\n\tif amount > s.refund {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to lower refund, attempted to removed %d from current refund %d\", amount, s.refund))\n\t\treturn\n\t}\n\told := s.refund\n\ts.refund -= amount\n\ts.undo = append(s.undo, func() {\n\t\ts.refund = old\n\t})\n}\n\nfunc (s *stateDB) GetRefund() uint64 {\n\treturn s.refund\n}\n\nfunc (s *stateDB) AddLog(log *common.Log) {\n\tsize := len(s.logs)\n\tlog.Index = s.logsInBlock\n\ts.logs = append(s.logs, log)\n\ts.logsInBlock++\n\ts.undo = append(s.undo, func() {\n\t\ts.logs = s.logs[0:size]\n\t\ts.logsInBlock--\n\t})\n}\n\nfunc (s *stateDB) GetLogs() []*common.Log {\n\treturn s.logs\n}\n\nfunc (s *stateDB) ClearAccessList() {\n\tif len(s.accessedAddresses) > 0 {\n\t\ts.accessedAddresses = make(map[common.Address]bool)\n\t}\n\tif s.accessedSlots.Size() > 0 {\n\t\ts.accessedSlots.Clear()\n\t}\n}\n\nfunc (s *stateDB) AddAddressToAccessList(addr common.Address) {\n\t_, found := s.accessedAddresses[addr]\n\tif !found {\n\t\ts.accessedAddresses[addr] = true\n\t\ts.undo = append(s.undo, func() {\n\t\t\tdelete(s.accessedAddresses, addr)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) AddSlotToAccessList(addr common.Address, key common.Key) {\n\ts.AddAddressToAccessList(addr)\n\tsid := slotId{addr, key}\n\t_, found := s.accessedSlots.Get(sid)\n\tif !found {\n\t\ts.accessedSlots.Put(sid, true)\n\t\ts.undo = append(s.undo, func() {\n\t\t\ts.accessedSlots.Remove(sid)\n\t\t})\n\t}\n}\n\nfunc (s *stateDB) IsAddressInAccessList(addr common.Address) bool {\n\t_, found := s.accessedAddresses[addr]\n\treturn found\n}\n\nfunc (s *stateDB) IsSlotInAccessList(addr common.Address, key common.Key) (addressPresent bool, slotPresent bool) {\n\t_, found := s.accessedSlots.Get(slotId{addr, key})\n\tif found {\n\t\treturn true, true\n\t}\n\treturn s.IsAddressInAccessList(addr), false\n}\n\nfunc (s *stateDB) Snapshot() int {\n\treturn len(s.undo)\n}\n\nfunc (s *stateDB) RevertToSnapshot(id int) {\n\tif id < 0 || len(s.undo) < id {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to revert to invalid snapshot id %d, allowed range 0 - %d\", id, len(s.undo)))\n\t\treturn\n\t}\n\tfor len(s.undo) > id {\n\t\ts.undo[len(s.undo)-1]()\n\t\ts.undo = s.undo[:len(s.undo)-1]\n\t}\n}\n\nfunc (s *stateDB) BeginTransaction() {\n\t// Ignored\n}\n\nfunc (s *stateDB) EndTransaction() {\n\t// Updated committed state of storage.\n\tfor value := range s.writtenSlots {\n\t\tvalue.committed, value.committedKnown = value.current, true\n\t}\n\n\t// EIP-161: At the end of the transaction, any account touched by the execution of that transaction\n\t// which is now empty SHALL instead become non-existent (i.e. deleted).\n\tfor _, addr := range s.emptyCandidates {\n\t\tif s.Empty(addr) {\n\t\t\ts.accountsToDelete = append(s.accountsToDelete, addr)\n\t\t\t// Mark the account storage state to be cleaned below.\n\t\t\ts.clearedAccounts[addr] = pendingClearing\n\t\t}\n\t}\n\n\t// Delete accounts scheduled for deletion - by suicide or because they are empty.\n\tif len(s.accountsToDelete) > 0 {\n\t\tfor _, addr := range s.accountsToDelete {\n\t\t\t// Transition accounts marked by suicide to be deleted.\n\t\t\tif s.HasSuicided(addr) {\n\t\t\t\ts.setAccountState(addr, accountNonExisting)\n\t\t\t\ts.setCodeInternal(addr, []byte{})\n\t\t\t\ts.clearedAccounts[addr] = pendingClearing\n\t\t\t}\n\n\t\t\t// If the account was already cleared because it was recreated, we skip this part.\n\t\t\tif state, found := s.clearedAccounts[addr]; found && (state == cleared || state == clearedAndTainted) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Note: storage state is handled through the clearedAccount map\n\t\t\t// the clearing of the data and storedDataCache at various phases\n\t\t\t// of the block processing.\n\t\t\ts.setAccountState(addr, accountNonExisting)\n\t\t\ts.resetBalance(addr) // reset balance if balance is set after suicide\n\t\t\ts.setNonceInternal(addr, 0)\n\t\t\ts.setCodeInternal(addr, []byte{})\n\n\t\t\t// Clear cached value states for the targeted account.\n\t\t\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\t\t\tif slot.addr == addr {\n\t\t\t\t\t// Clear cached values.\n\t\t\t\t\tvalue.stored = common.Value{}\n\t\t\t\t\tvalue.storedKnown = true\n\t\t\t\t\tvalue.committed = common.Value{}\n\t\t\t\t\tvalue.committedKnown = true\n\t\t\t\t\tvalue.current = common.Value{}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Signal to future fetches in this block that this account should be considered cleared.\n\t\t\ts.clearedAccounts[addr] = cleared\n\t\t}\n\n\t\ts.accountsToDelete = s.accountsToDelete[0:0]\n\t}\n\n\ts.writtenSlots = map[*slotValue]bool{}\n\t// Reset state, in particular seal effects by forgetting undo list.\n\ts.resetTransactionContext()\n}\n\nfunc (s *stateDB) GetTransactionChanges() map[common.Address][]common.Key {\n\tchanges := make(map[common.Address][]common.Key)\n\tfor addr := range s.accounts {\n\t\tchanges[addr] = nil\n\t}\n\tfor addr := range s.balances {\n\t\tchanges[addr] = nil\n\t}\n\tfor addr := range s.nonces {\n\t\tchanges[addr] = nil\n\t}\n\tfor addr := range s.codes {\n\t\tchanges[addr] = nil\n\t}\n\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\tif !value.committedKnown || value.committed != value.current {\n\t\t\tchanges[slot.addr] = append(changes[slot.addr], slot.key)\n\t\t}\n\t})\n\treturn changes\n}\n\n// Deprecated: not necessary, to be removed\nfunc (s *stateDB) AbortTransaction() {\n\t// Revert all effects and reset transaction context.\n\ts.RevertToSnapshot(0)\n\ts.resetTransactionContext()\n}\n\nfunc (s *stateDB) BeginBlock() {\n\t// ignored\n}\n\nfunc (s *stateDB) EndBlock(block uint64) {\n\tif !s.canApplyChanges {\n\t\terr := fmt.Errorf(\"unable to process EndBlock event in StateDB without permission to apply changes\")\n\t\ts.errors = append(s.errors, err)\n\t\treturn\n\t}\n\n\t// Skip applying changes if there have been any issues.\n\tif err := s.Check(); err != nil {\n\t\treturn\n\t}\n\n\tupdate := common.Update{}\n\n\t// Clear all accounts that have been deleted at some point during this block.\n\t// This will cause all storage slots of that accounts to be reset before new\n\t// values may be written in the subsequent updates.\n\tnonExistingAccounts := map[common.Address]bool{}\n\tfor addr, clearingState := range s.clearedAccounts {\n\t\tif clearingState == cleared || clearingState == clearedAndTainted {\n\t\t\tif s.accounts[addr].original == accountExists {\n\t\t\t\t// Pretend this account was originally deleted, such that in the loop below\n\t\t\t\t// it would be detected as re-created in case its new state is Existing.\n\t\t\t\ts.accounts[addr].original = accountNonExisting\n\t\t\t\t// If the account was not later re-created, we mark it for deletion.\n\t\t\t\tif s.accounts[addr].current != accountExists {\n\t\t\t\t\tupdate.AppendDeleteAccount(addr)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnonExistingAccounts[addr] = true\n\t\t\t}\n\t\t\t// Increment the reincarnation counter of cleared addresses to invalidate\n\t\t\t// cached entries in the stored data cache.\n\t\t\ts.reincarnation[addr] = s.reincarnation[addr] + 1\n\t\t}\n\t}\n\n\t// (Re-)create new or resurrected accounts.\n\tfor addr, value := range s.accounts {\n\t\tif value.original != value.current {\n\t\t\tif value.current == accountExists {\n\t\t\t\tupdate.AppendCreateAccount(addr)\n\t\t\t\tdelete(nonExistingAccounts, addr)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update balances.\n\tfor addr, value := range s.balances {\n\t\tif _, found := nonExistingAccounts[addr]; found {\n\t\t\tcontinue\n\t\t}\n\t\tif value.original == nil || value.original.Cmp(&value.current) != 0 {\n\t\t\tnewBalance, err := common.ToBalance(&value.current)\n\t\t\tif err != nil {\n\t\t\t\ts.errors = append(s.errors, fmt.Errorf(\"unable to convert big.Int balance %v to common.Balance: %w\", &value.current, err))\n\t\t\t} else {\n\t\t\t\tupdate.AppendBalanceUpdate(addr, newBalance)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update nonces.\n\tfor addr, value := range s.nonces {\n\t\tif _, found := nonExistingAccounts[addr]; found {\n\t\t\tcontinue\n\t\t}\n\t\tif value.original == nil || *value.original != value.current {\n\t\t\tupdate.AppendNonceUpdate(addr, common.ToNonce(s.nonces[addr].current))\n\t\t}\n\t}\n\n\t// Update storage values in state DB\n\ts.data.ForEach(func(slot slotId, value *slotValue) {\n\t\tif !value.storedKnown || value.stored != value.current {\n\t\t\tupdate.AppendSlotUpdate(slot.addr, slot.key, value.current)\n\t\t\ts.storedDataCache.Set(slot, storedDataCacheValue{value.current, s.reincarnation[slot.addr]})\n\t\t}\n\t})\n\n\t// Update modified codes.\n\tfor addr, value := range s.codes {\n\t\tif _, found := nonExistingAccounts[addr]; found {\n\t\t\tcontinue\n\t\t}\n\t\tif value.dirty {\n\t\t\tupdate.AppendCodeUpdate(addr, s.codes[addr].code)\n\t\t}\n\t}\n\n\t// Skip applying changes if there have been any issues.\n\tif err := s.Check(); err != nil {\n\t\treturn\n\t}\n\n\t// Send the update to the state.\n\tif err := s.state.Apply(block, update); err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to apply update for block %d: %w\", block, err))\n\t\treturn\n\t}\n\n\t// Reset internal state for next block\n\ts.ResetBlockContext()\n}\n\nfunc (s *stateDB) BeginEpoch() {\n\t// ignored\n}\n\nfunc (s *stateDB) EndEpoch(uint64) {\n\t// ignored\n}\n\nfunc (s *stateDB) GetHash() common.Hash {\n\thash, err := s.state.GetHash()\n\tif err != nil {\n\t\ts.errors = append(s.errors, fmt.Errorf(\"failed to compute hash: %w\", err))\n\t\treturn common.Hash{}\n\t}\n\treturn hash\n}\n\nfunc (s *stateDB) Check() error {\n\treturn errors.Join(\n\t\terrors.Join(s.errors...),\n\t\ts.state.Check())\n}\n\nfunc (s *stateDB) Flush() error {\n\treturn errors.Join(\n\t\ts.Check(),\n\t\ts.state.Flush(),\n\t)\n}\n\nfunc (s *stateDB) Close() error {\n\treturn errors.Join(\n\t\ts.Flush(),\n\t\ts.state.Close(),\n\t)\n}\n\nfunc (s *stateDB) StartBulkLoad(block uint64) BulkLoad {\n\ts.storedDataCache.Clear()\n\treturn &bulkLoad{s, common.Update{}, block, nil}\n}\n\nfunc (s *stateDB) GetMemoryFootprint() *common.MemoryFootprint {\n\tconst addressSize = 20\n\tconst keySize = 32\n\tconst hashSize = 32\n\tconst slotIdSize = addressSize + keySize\n\n\tmf := common.NewMemoryFootprint(unsafe.Sizeof(*s))\n\tmf.AddChild(\"state\", s.state.GetMemoryFootprint())\n\n\t// For account-states, balances, and nonces an over-approximation should be sufficient.\n\tmf.AddChild(\"accounts\", common.NewMemoryFootprint(uintptr(len(s.accounts))*(addressSize+unsafe.Sizeof(accountState{})+unsafe.Sizeof(common.AccountState(0)))))\n\tmf.AddChild(\"balances\", common.NewMemoryFootprint(uintptr(len(s.balances))*(addressSize+unsafe.Sizeof(balanceValue{}))))\n\tmf.AddChild(\"nonces\", common.NewMemoryFootprint(uintptr(len(s.nonces))*(addressSize+unsafe.Sizeof(nonceValue{})+8)))\n\tmf.AddChild(\"slots\", common.NewMemoryFootprint(uintptr(s.data.Size())*(slotIdSize+unsafe.Sizeof(slotValue{}))))\n\n\tvar sum uintptr = 0\n\tfor _, value := range s.codes {\n\t\tsum += addressSize\n\t\tif value.hash != nil {\n\t\t\tsum += hashSize\n\t\t}\n\t\tsum += uintptr(len(value.code))\n\t}\n\tmf.AddChild(\"codes\", common.NewMemoryFootprint(sum))\n\n\tvar boolean bool\n\tconst boolSize = unsafe.Sizeof(boolean)\n\tmf.AddChild(\"accessedAddresses\", common.NewMemoryFootprint(uintptr(len(s.accessedAddresses))*(addressSize+boolSize)))\n\tmf.AddChild(\"accessedSlots\", common.NewMemoryFootprint(uintptr(s.accessedSlots.Size())*(slotIdSize+boolSize)))\n\tmf.AddChild(\"writtenSlots\", common.NewMemoryFootprint(uintptr(len(s.writtenSlots))*(boolSize+unsafe.Sizeof(&slotValue{}))))\n\tmf.AddChild(\"storedDataCache\", s.storedDataCache.GetMemoryFootprint(0))\n\tmf.AddChild(\"reincarnation\", common.NewMemoryFootprint(uintptr(len(s.reincarnation))*(addressSize+unsafe.Sizeof(uint64(0)))))\n\tmf.AddChild(\"emptyCandidates\", common.NewMemoryFootprint(uintptr(len(s.emptyCandidates))*(addressSize)))\n\n\treturn mf\n}\n\nfunc (s *stateDB) GetArchiveStateDB(block uint64) (NonCommittableStateDB, error) {\n\tarchiveState, err := s.state.GetArchiveState(block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn CreateNonCommittableStateDBUsing(archiveState), nil\n}\n\nfunc (s *stateDB) GetArchiveBlockHeight() (uint64, bool, error) {\n\treturn s.state.GetArchiveBlockHeight()\n}\n\nfunc (s *stateDB) resetTransactionContext() {\n\ts.refund = 0\n\ts.ClearAccessList()\n\ts.transientStorage.Clear()\n\ts.undo = s.undo[0:0]\n\ts.emptyCandidates = s.emptyCandidates[0:0]\n\ts.logs = s.logs[0:0]\n}\n\nfunc (s *stateDB) ResetBlockContext() {\n\ts.accounts = make(map[common.Address]*accountState, len(s.accounts))\n\ts.balances = make(map[common.Address]*balanceValue, len(s.balances))\n\ts.nonces = make(map[common.Address]*nonceValue, len(s.nonces))\n\ts.data.Clear()\n\ts.clearedAccounts = make(map[common.Address]accountClearingState)\n\ts.codes = make(map[common.Address]*codeValue)\n\ts.logsInBlock = 0\n\ts.resetTransactionContext()\n}\n\nfunc (s *stateDB) resetState(state State) {\n\ts.ResetBlockContext()\n\ts.storedDataCache.Clear()\n\ts.reincarnation = map[common.Address]uint64{}\n\ts.errors = s.errors[0:0]\n\ts.state = state\n}\n\ntype bulkLoad struct {\n\tdb     *stateDB\n\tupdate common.Update\n\tblock  uint64\n\terrs   []error\n}\n\nfunc (l *bulkLoad) CreateAccount(addr common.Address) {\n\tl.update.AppendCreateAccount(addr)\n}\n\nfunc (l *bulkLoad) SetBalance(addr common.Address, value *big.Int) {\n\tnewBalance, err := common.ToBalance(value)\n\tif err != nil {\n\t\tl.errs = append(l.errs, fmt.Errorf(\"unable to convert big.Int balance to common.Balance: %w\", err))\n\t\treturn\n\t}\n\tl.update.AppendBalanceUpdate(addr, newBalance)\n}\n\nfunc (l *bulkLoad) SetNonce(addr common.Address, value uint64) {\n\tl.update.AppendNonceUpdate(addr, common.ToNonce(value))\n}\n\nfunc (l *bulkLoad) SetState(addr common.Address, key common.Key, value common.Value) {\n\tl.update.AppendSlotUpdate(addr, key, value)\n}\n\nfunc (l *bulkLoad) SetCode(addr common.Address, code []byte) {\n\tl.update.AppendCodeUpdate(addr, code)\n}\n\nfunc (l *bulkLoad) apply() {\n\t// Apply the update to the DB as one new block.\n\tif err := l.update.Normalize(); err != nil {\n\t\tl.errs = append(l.errs, err)\n\t\treturn\n\t}\n\terr := l.db.state.Apply(l.block, l.update)\n\tl.update = common.Update{}\n\tif err != nil {\n\t\tl.errs = append(l.errs, err)\n\t}\n}\n\nfunc (l *bulkLoad) Close() error {\n\tl.apply()\n\t// Return if errors occurred\n\tif l.errs != nil {\n\t\treturn errors.Join(l.errs...)\n\t}\n\n\t// Flush out all inserted data.\n\tif err := l.db.state.Flush(); err != nil {\n\t\treturn err\n\t}\n\t// Compute hash to bring cached hashes up-to-date.\n\t_, err := l.db.state.GetHash()\n\t// Reset state to allow starting bulk-load with existing database.\n\tl.db.resetState(l.db.state)\n\treturn err\n}\n\nvar nonCommittableStateDbPool = sync.Pool{\n\tNew: func() any {\n\t\t// We use a smaller stored-data cache size to support faster initialization\n\t\t// and resetting of instances. NonCommittable instances are expected to live\n\t\t// only for the duration of a few transactions.\n\t\treturn createStateDBWith(nil, nonCommittableStoredDataCacheSize, false)\n\t},\n}\n\ntype nonCommittableStateDB struct {\n\t*stateDB\n}\n\nfunc (db *nonCommittableStateDB) Copy() NonCommittableStateDB {\n\tcp := nonCommittableStateDbPool.Get().(*stateDB)\n\tcp.resetState(db.state)\n\n\tmaps.Copy(cp.accounts, db.accounts)\n\tmaps.Copy(cp.balances, db.balances)\n\tmaps.Copy(cp.nonces, db.nonces)\n\tdb.data.CopyTo(cp.data)\n\tmaps.Copy(cp.codes, db.codes)\n\tmaps.Copy(cp.clearedAccounts, db.clearedAccounts)\n\tmaps.Copy(cp.reincarnation, db.reincarnation)\n\tcp.logsInBlock = db.logsInBlock\n\t// we suppose ended tx - we may skip members,\n\t// which are reset at the end of every tx\n\n\treturn &nonCommittableStateDB{cp}\n}\n\nfunc (db *nonCommittableStateDB) Release() {\n\tif db.stateDB != nil {\n\t\tnonCommittableStateDbPool.Put(db.stateDB)\n\t\tdb.stateDB = nil\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/state_db.go b/go/state/state_db.go
--- a/go/state/state_db.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/state/state_db.go	(date 1718181191854)
@@ -20,6 +20,7 @@
 	"unsafe"
 
 	"github.com/Fantom-foundation/Carmen/go/common"
+	"github.com/Fantom-foundation/Carmen/go/common/tribool"
 )
 
 //go:generate mockgen -source state_db.go -destination state_db_mock.go -package state
@@ -52,6 +53,7 @@
 	SetState(common.Address, common.Key, common.Value)
 	GetTransientState(common.Address, common.Key) common.Value
 	SetTransientState(common.Address, common.Key, common.Value)
+	HasEmptyStorage(address common.Address) tribool.Tribool
 
 	// Code management.
 	GetCode(common.Address) []byte
@@ -827,6 +829,18 @@
 	}
 }
 
+func (s *stateDB) HasEmptyStorage(address common.Address) tribool.Tribool {
+	isEmpty, err := s.state.HasEmptyStorage(address)
+	if err != nil {
+		s.errors = append(s.errors, fmt.Errorf("failed to ask whether %x has empty storage: %w", address, err))
+		return tribool.Unknown()
+	}
+	if isEmpty {
+		return tribool.True()
+	}
+	return tribool.False()
+}
+
 func (s *stateDB) GetTransientState(addr common.Address, key common.Key) common.Value {
 	sid := slotId{addr, key}
 	val, _ := s.transientStorage.Get(sid)
Index: go/state/state.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright (c) 2024 Fantom Foundation\n//\n// Use of this software is governed by the Business Source License included\n// in the LICENSE file and at fantom.foundation/bsl11.\n//\n// Change Date: 2028-4-16\n//\n// On the date above, in accordance with the Business Source License, use of\n// this software will be governed by the GNU Lesser General Public License v3.\n\npackage state\n\n//go:generate mockgen -source state.go -destination state_mock.go -package state\n\nimport (\n\t\"github.com/Fantom-foundation/Carmen/go/backend\"\n\t\"github.com/Fantom-foundation/Carmen/go/common\"\n)\n\n// NoArchiveError is an error returned by implementation of the State interface\n// for archive operations if no archive is maintained by this implementation.\nconst NoArchiveError = common.ConstError(\"state does not maintain archive data\")\n\n// State interfaces provides access to accounts and smart contract values memory.\ntype State interface {\n\t// Exists obtains the current state of the provided account.\n\tExists(address common.Address) (bool, error)\n\n\t// GetBalance provides balance for the input account address.\n\tGetBalance(address common.Address) (common.Balance, error)\n\n\t// GetNonce returns nonce of the account for the  input account address.\n\tGetNonce(address common.Address) (common.Nonce, error)\n\n\t// GetStorage returns the memory slot for the account address (i.e. the contract) and the memory location key.\n\tGetStorage(address common.Address, key common.Key) (common.Value, error)\n\n\t// GetCode returns code of the contract for the input contract address.\n\tGetCode(address common.Address) ([]byte, error)\n\n\t// GetCodeSize returns the length of the contract for the input contract address.\n\tGetCodeSize(address common.Address) (int, error)\n\n\t// GetCodeHash returns the hash of the code of the input contract address.\n\tGetCodeHash(address common.Address) (common.Hash, error)\n\n\t// Apply applies the provided updates to the state content.\n\tApply(block uint64, update common.Update) error\n\n\t// GetHash hashes the values.\n\tGetHash() (common.Hash, error)\n\n\t// Flush writes all committed content to disk.\n\tFlush() error\n\n\t// Close flushes the store and closes it.\n\tClose() error\n\n\t// GetMemoryFootprint computes an approximation of the memory used by this state.\n\tGetMemoryFootprint() *common.MemoryFootprint\n\n\t// GetArchiveState provides a historical State view for given block.\n\t// An error is returned if the archive is not enabled or if it is empty.\n\tGetArchiveState(block uint64) (State, error)\n\n\t// GetArchiveBlockHeight provides the block height available in the archive. If\n\t// there is no block in the archive, the empty flag is returned.\n\t// An error is returned if the archive is not enabled or an IO issue occurred.\n\tGetArchiveBlockHeight() (height uint64, empty bool, err error)\n\n\t// Check checks the state of the DB and reports an error if issues have been\n\t// encountered.\n\t// Check should be called periodically to validate all interactions\n\t// with a State instance.\n\t// If an error is reported, all operations since the\n\t// last successful check need to be considered invalid.\n\tCheck() error\n\n\t// States can be snapshotted.\n\tbackend.Snapshotable\n}\n\ntype LiveDB interface {\n\tExists(address common.Address) (bool, error)\n\tGetBalance(address common.Address) (balance common.Balance, err error)\n\tGetNonce(address common.Address) (nonce common.Nonce, err error)\n\tGetStorage(address common.Address, key common.Key) (value common.Value, err error)\n\tGetCode(address common.Address) (value []byte, err error)\n\tGetCodeSize(address common.Address) (size int, err error)\n\tGetCodeHash(address common.Address) (hash common.Hash, err error)\n\tGetHash() (hash common.Hash, err error)\n\tApply(block uint64, update common.Update) (archiveUpdateHints common.Releaser, err error)\n\tFlush() error\n\tClose() error\n\tcommon.MemoryFootprintProvider\n\n\t// getSnapshotableComponents lists all components required to back-up or restore\n\t// for snapshotting this schema. Returns nil if snapshotting is not supported.\n\tGetSnapshotableComponents() []backend.Snapshotable\n\n\t// Called after synching to a new state, requisting the schema to update cached\n\t// values or tables not covered by the snapshot synchronization.\n\tRunPostRestoreTasks() error\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go/state/state.go b/go/state/state.go
--- a/go/state/state.go	(revision 5f1a329648ca0dfc6ebfbd1f63938951d09ad893)
+++ b/go/state/state.go	(date 1718180489370)
@@ -35,6 +35,8 @@
 	// GetStorage returns the memory slot for the account address (i.e. the contract) and the memory location key.
 	GetStorage(address common.Address, key common.Key) (common.Value, error)
 
+	HasEmptyStorage(address common.Address) (bool, error)
+
 	// GetCode returns code of the contract for the input contract address.
 	GetCode(address common.Address) ([]byte, error)
 
@@ -85,6 +87,7 @@
 	GetBalance(address common.Address) (balance common.Balance, err error)
 	GetNonce(address common.Address) (nonce common.Nonce, err error)
 	GetStorage(address common.Address, key common.Key) (value common.Value, err error)
+	//HasEmptyStorage(address common.Address) (isEmpty bool, err error)
 	GetCode(address common.Address) (value []byte, err error)
 	GetCodeSize(address common.Address) (size int, err error)
 	GetCodeHash(address common.Address) (hash common.Hash, err error)
