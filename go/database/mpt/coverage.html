
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mpt: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Fantom-foundation/Carmen/go/database/mpt/account.go (100.0%)</option>
				
				<option value="file1">github.com/Fantom-foundation/Carmen/go/database/mpt/archive_trie.go (98.3%)</option>
				
				<option value="file2">github.com/Fantom-foundation/Carmen/go/database/mpt/config.go (0.0%)</option>
				
				<option value="file3">github.com/Fantom-foundation/Carmen/go/database/mpt/decoder.go (99.0%)</option>
				
				<option value="file4">github.com/Fantom-foundation/Carmen/go/database/mpt/diff.go (100.0%)</option>
				
				<option value="file5">github.com/Fantom-foundation/Carmen/go/database/mpt/directory_lock.go (100.0%)</option>
				
				<option value="file6">github.com/Fantom-foundation/Carmen/go/database/mpt/dirty_directory_mark.go (100.0%)</option>
				
				<option value="file7">github.com/Fantom-foundation/Carmen/go/database/mpt/forest.go (97.7%)</option>
				
				<option value="file8">github.com/Fantom-foundation/Carmen/go/database/mpt/hash_cache.go (100.0%)</option>
				
				<option value="file9">github.com/Fantom-foundation/Carmen/go/database/mpt/hasher.go (90.4%)</option>
				
				<option value="file10">github.com/Fantom-foundation/Carmen/go/database/mpt/hasher_mocks.go (0.0%)</option>
				
				<option value="file11">github.com/Fantom-foundation/Carmen/go/database/mpt/live_trie.go (100.0%)</option>
				
				<option value="file12">github.com/Fantom-foundation/Carmen/go/database/mpt/nibble.go (100.0%)</option>
				
				<option value="file13">github.com/Fantom-foundation/Carmen/go/database/mpt/node_cache.go (91.1%)</option>
				
				<option value="file14">github.com/Fantom-foundation/Carmen/go/database/mpt/node_cache_mocks.go (74.4%)</option>
				
				<option value="file15">github.com/Fantom-foundation/Carmen/go/database/mpt/node_flusher.go (100.0%)</option>
				
				<option value="file16">github.com/Fantom-foundation/Carmen/go/database/mpt/node_hash.go (100.0%)</option>
				
				<option value="file17">github.com/Fantom-foundation/Carmen/go/database/mpt/node_id.go (100.0%)</option>
				
				<option value="file18">github.com/Fantom-foundation/Carmen/go/database/mpt/node_path.go (100.0%)</option>
				
				<option value="file19">github.com/Fantom-foundation/Carmen/go/database/mpt/nodes.go (99.0%)</option>
				
				<option value="file20">github.com/Fantom-foundation/Carmen/go/database/mpt/nodes_mocks.go (45.7%)</option>
				
				<option value="file21">github.com/Fantom-foundation/Carmen/go/database/mpt/path.go (100.0%)</option>
				
				<option value="file22">github.com/Fantom-foundation/Carmen/go/database/mpt/proof.go (90.7%)</option>
				
				<option value="file23">github.com/Fantom-foundation/Carmen/go/database/mpt/proof_mocks.go (0.0%)</option>
				
				<option value="file24">github.com/Fantom-foundation/Carmen/go/database/mpt/state.go (99.5%)</option>
				
				<option value="file25">github.com/Fantom-foundation/Carmen/go/database/mpt/state_mocks.go (57.7%)</option>
				
				<option value="file26">github.com/Fantom-foundation/Carmen/go/database/mpt/verification.go (89.1%)</option>
				
				<option value="file27">github.com/Fantom-foundation/Carmen/go/database/mpt/verification_mocks.go (100.0%)</option>
				
				<option value="file28">github.com/Fantom-foundation/Carmen/go/database/mpt/visitor.go (65.3%)</option>
				
				<option value="file29">github.com/Fantom-foundation/Carmen/go/database/mpt/visitor_mocks.go (100.0%)</option>
				
				<option value="file30">github.com/Fantom-foundation/Carmen/go/database/mpt/write_buffer.go (98.8%)</option>
				
				<option value="file31">github.com/Fantom-foundation/Carmen/go/database/mpt/write_buffer_mocks.go (67.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/common/amount"
)

// AccountInfo is the per-account information stored for each account in the
// State (excluding the storage root).
type AccountInfo struct {
        Nonce    common.Nonce
        Balance  amount.Amount
        CodeHash common.Hash
}

// IsEmpty checks whether the account information is empty, and thus, the
// default value. All accounts not present in an MPT are implicitly empty. Also
// no empty accounts may be explicitly stored.
func (a *AccountInfo) IsEmpty() bool <span class="cov8" title="1">{
        return *a == AccountInfo{}
}</span>

// ----------------------------------------------------------------------------
//                           AccountInfo Encoder
// ----------------------------------------------------------------------------

type AccountInfoEncoder struct{}

func (AccountInfoEncoder) GetEncodedSize() int <span class="cov8" title="1">{
        return common.AddressSize + amount.BytesLength + common.HashSize
}</span>

func (AccountInfoEncoder) Store(dst []byte, info *AccountInfo) <span class="cov8" title="1">{
        copy(dst[0:], info.Nonce[:])
        b := info.Balance.Bytes32()
        copy(dst[common.NonceSize:], b[:])
        copy(dst[common.NonceSize+amount.BytesLength:], info.CodeHash[:])
}</span>

func (AccountInfoEncoder) Load(src []byte, info *AccountInfo) <span class="cov8" title="1">{
        copy(info.Nonce[:], src[0:])
        info.Balance = amount.NewFromBytes(src[common.NonceSize : common.NonceSize+amount.BytesLength]...)
        copy(info.CodeHash[:], src[common.NonceSize+amount.BytesLength:])
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "os"
        "sync"
        "unsafe"

        "github.com/Fantom-foundation/Carmen/go/backend/archive"
        "github.com/Fantom-foundation/Carmen/go/common/witness"

        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/common/amount"
)

// ArchiveTrie retains a per-block history of the state trie. Each state is
// a trie in a Forest of which the root node is retained. Updates can only
// be applied through the `Add` method, according to the `archive.Archiveâ€œ
// interface, which this type is implementing.
//
// Its main task is to keep track of state roots and to freeze the head
// state after each block.
type ArchiveTrie struct {
        head         LiveState // the current head-state
        forest       Database  // global forest with all versions of LiveState
        nodeSource   NodeSource
        roots        rootList   // the roots of individual blocks indexed by block height
        rootsMutex   sync.Mutex // protecting access to the roots list
        rootFile     string     // the file storing the list of roots
        addMutex     sync.Mutex // a mutex to make sure that at any time only one thread is adding new blocks
        errorMutex   sync.RWMutex
        archiveError error // a non-nil error will be stored here should it occur during any archive operation
}

func OpenArchiveTrie(directory string, config MptConfig, cacheConfig NodeCacheConfig) (*ArchiveTrie, error) <span class="cov8" title="1">{
        lock, err := openStateDirectory(directory)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rootfile := directory + "/roots.dat"
        roots, err := loadRoots(rootfile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">forestConfig := ForestConfig{Mode: Immutable, NodeCacheConfig: cacheConfig}
        forest, err := OpenFileForest(directory, config, forestConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">head, err := makeTrie(directory, forest)
        if err != nil </span><span class="cov8" title="1">{
                forest.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">state, err := newMptState(directory, lock, head)
        if err != nil </span><span class="cov8" title="1">{
                head.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ArchiveTrie{
                head:       state,
                forest:     forest,
                nodeSource: forest,
                roots:      roots,
                rootFile:   rootfile,
        }, nil</span>
}

// VerifyArchiveTrie validates file-based archive stored in the given directory.
// If the test passes, the data stored in the respective directory
// can be considered a valid archive database of the given configuration.
func VerifyArchiveTrie(directory string, config MptConfig, observer VerificationObserver) error <span class="cov8" title="1">{
        roots, err := loadRoots(directory + "/roots.dat")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if roots.length() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return VerifyMptState(directory, config, roots.roots, observer)</span>
}

func (a *ArchiveTrie) Add(block uint64, update common.Update, hint any) error <span class="cov8" title="1">{
        if err := a.CheckErrors(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">precomputedHashes, _ := hint.(*NodeHashes)

        a.addMutex.Lock()
        defer a.addMutex.Unlock()

        a.rootsMutex.Lock()
        if uint64(a.roots.length()) &gt; block </span><span class="cov8" title="1">{
                a.rootsMutex.Unlock()
                return fmt.Errorf("block %d already present", block)
        }</span>

        // Mark skipped blocks as having no changes.
        <span class="cov8" title="1">if uint64(a.roots.length()) &lt; block </span><span class="cov8" title="1">{
                lastHash, err := a.head.GetHash()
                if err != nil </span><span class="cov8" title="1">{
                        a.rootsMutex.Unlock()
                        return a.addError(err)
                }</span>
                <span class="cov8" title="1">for uint64(a.roots.length()) &lt; block </span><span class="cov8" title="1">{
                        a.roots.append(Root{a.head.Root(), lastHash})
                }</span>
        }
        <span class="cov8" title="1">a.rootsMutex.Unlock()

        // Apply all the changes of the update.
        if err := update.ApplyTo(a.head); err != nil </span><span class="cov8" title="1">{
                return a.addError(err)
        }</span>

        // Freeze new state.
        <span class="cov8" title="1">root := a.head.Root()
        if err := a.forest.Freeze(&amp;root); err != nil </span><span class="cov8" title="1">{
                return a.addError(err)
        }</span>

        // Refresh hashes.
        <span class="cov8" title="1">var err error
        var hash common.Hash
        if precomputedHashes == nil </span><span class="cov8" title="1">{
                var hashes *NodeHashes
                hash, hashes, err = a.head.UpdateHashes()
                if hashes != nil </span><span class="cov8" title="1">{
                        hashes.Release()
                }</span>
        } else<span class="cov8" title="1"> {
                err = a.head.setHashes(precomputedHashes)
                if err == nil </span><span class="cov8" title="1">{
                        hash, err = a.head.GetHash()
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return a.addError(err)
        }</span>

        // Save new root node.
        <span class="cov8" title="1">a.rootsMutex.Lock()
        a.roots.append(Root{a.head.Root(), hash})
        a.rootsMutex.Unlock()
        return nil</span>
}

func (a *ArchiveTrie) GetBlockHeight() (block uint64, empty bool, err error) <span class="cov8" title="1">{
        a.rootsMutex.Lock()
        length := uint64(a.roots.length())
        a.rootsMutex.Unlock()
        if length == 0 </span><span class="cov8" title="1">{
                return 0, true, nil
        }</span>
        <span class="cov8" title="1">return length - 1, false, nil</span>
}

func (a *ArchiveTrie) Exists(block uint64, account common.Address) (exists bool, err error) <span class="cov8" title="1">{
        view, err := a.getView(block)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">_, exists, err = view.GetAccountInfo(account)
        if err != nil </span><span class="cov8" title="1">{
                return false, a.addError(err)
        }</span>
        <span class="cov8" title="1">return exists, err</span>
}

func (a *ArchiveTrie) GetBalance(block uint64, account common.Address) (balance amount.Amount, err error) <span class="cov8" title="1">{
        view, err := a.getView(block)
        if err != nil </span><span class="cov8" title="1">{
                return amount.New(), err
        }</span>
        <span class="cov8" title="1">info, _, err := view.GetAccountInfo(account)
        if err != nil </span><span class="cov8" title="1">{
                return amount.New(), a.addError(err)
        }</span>
        <span class="cov8" title="1">return info.Balance, nil</span>
}

func (a *ArchiveTrie) GetCode(block uint64, account common.Address) (code []byte, err error) <span class="cov8" title="1">{
        view, err := a.getView(block)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info, _, err := view.GetAccountInfo(account)
        if err != nil </span><span class="cov8" title="1">{
                return nil, a.addError(err)
        }</span>
        <span class="cov8" title="1">return a.head.GetCodeForHash(info.CodeHash), nil</span>
}

func (a *ArchiveTrie) GetCodes() map[common.Hash][]byte <span class="cov8" title="1">{
        return a.head.GetCodes()
}</span>

func (a *ArchiveTrie) GetNonce(block uint64, account common.Address) (nonce common.Nonce, err error) <span class="cov8" title="1">{
        view, err := a.getView(block)
        if err != nil </span><span class="cov8" title="1">{
                return common.Nonce{}, err
        }</span>
        <span class="cov8" title="1">info, _, err := view.GetAccountInfo(account)
        if err != nil </span><span class="cov8" title="1">{
                return common.Nonce{}, a.addError(err)
        }</span>
        <span class="cov8" title="1">return info.Nonce, nil</span>
}

func (a *ArchiveTrie) GetStorage(block uint64, account common.Address, slot common.Key) (value common.Value, err error) <span class="cov8" title="1">{
        view, err := a.getView(block)
        if err != nil </span><span class="cov8" title="1">{
                return common.Value{}, a.addError(err)
        }</span>
        <span class="cov8" title="1">return view.GetValue(account, slot)</span>
}

func (a *ArchiveTrie) GetAccountHash(block uint64, account common.Address) (common.Hash, error) <span class="cov8" title="1">{
        return common.Hash{}, fmt.Errorf("not implemented")
}</span>

func (a *ArchiveTrie) GetHash(block uint64) (hash common.Hash, err error) <span class="cov8" title="1">{
        a.rootsMutex.Lock()
        length := uint64(a.roots.length())
        if block &gt;= length </span><span class="cov8" title="1">{
                a.rootsMutex.Unlock()
                return common.Hash{}, fmt.Errorf("invalid block: %d &gt;= %d", block, length)
        }</span>
        <span class="cov8" title="1">res := a.roots.get(block).Hash
        a.rootsMutex.Unlock()
        return res, nil</span>
}

func (a *ArchiveTrie) CreateWitnessProof(block uint64, address common.Address, keys ...common.Key) (witness.Proof, error) <span class="cov8" title="1">{
        if a.nodeSource.getConfig().Name != "S5-Archive" </span><span class="cov8" title="1">{
                return nil, archive.ErrWitnessProofNotSupported
        }</span>
        <span class="cov8" title="1">a.rootsMutex.Lock()
        ref := a.roots.roots[block].NodeRef
        a.rootsMutex.Unlock()
        return CreateWitnessProof(a.nodeSource, &amp;ref, address, keys...)</span>
}

// GetDiff computes the difference between the given source and target blocks.
func (a *ArchiveTrie) GetDiff(srcBlock, trgBlock uint64) (Diff, error) <span class="cov8" title="1">{
        a.rootsMutex.Lock()
        if srcBlock &gt;= uint64(a.roots.length()) </span><span class="cov8" title="1">{
                a.rootsMutex.Unlock()
                return Diff{}, fmt.Errorf("source block %d not present in archive, highest block is %d", srcBlock, a.roots.length()-1)
        }</span>
        <span class="cov8" title="1">if trgBlock &gt;= uint64(a.roots.length()) </span><span class="cov8" title="1">{
                a.rootsMutex.Unlock()
                return Diff{}, fmt.Errorf("target block %d not present in archive, highest block is %d", trgBlock, a.roots.length()-1)
        }</span>
        <span class="cov8" title="1">before := a.roots.get(srcBlock).NodeRef
        after := a.roots.get(trgBlock).NodeRef
        a.rootsMutex.Unlock()
        return GetDiff(a.nodeSource, &amp;before, &amp;after)</span>
}

// GetDiffForBlock computes the diff introduced by the given block compared to its
// predecessor. Note that this enables access to the changes introduced by block 0.
func (a *ArchiveTrie) GetDiffForBlock(block uint64) (Diff, error) <span class="cov8" title="1">{
        if block == 0 </span><span class="cov8" title="1">{
                a.rootsMutex.Lock()
                if a.roots.length() == 0 </span><span class="cov8" title="1">{
                        a.rootsMutex.Unlock()
                        return Diff{}, fmt.Errorf("archive is empty, no diff present for block 0")
                }</span>
                <span class="cov8" title="1">after := a.roots.get(0).NodeRef
                a.rootsMutex.Unlock()
                return GetDiff(a.nodeSource, &amp;emptyNodeReference, &amp;after)</span>
        }
        <span class="cov8" title="1">return a.GetDiff(block-1, block)</span>
}

func (a *ArchiveTrie) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        mf := common.NewMemoryFootprint(unsafe.Sizeof(*a))
        mf.AddChild("head", a.head.GetMemoryFootprint())
        a.rootsMutex.Lock()
        mf.AddChild("roots", common.NewMemoryFootprint(uintptr(a.roots.length())*unsafe.Sizeof(NodeId(0))))
        a.rootsMutex.Unlock()
        return mf
}</span>

func (a *ArchiveTrie) Check() error <span class="cov8" title="1">{
        roots := make([]*NodeReference, a.roots.length())
        for i := 0; i &lt; a.roots.length(); i++ </span><span class="cov8" title="1">{
                roots[i] = &amp;a.roots.roots[i].NodeRef
        }</span>
        <span class="cov8" title="1">return errors.Join(
                a.CheckErrors(),
                a.forest.CheckAll(roots))</span>
}

func (a *ArchiveTrie) Dump() <span class="cov8" title="1">{
        a.rootsMutex.Lock()
        defer a.rootsMutex.Unlock()
        for i, root := range a.roots.roots </span><span class="cov8" title="1">{
                fmt.Printf("\nBlock %d: %x\n", i, root.Hash)
                view := getTrieView(root.NodeRef, a.forest)
                view.Dump()
                fmt.Printf("\n")
        }</span>
}

func (a *ArchiveTrie) Flush() error <span class="cov8" title="1">{
        a.rootsMutex.Lock()
        defer a.rootsMutex.Unlock()
        return errors.Join(
                a.CheckErrors(),
                a.head.Flush(),
                a.roots.storeRoots(),
        )
}</span>

func (a *ArchiveTrie) VisitTrie(block uint64, visitor NodeVisitor) error <span class="cov0" title="0">{
        view, err := a.getView(block)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return view.VisitTrie(visitor)</span>
}

func (a *ArchiveTrie) Close() error <span class="cov8" title="1">{
        return errors.Join(
                a.CheckErrors(),
                a.head.closeWithError(a.Flush()))
}</span>

func (a *ArchiveTrie) getView(block uint64) (*LiveTrie, error) <span class="cov8" title="1">{
        if err := a.CheckErrors(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">a.rootsMutex.Lock()
        length := uint64(a.roots.length())
        if block &gt;= length </span><span class="cov8" title="1">{
                a.rootsMutex.Unlock()
                return nil, fmt.Errorf("invalid block: %d &gt;= %d", block, length)
        }</span>
        <span class="cov8" title="1">rootRef := a.roots.roots[block].NodeRef
        a.rootsMutex.Unlock()
        return getTrieView(rootRef, a.forest), nil</span>
}

// CheckErrors returns a non-nil error should any error
// happen during any operation in this archive.
// In particular, updating this archive or getting
// values out of it may fail, and in this case,
// the error is stored and returned in this method.
// Further calls to this archive produce the same
// error as this method returns.
func (a *ArchiveTrie) CheckErrors() error <span class="cov8" title="1">{
        a.errorMutex.RLock()
        defer a.errorMutex.RUnlock()
        return a.archiveError
}</span>

func (a *ArchiveTrie) addError(err error) error <span class="cov8" title="1">{
        a.errorMutex.Lock()
        defer a.errorMutex.Unlock()
        a.archiveError = errors.Join(a.archiveError, err)
        return a.archiveError
}</span>

// ---- Reading and Writing Root Node ID Lists ----

// rootList is a utility type managing an in-memory copy of the list of roots
// of an archive and its synchronization with an on-disk file copy.
type rootList struct {
        roots          []Root
        filename       string
        numRootsInFile int
}

func (l *rootList) length() int <span class="cov8" title="1">{
        return len(l.roots)
}</span>

func (l *rootList) get(block uint64) Root <span class="cov8" title="1">{
        return l.roots[block]
}</span>

func (l *rootList) append(r Root) <span class="cov8" title="1">{
        l.roots = append(l.roots, r)
}</span>

func loadRoots(filename string) (rootList, error) <span class="cov8" title="1">{
        // If there is no file, initialize and return an empty list.
        if _, err := os.Stat(filename); err != nil </span><span class="cov8" title="1">{
                return rootList{filename: filename}, nil
        }</span>

        <span class="cov8" title="1">f, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return rootList{}, err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        reader := bufio.NewReader(f)
        roots, err := loadRootsFrom(reader)
        if err != nil </span><span class="cov8" title="1">{
                return rootList{}, err
        }</span>
        <span class="cov8" title="1">return rootList{
                roots:          roots,
                filename:       filename,
                numRootsInFile: len(roots),
        }, nil</span>
}

func loadRootsFrom(reader io.Reader) ([]Root, error) <span class="cov8" title="1">{
        res := []Root{}
        encoder := NodeIdEncoder{}
        buffer := make([]byte, encoder.GetEncodedSize())
        var hash common.Hash
        for </span><span class="cov8" title="1">{
                if _, err := io.ReadFull(reader, buffer); err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                return res, nil
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("invalid root file format: %v", err)</span>
                }

                <span class="cov8" title="1">if _, err := io.ReadFull(reader, hash[:]); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid root file format: %v", err)
                }</span>

                <span class="cov8" title="1">var id NodeId
                encoder.Load(buffer, &amp;id)
                res = append(res, Root{NewNodeReference(id), hash})</span>
        }
}

func StoreRoots(filename string, roots []Root) error <span class="cov8" title="1">{
        list := rootList{roots: roots, filename: filename}
        return list.storeRoots()
}</span>

func (l *rootList) storeRoots() error <span class="cov8" title="1">{
        toBeWritten := l.roots[l.numRootsInFile:]
        if l.numRootsInFile &gt; 0 &amp;&amp; len(toBeWritten) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">f, err := os.OpenFile(l.filename, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">writer := bufio.NewWriter(f)
        res := errors.Join(
                storeRootsTo(writer, toBeWritten),
                writer.Flush(),
                f.Close(),
        )
        if res == nil </span><span class="cov8" title="1">{
                l.numRootsInFile = len(l.roots)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func storeRootsTo(writer io.Writer, roots []Root) error <span class="cov8" title="1">{
        // Simple file format: [&lt;node-id&gt;&lt;state-hash&gt;]*
        encoder := NodeIdEncoder{}
        buffer := make([]byte, encoder.GetEncodedSize())
        for _, root := range roots </span><span class="cov8" title="1">{
                encoder.Store(buffer, &amp;root.NodeRef.id)
                if _, err := writer.Write(buffer[:]); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := writer.Write(root.Hash[:]); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

// MptConfig defines a set of configuration options for customizing the MPT
// implementation. It is mainly intended to facilitate the accurate modeling
// of Ethereum's MPT implementation (see schema 5) but may also be used for
// experimenting with design options.
type MptConfig struct {
        // A descriptive name for this configuration. It has no effect except for
        // logging and debugging purposes.
        Name string

        // If set to true, the address of accounts and keys of values are hashed
        // using keccak256 before being used to navigate the trie. If false, the
        // addresses and keys are directly used as paths for the MPT.
        UseHashedPaths bool

        // If enabled, leaf nodes are tracking the number of nibbles of their path
        // not covered by parent nodes. If disabled, this information is not
        // maintained. In either way, the full path is stored in leaf nodes.
        // The suffix length is required for Ethereum's MPT variant.
        TrackSuffixLengthsInLeafNodes bool

        // The hashing algorithm to be used in the MPT implementation.
        Hashing hashAlgorithm

        // Determines whether hashes are stored with nodes or with the parents.
        HashStorageLocation HashStorageLocation
}

var S4LiveConfig = MptConfig{
        Name:                          "S4-Live",
        UseHashedPaths:                false,
        TrackSuffixLengthsInLeafNodes: false,
        Hashing:                       DirectHashing,
        HashStorageLocation:           HashStoredWithParent,
}

var S4ArchiveConfig = MptConfig{
        Name:                          "S4-Archive",
        UseHashedPaths:                false,
        TrackSuffixLengthsInLeafNodes: false,
        Hashing:                       DirectHashing,
        HashStorageLocation:           HashStoredWithNode,
}

var S5LiveConfig = MptConfig{
        Name:                          "S5-Live",
        UseHashedPaths:                true,
        TrackSuffixLengthsInLeafNodes: true,
        Hashing:                       EthereumLikeHashing, // requires tracking of suffix lengths
        HashStorageLocation:           HashStoredWithParent,
}

var S5ArchiveConfig = MptConfig{
        Name:                          "S5-Archive",
        UseHashedPaths:                true,
        TrackSuffixLengthsInLeafNodes: true,
        Hashing:                       EthereumLikeHashing, // requires tracking of suffix lengths
        HashStorageLocation:           HashStoredWithNode,
}

var allMptConfigs = []MptConfig{
        S4LiveConfig, S4ArchiveConfig,
        S5LiveConfig, S5ArchiveConfig,
}

// GetConfigByName attempts to locate a configuration with the given name.
func GetConfigByName(name string) (MptConfig, bool) <span class="cov0" title="0">{
        for _, config := range allMptConfigs </span><span class="cov0" title="0">{
                if config.Name == name </span><span class="cov0" title="0">{
                        return config, true
                }</span>
        }
        <span class="cov0" title="0">return MptConfig{}, false</span>
}

type HashStorageLocation bool

const (
        // HashStoredWithNode is a configuration option where the hash of a node
        // is stored together with the node. Storing hashes with nodes avoids
        // retaining multiple copies of the same hash in Archives. However, it
        // increases the number of disk accesses required for computing hashes.
        // It is thus the recommended mode for Archives
        HashStoredWithNode HashStorageLocation = true
        // HashStoredWithParent is a configuration option where hashes of nodes
        // are stored in their respective parent nodes. For trees, this mode is
        // equally disk-space efficient as storing hashes in nodes, but less
        // disk-seek operations are required for re-computing hashes. It is thus
        // the main mode recommended for LiveDB configurations. For Archives
        // this mode results in the redundant storage of hashes, since each
        // node may have multiple parent nodes.
        HashStoredWithParent HashStorageLocation = false
)

func (l HashStorageLocation) String() string <span class="cov0" title="0">{
        switch l </span>{
        case HashStoredWithNode:<span class="cov0" title="0">
                return "HashStoredWithNode"</span>
        case HashStoredWithParent:<span class="cov0" title="0">
                return "HashStoredWithParent"</span>
        default:<span class="cov0" title="0">
                return "?"</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "bytes"
        "fmt"

        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/common/amount"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/rlp"
)

// DecodeFromRlp decodes a node from RLP-encoded data.
// It checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded node.
func DecodeFromRlp(data []byte) (Node, error) <span class="cov8" title="1">{
        if bytes.Equal(data, emptyStringRlpEncoded) </span><span class="cov8" title="1">{
                return EmptyNode{}, nil
        }</span>

        <span class="cov8" title="1">item, err := rlp.Decode(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">list, ok := item.(rlp.List)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid node type: got: %T, wanted: List", item)
        }</span>

        <span class="cov8" title="1">switch len(list.Items) </span>{
        case 2:<span class="cov8" title="1">
                path, ok := list.Items[0].(rlp.String)
                if !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid prefix type: got: %T, wanted: String", list.Items[0])
                }</span>
                <span class="cov8" title="1">nibbles := compactPathToNibbles(path.Str)
                if len(nibbles) &gt; 64 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid path length: got: %v, wanted: &lt;= 64", len(nibbles))
                }</span>
                <span class="cov8" title="1">compactPath := CreatePathFromNibbles(nibbles)
                if isEncodedLeafNode(path.Str) </span><span class="cov8" title="1">{
                        return decodeLeafNodeFromRlp(compactPath, list.Items[1])
                }</span> else<span class="cov8" title="1"> {
                        return decodeExtensionNodeFromRlp(compactPath, list.Items[1])
                }</span>
        case 17:<span class="cov8" title="1">
                return decodeBranchNodeFromRlp(list)</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("invalid number of list elements: got: %v, wanted: either 2 or 17", len(list.Items))</span>
}

// decodeExtensionNodeFromRlp decodes an extension node from RLP-encoded data.
// It checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded extension node.
func decodeExtensionNodeFromRlp(path Path, payload rlp.Item) (Node, error) <span class="cov8" title="1">{
        hashed, embedded, err := decodeEmbeddedOrHashedNode(payload)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ExtensionNode{path: path, nextHash: hashed, nextIsEmbedded: embedded}, nil</span>
}

// decodeLeafNodeFromRlp decodes a leaf node from RLP-encoded data.
// A leaf node can be either a value node or an account node.
// The node type is distinguished by the length of the payload.
// The value node has a payload of size &lt;= common.ValueSize,
// in other cases, it is an account node.
// Ths method checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded leaf node.
func decodeLeafNodeFromRlp(path Path, payload rlp.Item) (Node, error) <span class="cov8" title="1">{
        str, ok := payload.(rlp.String)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid node payload: got: %T, wanted: String", payload)
        }</span>

        <span class="cov8" title="1">innerPayload, err := rlp.Decode(str.Str)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">switch n := innerPayload.(type) </span>{
        case rlp.String:<span class="cov8" title="1">
                return decodeValueNodeFromRlp(path, n)</span>
        case rlp.List:<span class="cov8" title="1">
                return decodeAccountFromRlp(path, n)</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid leaf node type: got: %T, wanted: String or List", innerPayload)</span>
}

// decodeValueNodeFromRlp decodes a value node from RLP-encoded data.
// The value node will be decoded with the Key equivalent the input path.
// It means that the key will not be the full storage key, as this
// information is not available in the RLP-encoded data.
// It checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded value node.
func decodeValueNodeFromRlp(path Path, payload rlp.String) (Node, error) <span class="cov8" title="1">{
        var key common.Key
        copy(key[:], path.GetPackedNibbles()) // it does not cover full key as it is not available in RLP.
        var value common.Value
        copy(value[32-len(payload.Str):], payload.Str) // align the value to the right
        return &amp;ValueNode{key: key, value: value, pathLength: byte(path.Length())}, nil
}</span>

// decodeAccountFromRlp decodes an account node from RLP-encoded data.
// The account node will be decoded with the address equivalent the input path.
// It means that the address will not be the full address, as this
// information is not available in the RLP-encoded data.
// It checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded account node.
func decodeAccountFromRlp(path Path, items rlp.List) (Node, error) <span class="cov8" title="1">{
        if len(items.Items) != 4 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid number of account items: got: %v, wanted: 4", len(items.Items))
        }</span>

        <span class="cov8" title="1">nonceStr, ok := items.Items[0].(rlp.String)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid nonce type: got: %T, wanted: String", items.Items[0])
        }</span>
        <span class="cov8" title="1">nonce, err := nonceStr.Uint64()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid nonce: %v", err)
        }</span>

        <span class="cov8" title="1">balanceStr, ok := items.Items[1].(rlp.String)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid balance type: got: %T, wanted: String", items.Items[1])
        }</span>
        <span class="cov8" title="1">balance := balanceStr.BigInt()
        balanceAmount, err := amount.NewFromBigInt(balance)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid balance: %v", err)
        }</span>

        <span class="cov8" title="1">storageHashStr, ok := items.Items[2].(rlp.String)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid storage hash type: got: %T, wanted: String", items.Items[2])
        }</span>
        <span class="cov8" title="1">if len(storageHashStr.Str) &gt; common.HashSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("storage hash is too long: got: %v, wanted: &lt;= 32", len(storageHashStr.Str))
        }</span>
        <span class="cov8" title="1">var storageHash common.Hash
        copy(storageHash[:], storageHashStr.Str)

        codeHashStr, ok := items.Items[3].(rlp.String)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid code hash type: got: %T, wanted: String", items.Items[3])
        }</span>
        <span class="cov8" title="1">if len(codeHashStr.Str) &gt; common.HashSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("code hash is too long: got: %v, wanted: &lt;= 32", len(codeHashStr.Str))
        }</span>

        <span class="cov8" title="1">var codeHash common.Hash
        copy(codeHash[:], codeHashStr.Str)

        return &amp;decodedAccountNode{AccountNode{
                storageHash: storageHash,
                pathLength:  byte(path.Length()),
                info: AccountInfo{
                        Nonce:    common.ToNonce(nonce),
                        Balance:  balanceAmount,
                        CodeHash: codeHash,
                }}, path}, nil</span>
}

// decodeBranchNodeFromRlp decodes a branch node from RLP-encoded data.
// It checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded branch node.
func decodeBranchNodeFromRlp(list rlp.List) (Node, error) <span class="cov8" title="1">{
        node := BranchNode{}
        for i, item := range list.Items[0:16] </span><span class="cov8" title="1">{
                hashed, embedded, err := decodeEmbeddedOrHashedNode(item)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">node.hashes[i] = hashed
                node.setEmbedded(byte(i), embedded)</span>
        }

        <span class="cov8" title="1">return &amp;node, nil</span>
}

// decodeEmbeddedOrHashedNode decodes an embedded or hashed node from RLP-encoded data.
// It checks for malformed data and returns an error if the data is not valid.
// Otherwise, it returns the decoded node hash and a flag indicating if the node is embedded.
func decodeEmbeddedOrHashedNode(payload rlp.Item) (node common.Hash, embedded bool, err error) <span class="cov8" title="1">{
        var hash common.Hash
        switch item := payload.(type) </span>{
        case rlp.String:<span class="cov8" title="1">
                if len(item.Str) &gt; common.HashSize </span><span class="cov8" title="1">{
                        return common.Hash{}, false, fmt.Errorf("node hash is too long: got: %v, wanted: &lt;= 32", len(item.Str))
                }</span>
                <span class="cov8" title="1">if len(item.Str) == 0 </span><span class="cov8" title="1">{
                        hash = EmptyNodeEthereumHash
                }</span> else<span class="cov8" title="1"> {
                        copy(hash[:], item.Str)
                }</span>
        case rlp.List:<span class="cov8" title="1"> // embedded node is a two item list of a value node.
                arr := make([]byte, 0, common.HashSize)
                if n := copy(hash[:], rlp.EncodeInto(arr, item)); n &gt; 0 &amp;&amp; n &lt; common.HashSize </span><span class="cov8" title="1">{
                        embedded = true
                }</span> else<span class="cov8" title="1"> {
                        return common.Hash{}, false, fmt.Errorf("embedded node is too long: got: %v, wanted: &lt; 32", n)
                }</span>
        }

        <span class="cov8" title="1">return hash, embedded, nil</span>
}

// isEncodedLeafNode checks if the path is a leaf node in the compact encoding.
// In the compact encoding, the first nibble of the path contains the oddness of the path,
// and if the node is leaf or not.
// The encoding is as follows:
// - 0b_0000_0000 (0x00): extension node, even path
// - 0b_0001_xxxx (0x1_): extension node, odd path
// - 0b_0010_0000 (0x20): leaf node, even path
// - 0b_0011_xxxx (0x3_): leaf node, odd path
// for more see:
// https://arxiv.org/pdf/2108.05513/1000 sec 4.1
func isEncodedLeafNode(path []byte) bool <span class="cov8" title="1">{
        return path[0]&amp;0b_0010_0000&gt;&gt;5 == 1
}</span>

// compactPathToNibbles converts a compact path to nibbles.
// The compact path packs two nibbles into a single byte.
// The higher nibble of first byte contains the oddness of the path and if the node is a leaf node.
// If the payload is odd, the lower nibble of the  first byte contains already payload.
// If the payload is even, the lower nibble of the first byte is padded with zero.
// The encoding is as follows:
// - 0b_0000_0000 (0x00): extension node, even path
// - 0b_0001_xxxx (0x1_): extension node, odd path
// - 0b_0010_0000 (0x20): leaf node, even path
// - 0b_0011_xxxx (0x3_): leaf node, odd path
// Examples:
//
//        [5,6,7,8,9] -&gt; [15,67,89] extension node, or [35,67,89] leaf node
//        [4,5,6,7,8,9] -&gt; [00,45,67,89] extension node, or [20,45,67,89] leaf node
//
// for more see:
// https://arxiv.org/pdf/2108.05513/1000 sec 4.1
func compactPathToNibbles(path []byte) []Nibble <span class="cov8" title="1">{
        odd := int(path[0] &amp; 0b_0001_0000 &gt;&gt; 4) // will become either 1 or 0

        res := make([]Nibble, 0, len(path)*2)
        for _, b := range path </span><span class="cov8" title="1">{
                res = append(res, Nibble(b&gt;&gt;4), Nibble(b&amp;0xF))
        }</span>

        <span class="cov8" title="1">return res[2-odd:]</span>
}

// decodedAccountNode is an extension of the  account node with the path.
// It is used for storing hashed path. which is part of the address
// potentially up to 32bytes long, i.e. exceeding plain 20bytes long address.
type decodedAccountNode struct {
        AccountNode
        suffix Path
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "fmt"
        "reflect"
        "sort"
        "strings"

        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/common/amount"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        "golang.org/x/exp/maps"
)

type Diff map[common.Address]*AccountDiff

type AccountDiff struct {
        Reset   bool
        Balance *amount.Amount
        Nonce   *common.Nonce
        Code    *common.Hash
        Storage map[common.Key]common.Value
}

func (d Diff) Equal(other Diff) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(d, other)
}</span>

func (d Diff) String() string <span class="cov8" title="1">{
        addresses := maps.Keys(d)
        sort.Slice(addresses, func(i, j int) bool </span><span class="cov8" title="1">{
                return string(addresses[i][:]) &lt; string(addresses[j][:])
        }</span>)

        <span class="cov8" title="1">builder := strings.Builder{}
        builder.WriteString("Diff {\n")
        for _, address := range addresses </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf("\t%x: \n", address[:]))
                diff := d[address]
                if diff.Reset </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("\t\tReset:   %t\n", diff.Reset))
                }</span>
                <span class="cov8" title="1">if diff.Balance != nil </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("\t\tBalance: %x\n", *diff.Balance))
                }</span>
                <span class="cov8" title="1">if diff.Nonce != nil </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("\t\tNonce:   %x\n", *diff.Nonce))
                }</span>
                <span class="cov8" title="1">if diff.Code != nil </span><span class="cov8" title="1">{
                        builder.WriteString(fmt.Sprintf("\t\tCode:    %x\n", *diff.Code))
                }</span>

                <span class="cov8" title="1">if len(diff.Storage) &gt; 0 </span><span class="cov8" title="1">{
                        keys := maps.Keys(diff.Storage)
                        sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                                return string(keys[i][:]) &lt; string(keys[j][:])
                        }</span>)
                        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                                value := diff.Storage[key]
                                builder.WriteString(fmt.Sprintf("\t\t\t%x: %x\n", key[:], value[:]))
                        }</span>
                }
        }
        <span class="cov8" title="1">builder.WriteString("}")
        return builder.String()</span>
}

func (d *AccountDiff) Empty() bool <span class="cov8" title="1">{
        return !d.Reset &amp;&amp; d.Balance == nil &amp;&amp; d.Nonce == nil &amp;&amp; d.Code == nil &amp;&amp; len(d.Storage) == 0
}</span>

func GetDiff(
        source NodeSource,
        before *NodeReference,
        after *NodeReference,
) (Diff, error) <span class="cov8" title="1">{
        context := &amp;diffContext{
                source: source,
                result: Diff{},
        }

        if before.Id() == after.Id() </span><span class="cov8" title="1">{
                return context.result, nil
        }</span>

        <span class="cov8" title="1">if err := collectDiff(context, triePosition{ref: *before}, triePosition{ref: *after}); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return context.result, nil</span>
}

// -----

type triePosition struct {
        ref    NodeReference
        depth  int // the distance from the root node
        offset int // number of Nibbles consumed of Extension Node paths
}

func (p *triePosition) id() NodeId <span class="cov8" title="1">{
        return p.ref.Id()
}</span>

func (p *triePosition) isLeaf() bool <span class="cov8" title="1">{
        id := p.id()
        return id.IsEmpty() || id.IsAccount() || id.IsValue()
}</span>

func (p *triePosition) getReadAccess(source NodeSource) (shared.ReadHandle[Node], error) <span class="cov8" title="1">{
        return source.getReadAccess(&amp;p.ref)
}</span>

func (p *triePosition) getChild(source NodeSource, nibble Nibble) (triePosition, error) <span class="cov8" title="1">{
        if p.id().IsEmpty() </span><span class="cov8" title="1">{
                return *p, nil
        }</span>

        <span class="cov8" title="1">handle, err := p.getReadAccess(source)
        if err != nil </span><span class="cov8" title="1">{
                return triePosition{}, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()

        if p.ref.Id().IsAccount() </span><span class="cov8" title="1">{
                path := AddressToNibblePath(handle.Get().(*AccountNode).address, source)
                if path[p.depth] == nibble </span><span class="cov8" title="1">{
                        return triePosition{ref: p.ref, depth: p.depth + 1}, nil
                }</span>
                <span class="cov8" title="1">return triePosition{ref: emptyNodeReference}, nil</span>
        }

        <span class="cov8" title="1">if p.ref.Id().IsValue() </span><span class="cov8" title="1">{
                path := KeyToNibblePath(handle.Get().(*ValueNode).key, source)
                if path[p.depth] == nibble </span><span class="cov8" title="1">{
                        return triePosition{ref: p.ref, depth: p.depth + 1}, nil
                }</span>
                <span class="cov8" title="1">return triePosition{ref: emptyNodeReference}, nil</span>
        }

        <span class="cov8" title="1">if p.ref.Id().IsBranch() </span><span class="cov8" title="1">{
                child := handle.Get().(*BranchNode).children[nibble]
                return triePosition{ref: child, depth: p.depth + 1}, nil
        }</span>

        <span class="cov8" title="1">extension := handle.Get().(*ExtensionNode)

        // If the requested child is deviating from the extension's path, return an empty position.
        if nibble != extension.path.Get(p.offset) </span><span class="cov8" title="1">{
                return triePosition{ref: emptyNodeReference}, nil
        }</span>

        // If the end of the path would be reached, return the next node.
        <span class="cov8" title="1">if p.offset+1 == extension.path.Length() </span><span class="cov8" title="1">{
                return triePosition{
                        ref:   extension.next,
                        depth: p.depth + 1,
                }, nil
        }</span>

        // Otherwise, return a position pointing to the same extension but with increased offset.
        <span class="cov8" title="1">return triePosition{
                ref:    p.ref,
                depth:  p.depth + 1,
                offset: p.offset + 1,
        }, nil</span>
}

// ------

type diffContext struct {
        source         NodeSource
        currentAccount *common.Address
        result         Diff
}

var emptyNodeReference = NewNodeReference(EmptyId())

func collectDiff(
        context *diffContext,
        before triePosition,
        after triePosition,
) error <span class="cov8" title="1">{
        if before.id() == after.id() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if before.isLeaf() &amp;&amp; after.isLeaf() </span><span class="cov8" title="1">{
                return collectDiffFromLeafs(context, before, after)
        }</span>

        <span class="cov8" title="1">for i := Nibble(0); i &lt; Nibble(16); i++ </span><span class="cov8" title="1">{
                lhs, err := before.getChild(context.source, i)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">rhs, err := after.getChild(context.source, i)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := collectDiff(context, lhs, rhs); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func collectDiffFromLeafs(context *diffContext, before triePosition, after triePosition) error <span class="cov8" title="1">{
        lhs := before.id()
        rhs := after.id()

        // Handle newly added accounts and values.
        if lhs.IsEmpty() </span><span class="cov8" title="1">{
                if rhs.IsAccount() </span><span class="cov8" title="1">{
                        // A new account is present in the after state.
                        handle, err := after.getReadAccess(context.source)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer handle.Release()
                        account := handle.Get().(*AccountNode)
                        return recordAddedAccount(context, account)</span>
                }
                <span class="cov8" title="1">if rhs.IsValue() </span><span class="cov8" title="1">{
                        // A new value is present in the after state.
                        handle, err := after.getReadAccess(context.source)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer handle.Release()
                        value := handle.Get().(*ValueNode)
                        recordValueUpdate(context, value.key, value.value)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        // Handle deleted values.
        <span class="cov8" title="1">if rhs.IsEmpty() </span><span class="cov8" title="1">{
                if lhs.IsAccount() </span><span class="cov8" title="1">{
                        // An account is removed in the after state.
                        handle, err := before.getReadAccess(context.source)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer handle.Release()
                        account := handle.Get().(*AccountNode)
                        context.result[account.address] = &amp;AccountDiff{Reset: true}</span>
                }
                <span class="cov8" title="1">if lhs.IsValue() </span><span class="cov8" title="1">{
                        // A value is removed in the after state.
                        handle, err := before.getReadAccess(context.source)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer handle.Release()
                        value := handle.Get().(*ValueNode)
                        recordValueUpdate(context, value.key, common.Value{})</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        // Handle modified accounts.
        <span class="cov8" title="1">if lhs.IsAccount() &amp;&amp; rhs.IsAccount() </span><span class="cov8" title="1">{
                beforeHandle, err := before.getReadAccess(context.source)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">defer beforeHandle.Release()
                afterHandle, err := after.getReadAccess(context.source)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">defer afterHandle.Release()

                beforeNode := beforeHandle.Get().(*AccountNode)
                afterNode := afterHandle.Get().(*AccountNode)

                if beforeNode.address != afterNode.address </span><span class="cov8" title="1">{
                        // The old account was deleted.
                        recordDeletedAccount(context, beforeNode)

                        // And a new account was created.
                        return recordAddedAccount(context, afterNode)
                }</span>

                <span class="cov8" title="1">diff := &amp;AccountDiff{}
                if beforeNode.info.Balance != afterNode.info.Balance </span><span class="cov8" title="1">{
                        diff.Balance = new(amount.Amount)
                        *diff.Balance = afterNode.info.Balance
                }</span>
                <span class="cov8" title="1">if beforeNode.info.Nonce != afterNode.info.Nonce </span><span class="cov8" title="1">{
                        diff.Nonce = new(common.Nonce)
                        *diff.Nonce = afterNode.info.Nonce
                }</span>
                <span class="cov8" title="1">if beforeNode.info.CodeHash != afterNode.info.CodeHash </span><span class="cov8" title="1">{
                        diff.Code = new(common.Hash)
                        *diff.Code = afterNode.info.CodeHash
                }</span>
                <span class="cov8" title="1">if !diff.Empty() </span><span class="cov8" title="1">{
                        context.result[afterNode.address] = diff
                }</span>

                // Also collect storage differences.
                <span class="cov8" title="1">if beforeNode.storage.Id() != afterNode.storage.Id() </span><span class="cov8" title="1">{
                        context.currentAccount = &amp;afterNode.address
                        return collectDiff(context, triePosition{ref: beforeNode.storage}, triePosition{ref: afterNode.storage})
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if lhs.IsValue() &amp;&amp; rhs.IsValue() </span><span class="cov8" title="1">{
                // Check whether the value got modified.
                beforeHandle, err := before.getReadAccess(context.source)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">defer beforeHandle.Release()
                afterHandle, err := after.getReadAccess(context.source)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">defer afterHandle.Release()

                beforeNode := beforeHandle.Get().(*ValueNode)
                afterNode := afterHandle.Get().(*ValueNode)

                if beforeNode.key == afterNode.key </span><span class="cov8" title="1">{
                        if beforeNode.value != afterNode.value </span><span class="cov8" title="1">{
                                recordValueUpdate(context, afterNode.key, afterNode.value)
                        }</span>
                } else<span class="cov8" title="1"> {
                        recordValueUpdate(context, beforeNode.key, common.Value{})
                        recordValueUpdate(context, afterNode.key, afterNode.value)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// --- Utilities ---

func recordAddedAccount(
        context *diffContext,
        account *AccountNode,
) error <span class="cov8" title="1">{
        // And a new account was created.
        diff := &amp;AccountDiff{}
        if !account.info.Balance.IsZero() </span><span class="cov8" title="1">{
                diff.Balance = new(amount.Amount)
                *diff.Balance = account.info.Balance
        }</span>
        <span class="cov8" title="1">if (account.info.Nonce != common.Nonce{}) </span><span class="cov8" title="1">{
                diff.Nonce = new(common.Nonce)
                *diff.Nonce = account.info.Nonce
        }</span>
        <span class="cov8" title="1">if (account.info.CodeHash != common.Hash{}) </span><span class="cov8" title="1">{
                diff.Code = new(common.Hash)
                *diff.Code = account.info.CodeHash
        }</span>
        <span class="cov8" title="1">if !diff.Empty() </span><span class="cov8" title="1">{
                context.result[account.address] = diff
        }</span>
        <span class="cov8" title="1">context.currentAccount = &amp;account.address
        return collectDiff(context, triePosition{ref: emptyNodeReference}, triePosition{ref: account.storage})</span>
}

func recordDeletedAccount(
        context *diffContext,
        account *AccountNode,
) <span class="cov8" title="1">{
        context.result[account.address] = &amp;AccountDiff{Reset: true}
}</span>

func recordValueUpdate(
        context *diffContext,
        key common.Key,
        value common.Value,
) <span class="cov8" title="1">{
        diff := context.result[*context.currentAccount]
        if diff == nil </span><span class="cov8" title="1">{
                diff = &amp;AccountDiff{}
                context.result[*context.currentAccount] = diff
        }</span>
        <span class="cov8" title="1">if diff.Storage == nil </span><span class="cov8" title="1">{
                diff.Storage = map[common.Key]common.Value{}
        }</span>
        <span class="cov8" title="1">diff.Storage[key] = value</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/Fantom-foundation/Carmen/go/common"
)

const lockFileName = "~lock"

// LockDirectory acquires a lock on the given directory. If needed,
// the directory is implicitly created. The operation fails if the
// lock can not be acquired due to some other thread or process holding
// the lock or due to an IO error.
//
// Note: if successful, the acquired lock needs to be explicitly released.
// The lock is not automatically released when the process is terminated.
func LockDirectory(directory string) (common.LockFile, error) <span class="cov8" title="1">{
        if err := os.MkdirAll(directory, 0700); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">lock, err := common.CreateLockFile(filepath.Join(directory, lockFileName))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unable to gain exclusive access to %s: %w", directory, err)
        }</span>
        <span class="cov8" title="1">return lock, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
)

const dirtyFileName = "~dirty"

// isDirty checks whether the given directory is marked as dirty. The mark
// is represented by the presence of a file in the respective directory.
// An error is returned if the directory does not exist, the provided
// path does not point to a directory, or another IO error occurred.
func isDirty(directory string) (bool, error) <span class="cov8" title="1">{
        // Check that the directory exists.
        info, err := os.Stat(directory)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return false, fmt.Errorf("%s is not a directory", directory)
        }</span>

        // Check for the dirty flag.
        <span class="cov8" title="1">_, err = os.Stat(filepath.Join(directory, dirtyFileName))
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, err</span>
}

// markDirty marks the given directory as dirty, and thus, potentially
// corrupted. MPT instances mark their directories as dirty as long as
// they are opened by a process and only clear the mark if the DB got
// successfully closed.
func markDirty(directory string) error <span class="cov8" title="1">{
        return os.WriteFile(filepath.Join(directory, dirtyFileName), []byte{}, 0600)
}</span>

// markClean marks the given directory as clean, and thus, expected
// to be consistent. MPT instances mark their directories as dirty as
// long as they are opened by a process and only clear the mark if the
// DB got successfully closed.
func markClean(directory string) error <span class="cov8" title="1">{
        return os.Remove(filepath.Join(directory, dirtyFileName))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "os"
        "sort"
        "sync"
        "sync/atomic"
        "time"
        "unsafe"

        "github.com/Fantom-foundation/Carmen/go/backend/stock"
        "github.com/Fantom-foundation/Carmen/go/backend/stock/file"
        "github.com/Fantom-foundation/Carmen/go/backend/stock/memory"
        "github.com/Fantom-foundation/Carmen/go/backend/stock/synced"
        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
)

type StorageMode bool

const (
        // Immutable is the mode of an archive or a read-only state on the disk.
        // All nodes written to disk will be finalized and never updated again.
        Immutable StorageMode = true
        // Mutable is the mode of a LiveDB in which the state on the disk can be
        // modified through destructive updates.
        Mutable StorageMode = false
        // forestClosedErr is an error returned when a forest is already closed.
        forestClosedErr = common.ConstError("forest already closed")
)

// printWarningDefaultNodeFreezing allows for printing a warning that a node is going to be frozen
// as a consequence of its flushing to the disk.
const printWarningDefaultNodeFreezing = false

func (m StorageMode) String() string <span class="cov8" title="1">{
        if m == Immutable </span><span class="cov8" title="1">{
                return "Immutable"
        }</span> else<span class="cov8" title="1"> {
                return "Mutable"
        }</span>
}

// Root is used to identify and verify root nodes of trees in forests.
type Root struct {
        NodeRef NodeReference
        Hash    common.Hash
}

// NodeCacheConfig summarizes the configuration options for the node cache
// managed by a forest instance.
type NodeCacheConfig struct {
        Capacity               int           // the (approximate) maximum number of nodes retained in memory; a default is chosen if zero or negative
        BackgroundFlushPeriod  time.Duration // the time between background flushes; a default is chosen if zero, disabled if negative
        writeBufferChannelSize int           // the maximum number of elements retained in the write buffer channel
}

// ForestConfig summarizes forest instance configuration options that affect
// the functional and non-functional properties of a forest but do not change
// the on-disk format.
type ForestConfig struct {
        Mode            StorageMode // whether to perform destructive or constructive updates
        NodeCacheConfig             // configuration options for the node cache
}

// Forest is a utility node managing nodes for one or more Tries.
// It provides the common foundation for the Live and Archive Tries.
//
// Forests are thread safe. Thus, read and write operations may be
// conducted concurrently.
type Forest struct {
        config MptConfig

        // The stock containers managing individual node types.
        branches   stock.Stock[uint64, BranchNode]
        extensions stock.Stock[uint64, ExtensionNode]
        accounts   stock.Stock[uint64, AccountNode]
        values     stock.Stock[uint64, ValueNode]

        // Indicates whether all values in the stock should be considered
        // frozen, and thus immutable as required for the archive case or
        // mutable, as for the live-db-only case.
        storageMode StorageMode

        // A unified cache for all node types.
        nodeCache NodeCache

        // A background worker flushing nodes to disk.
        flusher *nodeFlusher

        // The hasher managing node hashes for this forest.
        hasher hasher

        // Cached hashers for keys and addresses (thread safe).
        keyHasher     CachedHasher[common.Key]
        addressHasher CachedHasher[common.Address]

        // A buffer for asynchronously writing nodes to files.
        writeBuffer WriteBuffer

        // A mutex synchronizing the transfer of elements between the cache, the
        // write buffer, and stocks (=disks).
        nodeTransferMutex sync.Mutex

        // Utilities to manage a background worker releasing nodes.
        releaseQueue chan&lt;- NodeId   // send EmptyId to trigger sync signal
        releaseSync  &lt;-chan struct{} // signaled whenever the release worker reaches a sync point
        releaseError &lt;-chan error    // errors detected by the release worker
        releaseDone  &lt;-chan struct{} // closed when the release worker is done

        // A list of issues encountered while performing operations on the forest.
        // If this list is non-empty, no guarantees are provided on the correctness
        // of the maintained forest. Thus, it should be considered corrupted.
        errors []error

        // A flag indicating whether the forest is closed.
        closed atomic.Bool
}

func OpenInMemoryForest(directory string, mptConfig MptConfig, forestConfig ForestConfig) (*Forest, error) <span class="cov8" title="1">{
        if _, err := checkForestMetadata(directory, mptConfig, forestConfig.Mode); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">success := false
        var err error
        closers := make(closers, 0, 4)
        defer func() </span><span class="cov8" title="1">{
                // if opening the forest was not successful, close all opened stocks.
                if !success </span><span class="cov8" title="1">{
                        err = errors.Join(err, closers.CloseAll())
                }</span>
        }()

        <span class="cov8" title="1">accountEncoder, branchEncoder, extensionEncoder, valueEncoder := getEncoder(mptConfig)
        branches, err := memory.OpenStock[uint64, BranchNode](branchEncoder, directory+"/branches")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, branches)

        extensions, err := memory.OpenStock[uint64, ExtensionNode](extensionEncoder, directory+"/extensions")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, extensions)

        accounts, err := memory.OpenStock[uint64, AccountNode](accountEncoder, directory+"/accounts")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, accounts)

        values, err := memory.OpenStock[uint64, ValueNode](valueEncoder, directory+"/values")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, values)

        success = true
        return makeForest(mptConfig, branches, extensions, accounts, values, forestConfig)</span>
}

func OpenFileForest(directory string, mptConfig MptConfig, forestConfig ForestConfig) (*Forest, error) <span class="cov8" title="1">{
        if _, err := checkForestMetadata(directory, mptConfig, forestConfig.Mode); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">success := false
        var err error
        closers := make(closers, 0, 4)
        defer func() </span><span class="cov8" title="1">{
                // if opening the forest was not successful, close all opened stocks.
                if !success </span><span class="cov8" title="1">{
                        err = errors.Join(err, closers.CloseAll())
                }</span>
        }()

        <span class="cov8" title="1">accountEncoder, branchEncoder, extensionEncoder, valueEncoder := getEncoder(mptConfig)
        branches, err := file.OpenStock[uint64, BranchNode](branchEncoder, directory+"/branches")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, branches)

        extensions, err := file.OpenStock[uint64, ExtensionNode](extensionEncoder, directory+"/extensions")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, extensions)

        accounts, err := file.OpenStock[uint64, AccountNode](accountEncoder, directory+"/accounts")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, accounts)

        values, err := file.OpenStock[uint64, ValueNode](valueEncoder, directory+"/values")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">closers = append(closers, values)

        success = true
        return makeForest(mptConfig, branches, extensions, accounts, values, forestConfig)</span>
}

// closers is a shortcut for the list of io.Closer.
type closers []io.Closer

// CloseAll closes all the closers and returns an error if any errors occurred during the closing process.
func (c closers) CloseAll() error <span class="cov8" title="1">{
        var errs []error
        for _, closer := range c </span><span class="cov8" title="1">{
                errs = append(errs, closer.Close())
        }</span>
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func checkForestMetadata(directory string, config MptConfig, mode StorageMode) (ForestMetadata, error) <span class="cov8" title="1">{
        path := directory + "/forest.json"
        meta, present, err := ReadForestMetadata(path)
        if err != nil </span><span class="cov8" title="1">{
                return meta, err
        }</span>

        // Check present metadata to match expected configuration.
        <span class="cov8" title="1">if present </span><span class="cov8" title="1">{
                if want, got := config.Name, meta.Configuration; want != got </span><span class="cov8" title="1">{
                        return meta, fmt.Errorf("unexpected MPT configuration in directory, wanted %v, got %v", want, got)
                }</span>
                <span class="cov8" title="1">if want, got := StorageMode(mode == Mutable), StorageMode(meta.Mutable); want != got </span><span class="cov8" title="1">{
                        return meta, fmt.Errorf("unexpected MPT storage mode in directory, wanted %v, got %v", want, got)
                }</span>
                <span class="cov8" title="1">return meta, nil</span>
        }

        // Write metadata to disk to create new forest.
        <span class="cov8" title="1">meta = ForestMetadata{
                Configuration: config.Name,
                Mutable:       mode == Mutable,
        }

        // Update on-disk meta-data.
        metadata, err := json.Marshal(meta)
        return meta, errors.Join(err, os.WriteFile(path, metadata, 0600))</span>
}

func makeForest(
        mptConfig MptConfig,
        branches stock.Stock[uint64, BranchNode],
        extensions stock.Stock[uint64, ExtensionNode],
        accounts stock.Stock[uint64, AccountNode],
        values stock.Stock[uint64, ValueNode],
        forestConfig ForestConfig,
) (*Forest, error) <span class="cov8" title="1">{
        releaseQueue := make(chan NodeId, 1&lt;&lt;16) // NodeIds are small and a large buffer increases resilience.
        releaseSync := make(chan struct{})
        releaseError := make(chan error, 1)
        releaseDone := make(chan struct{})

        // The capacity of an MPT's node cache must be at least as large as the maximum
        // number of nodes modified in a block. Evaluations show that most blocks
        // modify less than 2000 nodes. However, one block, presumably the one handling
        // the opera fork at ~4.5M, modifies 434.589 nodes. Thus, the cache size of a
        // MPT processing Fantom's history should be at least ~500.000 nodes.
        const defaultCacheCapacity = 10_000_000
        if forestConfig.Capacity &lt;= 0 </span><span class="cov8" title="1">{
                forestConfig.Capacity = defaultCacheCapacity
        }</span>
        <span class="cov8" title="1">const minCacheCapacity = 2_000
        if forestConfig.Capacity &lt; minCacheCapacity </span><span class="cov8" title="1">{
                forestConfig.Capacity = minCacheCapacity
        }</span>

        <span class="cov8" title="1">res := &amp;Forest{
                config:        mptConfig,
                branches:      synced.Sync(branches),
                extensions:    synced.Sync(extensions),
                accounts:      synced.Sync(accounts),
                values:        synced.Sync(values),
                storageMode:   forestConfig.Mode,
                nodeCache:     NewNodeCache(forestConfig.Capacity),
                hasher:        mptConfig.Hashing.createHasher(),
                keyHasher:     NewKeyHasher(),
                addressHasher: NewAddressHasher(),
                releaseQueue:  releaseQueue,
                releaseSync:   releaseSync,
                releaseError:  releaseError,
                releaseDone:   releaseDone,
        }

        sink := writeBufferSink{res}

        // Start a background worker flushing dirty nodes to disk.
        res.flusher = startNodeFlusher(res.nodeCache, sink, nodeFlusherConfig{
                period: forestConfig.BackgroundFlushPeriod,
        })

        // Run a background worker releasing entire tries of nodes on demand.
        go func() </span><span class="cov8" title="1">{
                defer close(releaseDone)
                defer close(releaseError)
                defer close(releaseSync)
                for id := range releaseQueue </span><span class="cov8" title="1">{
                        if id.IsEmpty() </span><span class="cov8" title="1">{
                                releaseSync &lt;- struct{}{}
                        }</span> else<span class="cov8" title="1"> {
                                ref := NewNodeReference(id)
                                handle, err := res.getWriteAccess(&amp;ref)
                                if err != nil </span><span class="cov8" title="1">{
                                        releaseError &lt;- err
                                        return
                                }</span>
                                <span class="cov8" title="1">err = handle.Get().Release(res, &amp;ref, handle)
                                handle.Release()
                                if err != nil </span><span class="cov8" title="1">{
                                        releaseError &lt;- err
                                        return
                                }</span>
                        }
                }
        }()

        <span class="cov8" title="1">channelSize := forestConfig.writeBufferChannelSize
        if channelSize &lt;= 0 </span><span class="cov8" title="1">{
                channelSize = 1024 // the default value
        }</span>

        <span class="cov8" title="1">res.writeBuffer = makeWriteBuffer(sink, channelSize)
        return res, nil</span>
}

func (s *Forest) GetAccountInfo(rootRef *NodeReference, addr common.Address) (AccountInfo, bool, error) <span class="cov8" title="1">{
        handle, err := s.getReadAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain read access to node %v: %w", rootRef.Id(), err)
                s.errors = append(s.errors, err)
                return AccountInfo{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        path := AddressToNibblePath(addr, s)
        info, exists, err := handle.Get().GetAccount(s, addr, path[:])
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to fetch account information for account %v: %w", addr, err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return info, exists, err</span>
}

func (s *Forest) SetAccountInfo(rootRef *NodeReference, addr common.Address, info AccountInfo) (NodeReference, error) <span class="cov8" title="1">{
        root, err := s.getWriteAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain write access to node %v: %w", rootRef.Id(), err)
                s.errors = append(s.errors, err)
                return NodeReference{}, err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        path := AddressToNibblePath(addr, s)
        newRoot, _, err := root.Get().SetAccount(s, rootRef, root, addr, path[:], info)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to update account information for account %v: %w", addr, err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return newRoot, err</span>
}

func (s *Forest) GetValue(rootRef *NodeReference, addr common.Address, key common.Key) (common.Value, error) <span class="cov8" title="1">{
        root, err := s.getReadAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain read access to node %v: %w", rootRef.Id(), err)
                s.errors = append(s.errors, err)
                return common.Value{}, err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        path := AddressToNibblePath(addr, s)
        value, _, err := root.Get().GetSlot(s, addr, path[:], key)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to fetch value for %v/%v: %w", addr, key, err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return value, err</span>
}

func (s *Forest) SetValue(rootRef *NodeReference, addr common.Address, key common.Key, value common.Value) (NodeReference, error) <span class="cov8" title="1">{
        root, err := s.getWriteAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain write access to node %v: %w", rootRef.Id(), err)
                s.errors = append(s.errors, err)
                return NodeReference{}, err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        path := AddressToNibblePath(addr, s)
        newRoot, _, err := root.Get().SetSlot(s, rootRef, root, addr, path[:], key, value)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to update value for %v/%v: %w", addr, key, err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return newRoot, err</span>
}

func (s *Forest) HasEmptyStorage(rootRef *NodeReference, addr common.Address) (isEmpty bool, err error) <span class="cov8" title="1">{
        v := MakeVisitor(func(node Node, info NodeInfo) VisitResponse </span><span class="cov8" title="1">{
                if a, ok := node.(*AccountNode); ok </span><span class="cov8" title="1">{
                        isEmpty = a.storage.Id().IsEmpty()
                        return VisitResponseAbort
                }</span>
                <span class="cov8" title="1">return VisitResponseContinue</span>
        })
        <span class="cov8" title="1">exists, err := VisitPathToAccount(s, rootRef, addr, v)
        return isEmpty || !exists, err</span>
}

func (s *Forest) ClearStorage(rootRef *NodeReference, addr common.Address) (NodeReference, error) <span class="cov8" title="1">{
        root, err := s.getWriteAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain write access to node %v: %w", rootRef.Id(), err)
                s.errors = append(s.errors, err)
                return NodeReference{}, err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        path := AddressToNibblePath(addr, s)
        newRoot, _, err := root.Get().ClearStorage(s, rootRef, root, addr, path[:])
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to clear storage for %v: %w", addr, err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return newRoot, err</span>
}

func (s *Forest) VisitTrie(rootRef *NodeReference, visitor NodeVisitor) error <span class="cov8" title="1">{
        root, err := s.getViewAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain view access to node %v: %w", rootRef.Id(), err)
                s.errors = append(s.errors, err)
                return err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        _, err = root.Get().Visit(s, rootRef, 0, visitor)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("error during trie visit: %w", err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (s *Forest) updateHashesFor(ref *NodeReference) (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        hash, hints, err := s.hasher.updateHashes(ref, s)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("error during hash update: %w", err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return hash, hints, err</span>
}

func (s *Forest) setHashesFor(root *NodeReference, hashes *NodeHashes) error <span class="cov8" title="1">{
        for _, cur := range hashes.GetHashes() </span><span class="cov8" title="1">{
                write, err := s.getMutableNodeByPath(root, cur.Path)
                if err != nil </span><span class="cov8" title="1">{
                        err = fmt.Errorf("error during location of node at %v: %w", cur.Path, err)
                        s.errors = append(s.errors, err)
                        return err
                }</span>
                <span class="cov8" title="1">write.Get().SetHash(cur.Hash)
                write.Release()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Forest) getHashFor(ref *NodeReference) (common.Hash, error) <span class="cov8" title="1">{
        hash, err := s.hasher.getHash(ref, s)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("error while retrieving hash for node %v: %w", ref.Id(), err)
                s.errors = append(s.errors, err)
        }</span>
        <span class="cov8" title="1">return hash, err</span>
}

func (s *Forest) hashKey(key common.Key) common.Hash <span class="cov8" title="1">{
        hash, _ := s.keyHasher.Hash(key)
        return hash
}</span>

func (s *Forest) hashAddress(address common.Address) common.Hash <span class="cov8" title="1">{
        hash, _ := s.addressHasher.Hash(address)
        return hash
}</span>

func (f *Forest) Freeze(ref *NodeReference) error <span class="cov8" title="1">{
        if f.storageMode != Immutable </span><span class="cov0" title="0">{
                return fmt.Errorf("node-freezing only supported in archive mode")
        }</span>
        <span class="cov8" title="1">root, err := f.getWriteAccess(ref)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("failed to obtain write access to node %v: %w", ref.Id(), err)
                f.errors = append(f.errors, err)
                return err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        err = root.Get().Freeze(f, root)
        if err != nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("error while freezing trie rooted by %v: %w", ref.Id(), err)
                f.errors = append(f.errors, err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// CheckErrors returns an error that might have been
// encountered on this forest in the past.
// If the result is not empty, this
// Forest is to be considered corrupted and should be discarded.
func (s *Forest) CheckErrors() error <span class="cov8" title="1">{
        return errors.Join(s.errors...)
}</span>

func (s *Forest) Flush() error <span class="cov8" title="1">{
        // Wait for releaser to finish its current tasks.
        s.releaseQueue &lt;- EmptyId() // signals a sync request
        &lt;-s.releaseSync

        // Consume potential operation and release errors.
        errs := []error{
                s.CheckErrors(),
                s.collectReleaseWorkerErrors(),
        }

        // Get snapshot of set of dirty Node IDs.
        ids := make([]NodeId, 0, 1&lt;&lt;16)
        s.nodeCache.ForEach(func(id NodeId, node *shared.Shared[Node]) </span><span class="cov8" title="1">{
                handle := node.GetViewHandle()
                dirty := handle.Get().IsDirty()
                handle.Release()
                if dirty </span><span class="cov8" title="1">{
                        ids = append(ids, id)
                }</span>
        })

        <span class="cov8" title="1">errs = append(errs, s.flushDirtyIds(ids))

        return errors.Join(
                errors.Join(errs...),
                s.writeBuffer.Flush(),
                s.accounts.Flush(),
                s.branches.Flush(),
                s.extensions.Flush(),
                s.values.Flush(),
        )</span>
}

func (s *Forest) flushDirtyIds(ids []NodeId) error <span class="cov8" title="1">{
        var errs []error
        // Flush dirty keys in order (to avoid excessive seeking).
        sort.Slice(ids, func(i, j int) bool </span><span class="cov8" title="1">{ return ids[i] &lt; ids[j] }</span>)
        <span class="cov8" title="1">for _, id := range ids </span><span class="cov8" title="1">{
                ref := NewNodeReference(id)
                node, present := s.nodeCache.Get(&amp;ref)
                if present </span><span class="cov8" title="1">{
                        handle := node.GetWriteHandle()
                        node := handle.Get()
                        err := s.flushNode(id, node)
                        if err == nil </span><span class="cov8" title="1">{
                                node.MarkClean()
                        }</span> else<span class="cov8" title="1"> {
                                errs = append(errs, err)
                        }</span>
                        <span class="cov8" title="1">handle.Release()</span>
                } else<span class="cov8" title="1"> {
                        errs = append(errs, fmt.Errorf("missing dirty node %v in node cache", id))
                }</span>
        }

        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (s *Forest) Close() error <span class="cov8" title="1">{
        // Ensure that the forest is only closed once.
        if !s.closed.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return forestClosedErr
        }</span>

        <span class="cov8" title="1">errs := []error{s.flusher.Stop(), s.Flush()}

        // shut down release worker
        close(s.releaseQueue)
        &lt;-s.releaseDone

        // Consume potential release errors.
        errs = append(errs, s.collectReleaseWorkerErrors())

        return errors.Join(
                errors.Join(errs...),
                s.writeBuffer.Close(),
                s.accounts.Close(),
                s.branches.Close(),
                s.extensions.Close(),
                s.values.Close(),
        )</span>
}

func (s *Forest) collectReleaseWorkerErrors() error <span class="cov8" title="1">{
        var errs []error
loop:
        for </span><span class="cov8" title="1">{
                select </span>{
                case err, open := &lt;-s.releaseError:<span class="cov8" title="1">
                        if !open </span><span class="cov8" title="1">{
                                break loop</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                        }</span>
                default:<span class="cov8" title="1">
                        break loop</span>
                }
        }
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

// GetMemoryFootprint provides sizes of individual components of the state in the memory
func (s *Forest) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        mf := common.NewMemoryFootprint(unsafe.Sizeof(*s))
        mf.AddChild("accounts", s.accounts.GetMemoryFootprint())
        mf.AddChild("branches", s.branches.GetMemoryFootprint())
        mf.AddChild("extensions", s.extensions.GetMemoryFootprint())
        mf.AddChild("values", s.values.GetMemoryFootprint())
        mf.AddChild("cache", s.nodeCache.GetMemoryFootprint())
        mf.AddChild("hashedKeysCache", s.keyHasher.GetMemoryFootprint())
        mf.AddChild("hashedAddressesCache", s.addressHasher.GetMemoryFootprint())
        return mf
}</span>

// Dump prints the content of the Trie to the console. Mainly intended for debugging.
func (s *Forest) Dump(rootRef *NodeReference) <span class="cov8" title="1">{
        root, err := s.getViewAccess(rootRef)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Failed to fetch root: %v", err)
                return
        }</span>
        <span class="cov8" title="1">defer root.Release()
        root.Get().Dump(os.Stdout, s, rootRef, "")</span>
}

// Check verifies internal invariants of the Trie instance. If the trie is
// self-consistent, nil is returned and the Trie is ready to be accessed. If
// errors are detected, the Trie is to be considered in an invalid state and
// the behavior of all other operations is undefined.
func (s *Forest) Check(rootRef *NodeReference) error <span class="cov8" title="1">{
        return s.CheckAll([]*NodeReference{rootRef})
}</span>

// CheckAll verifies internal invariants of a set of Trie instances rooted by
// the given nodes. It is a generalization of the Check() function.
func (s *Forest) CheckAll(rootRefs []*NodeReference) error <span class="cov8" title="1">{
        return CheckForest(s, rootRefs)
}</span>

// -- NodeManager interface --

func (s *Forest) getConfig() MptConfig <span class="cov8" title="1">{
        return s.config
}</span>

func (s *Forest) getSharedNode(ref *NodeReference) (*shared.Shared[Node], error) <span class="cov8" title="1">{
        res, found := s.nodeCache.Get(ref)
        if found </span><span class="cov8" title="1">{
                return res, nil
        }</span>

        // Check whether the node is in the write buffer.
        // Note: although Cancel is thread safe, it is important to make sure
        // that this part is only run by a single thread to avoid one thread
        // recovering a node from the buffer and another fetching it from the
        // storage. This synchronization is currently ensured by acquiring the
        // nodeTransferMutex and holding it until the end of the function.
        // Using a global lock that does not differentiate between node IDs may
        // cause performance issues since it is delaying unrelated lookup
        // operations. However, the impact should be small since cache misses
        // should be infrequent enough. Unless it is detected in CPU profiles
        // and traces, this lock should be fine.
        <span class="cov8" title="1">s.nodeTransferMutex.Lock()
        defer s.nodeTransferMutex.Unlock()

        id := ref.Id()
        res, found = s.writeBuffer.Cancel(id)
        if found </span><span class="cov8" title="1">{
                masterCopy, _ := s.addToCacheHoldingTransferMutex(ref, res)
                if masterCopy != res </span><span class="cov8" title="1">{
                        panic("failed to reinstate element from write buffer")</span>
                }
                <span class="cov8" title="1">return res, nil</span>
        }

        // Load the node from persistent storage.
        <span class="cov8" title="1">var node Node
        var err error
        if id.IsValue() </span><span class="cov8" title="1">{
                value, e := s.values.Get(id.Index())
                node, err = &amp;value, e
        }</span> else<span class="cov8" title="1"> if id.IsAccount() </span><span class="cov8" title="1">{
                value, e := s.accounts.Get(id.Index())
                node, err = &amp;value, e
        }</span> else<span class="cov8" title="1"> if id.IsBranch() </span><span class="cov8" title="1">{
                value, e := s.branches.Get(id.Index())
                node, err = &amp;value, e
        }</span> else<span class="cov8" title="1"> if id.IsExtension() </span><span class="cov8" title="1">{
                value, e := s.extensions.Get(id.Index())
                node, err = &amp;value, e
        }</span> else<span class="cov8" title="1"> if id.IsEmpty() </span><span class="cov8" title="1">{
                node = EmptyNode{}
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Everything loaded from the stock is in sync and thus clean.
        <span class="cov8" title="1">node.MarkClean()

        // Everything that is loaded from an archive is to be considered
        // frozen, and thus immutable.
        if s.storageMode == Immutable </span><span class="cov8" title="1">{
                node.MarkFrozen()
        }</span>

        // if there has been a concurrent fetch, use the other value
        <span class="cov8" title="1">instance, _ := s.addToCacheHoldingTransferMutex(ref, shared.MakeShared[Node](node))
        return instance, nil</span>
}

func getAccess[H any](
        f *Forest,
        ref *NodeReference,
        getAccess func(*shared.Shared[Node]) H,
        release func(H),
        def H,
) (H, error) <span class="cov8" title="1">{
        instance, err := f.getSharedNode(ref)
        if err != nil </span><span class="cov8" title="1">{
                return def, err
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // Obtain needed access and make sure the instance access was obtained
                // for is still valid (by re-fetching the instance and check that it
                // has not changed). This is not super efficient, and may be improved
                // in the future by merging this functionality into called operations.
                res := getAccess(instance)
                if actual, err := f.getSharedNode(ref); err == nil &amp;&amp; actual == instance </span><span class="cov8" title="1">{
                        return res, nil
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        release(res)
                        return def, err
                }</span> else<span class="cov0" title="0"> {
                        release(res)
                        instance = actual
                }</span>
        }
}

func (s *Forest) getReadAccess(ref *NodeReference) (shared.ReadHandle[Node], error) <span class="cov8" title="1">{
        return getAccess(s, ref,
                func(s *shared.Shared[Node]) shared.ReadHandle[Node] </span><span class="cov8" title="1">{
                        return s.GetReadHandle()
                }</span>,
                func(p shared.ReadHandle[Node]) <span class="cov8" title="1">{
                        p.Release()
                }</span>,
                shared.ReadHandle[Node]{},
        )
}

func (s *Forest) getViewAccess(ref *NodeReference) (shared.ViewHandle[Node], error) <span class="cov8" title="1">{
        return getAccess(s, ref,
                func(s *shared.Shared[Node]) shared.ViewHandle[Node] </span><span class="cov8" title="1">{
                        return s.GetViewHandle()
                }</span>,
                func(p shared.ViewHandle[Node]) <span class="cov8" title="1">{
                        p.Release()
                }</span>,
                shared.ViewHandle[Node]{},
        )
}

func (s *Forest) getHashAccess(ref *NodeReference) (shared.HashHandle[Node], error) <span class="cov8" title="1">{
        return getAccess(s, ref,
                func(s *shared.Shared[Node]) shared.HashHandle[Node] </span><span class="cov8" title="1">{
                        return s.GetHashHandle()
                }</span>,
                func(p shared.HashHandle[Node]) <span class="cov8" title="1">{
                        p.Release()
                }</span>,
                shared.HashHandle[Node]{},
        )
}

func (f *Forest) getWriteAccess(ref *NodeReference) (shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        return getAccess(f, ref,
                func(s *shared.Shared[Node]) shared.WriteHandle[Node] </span><span class="cov8" title="1">{
                        // When gaining write access to nodes, they need to be touched to make sure
                        // modified nodes are at the head of the cache's LRU queue to be evicted last.
                        f.nodeCache.Touch(ref)
                        return s.GetWriteHandle()
                }</span>,
                func(p shared.WriteHandle[Node]) <span class="cov8" title="1">{
                        p.Release()
                }</span>,
                shared.WriteHandle[Node]{},
        )
}

func (s *Forest) getMutableNodeByPath(root *NodeReference, path NodePath) (shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        // Navigate down the trie using read access.
        next := root
        last := shared.ReadHandle[Node]{}
        lastValid := false
        for i := 0; i &lt; path.Length(); i++ </span><span class="cov8" title="1">{
                cur, err := s.getReadAccess(next)
                if lastValid </span><span class="cov8" title="1">{
                        last.Release()
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return shared.WriteHandle[Node]{}, err
                }</span>
                <span class="cov8" title="1">last = cur
                lastValid = true
                switch n := cur.Get().(type) </span>{
                case *BranchNode:<span class="cov8" title="1">
                        next = &amp;n.children[path.Get(byte(i))]</span>
                case *AccountNode:<span class="cov8" title="1">
                        next = &amp;n.storage</span>
                case *ExtensionNode:<span class="cov8" title="1">
                        next = &amp;n.next</span>
                default:<span class="cov8" title="1">
                        if lastValid </span><span class="cov8" title="1">{
                                last.Release()
                        }</span>
                        <span class="cov8" title="1">return shared.WriteHandle[Node]{}, fmt.Errorf("no node for path: %v", path)</span>
                }
        }

        // The last step requires write access.
        <span class="cov8" title="1">res, err := s.getWriteAccess(next)
        if lastValid </span><span class="cov8" title="1">{
                last.Release()
        }</span>
        <span class="cov8" title="1">return res, err</span>
}

func (s *Forest) addToCache(ref *NodeReference, node *shared.Shared[Node]) (value *shared.Shared[Node], present bool) <span class="cov8" title="1">{
        s.nodeTransferMutex.Lock()
        defer s.nodeTransferMutex.Unlock()
        return s.addToCacheHoldingTransferMutex(ref, node)
}</span>

func (s *Forest) addToCacheHoldingTransferMutex(ref *NodeReference, node *shared.Shared[Node]) (value *shared.Shared[Node], present bool) <span class="cov8" title="1">{

        // Check whether the node is currently in the write buffer and needs
        // to be recovered. Failing to check this can lead to the presence
        // of multiple node instances associated with the same node ID.
        recoveredFromBuffer := false
        if recovered, found := s.writeBuffer.Cancel(ref.Id()); found </span><span class="cov8" title="1">{
                node = recovered
                recoveredFromBuffer = true
        }</span>

        // Replacing the element in the already thread safe node cache needs to be
        // guarded by the `getTransferMutex` since an evicted node has to
        // be moved to the write buffer in an atomic step.
        <span class="cov8" title="1">current, present, evictedId, evictedNode, evicted := s.nodeCache.GetOrSet(ref, node)
        if present </span><span class="cov8" title="1">{
                // If a present element is re-used, it needs to be touched to be at the
                // head of the cache's LRU queue -- just like a newly inserted node
                // would be. Methods like createBranch depend on this to be covered here.
                s.nodeCache.Touch(ref)
        }</span>
        <span class="cov8" title="1">if !evicted </span><span class="cov8" title="1">{
                return current, present || recoveredFromBuffer
        }</span>

        // Clean nodes can be ignored, dirty nodes need to be written.
        <span class="cov8" title="1">if handle, ok := evictedNode.TryGetViewHandle(); ok </span><span class="cov8" title="1">{
                dirty := handle.Get().IsDirty()
                handle.Release()
                if !dirty </span><span class="cov8" title="1">{
                        return current, present || recoveredFromBuffer
                }</span>
        }

        // Enqueue evicted node for asynchronous write to file.
        <span class="cov8" title="1">s.writeBuffer.Add(evictedId, evictedNode)
        return current, present || recoveredFromBuffer</span>
}

func (s *Forest) flushNode(id NodeId, node Node) error <span class="cov8" title="1">{
        // Note: flushing nodes in Archive mode will implicitly freeze them,
        // since after the reload they will be considered frozen. This may
        // cause temporary states between updates to be accidentally frozen,
        // leaving unreferenced nodes in the archive, but it is not causing
        // correctness issues. However, if the node-cache size is sufficiently
        // large, such cases should be rare. Nevertheless, a warning is
        // printed here to get informed if this changes in the future.
        if printWarningDefaultNodeFreezing &amp;&amp; s.storageMode == Immutable &amp;&amp; !node.IsFrozen() </span><span class="cov0" title="0">{
                log.Printf("WARNING: non-frozen node flushed to disk causing implicit freeze")
        }</span>

        <span class="cov8" title="1">if id.IsValue() </span><span class="cov8" title="1">{
                return s.values.Set(id.Index(), *node.(*ValueNode))
        }</span> else<span class="cov8" title="1"> if id.IsAccount() </span><span class="cov8" title="1">{
                return s.accounts.Set(id.Index(), *node.(*AccountNode))
        }</span> else<span class="cov8" title="1"> if id.IsBranch() </span><span class="cov8" title="1">{
                return s.branches.Set(id.Index(), *node.(*BranchNode))
        }</span> else<span class="cov8" title="1"> if id.IsExtension() </span><span class="cov8" title="1">{
                return s.extensions.Set(id.Index(), *node.(*ExtensionNode))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *Forest) createAccount() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        i, err := s.accounts.New()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, shared.WriteHandle[Node]{}, err
        }</span>
        <span class="cov8" title="1">ref := NewNodeReference(AccountId(i))
        node := new(AccountNode)
        instance, present := s.addToCache(&amp;ref, shared.MakeShared[Node](node))
        if present </span><span class="cov0" title="0">{
                write := instance.GetWriteHandle()
                *write.Get().(*AccountNode) = *node
                write.Release()
        }</span>
        <span class="cov8" title="1">return ref, instance.GetWriteHandle(), err</span>
}

func (s *Forest) createBranch() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        i, err := s.branches.New()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, shared.WriteHandle[Node]{}, err
        }</span>
        <span class="cov8" title="1">ref := NewNodeReference(BranchId(i))
        node := new(BranchNode)
        instance, present := s.addToCache(&amp;ref, shared.MakeShared[Node](node))
        if present </span><span class="cov8" title="1">{
                write := instance.GetWriteHandle()
                *write.Get().(*BranchNode) = *node
                write.Release()
        }</span>
        <span class="cov8" title="1">return ref, instance.GetWriteHandle(), err</span>
}

func (s *Forest) createExtension() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        i, err := s.extensions.New()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, shared.WriteHandle[Node]{}, err
        }</span>
        <span class="cov8" title="1">ref := NewNodeReference(ExtensionId(i))
        node := new(ExtensionNode)
        instance, present := s.addToCache(&amp;ref, shared.MakeShared[Node](node))
        if present </span><span class="cov8" title="1">{
                write := instance.GetWriteHandle()
                *write.Get().(*ExtensionNode) = *node
                write.Release()
        }</span>
        <span class="cov8" title="1">return ref, instance.GetWriteHandle(), err</span>
}

func (s *Forest) createValue() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        i, err := s.values.New()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, shared.WriteHandle[Node]{}, err
        }</span>
        <span class="cov8" title="1">ref := NewNodeReference(ValueId(i))
        node := new(ValueNode)
        instance, present := s.addToCache(&amp;ref, shared.MakeShared[Node](node))
        if present </span><span class="cov0" title="0">{
                write := instance.GetWriteHandle()
                *write.Get().(*ValueNode) = *node
                write.Release()
        }</span>
        <span class="cov8" title="1">return ref, instance.GetWriteHandle(), err</span>
}

func (s *Forest) release(ref *NodeReference) error <span class="cov8" title="1">{
        // Released nodes will not be needed,
        // so they are moved in the cache to the least priority.
        // This way they do not occupy space for other nodes
        // written/read in parallel.
        // Furthermore, it prevents cache exhaustion when
        // deleting many nodes in parallel.
        // It fixes: https://github.com/Fantom-foundation/Carmen/issues/691
        // If this line is removed, this test fails:
        //  go test ./database/mpt/...  -run TestForest_AsyncDelete_CacheIsNotExhausted
        s.nodeCache.Release(ref)

        id := ref.Id()
        if id.IsAccount() </span><span class="cov8" title="1">{
                return s.accounts.Delete(id.Index())
        }</span>
        <span class="cov8" title="1">if id.IsBranch() </span><span class="cov8" title="1">{
                return s.branches.Delete(id.Index())
        }</span>
        <span class="cov8" title="1">if id.IsExtension() </span><span class="cov8" title="1">{
                return s.extensions.Delete(id.Index())
        }</span>
        <span class="cov8" title="1">if id.IsValue() </span><span class="cov8" title="1">{
                return s.values.Delete(id.Index())
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("unable to release node %v", id)</span>
}

func (s *Forest) releaseTrieAsynchronous(ref NodeReference) <span class="cov8" title="1">{
        id := ref.Id()
        if !id.IsEmpty() </span><span class="cov8" title="1">{ // empty Id is used for signalling sync requests
                s.releaseQueue &lt;- id
        }</span>
}

func getEncoder(config MptConfig) (
        stock.ValueEncoder[AccountNode],
        stock.ValueEncoder[BranchNode],
        stock.ValueEncoder[ExtensionNode],
        stock.ValueEncoder[ValueNode],
) <span class="cov8" title="1">{
        switch config.HashStorageLocation </span>{
        case HashStoredWithParent:<span class="cov8" title="1">
                if config.TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                        return AccountNodeWithPathLengthEncoderWithChildHash{},
                                BranchNodeEncoderWithChildHashes{},
                                ExtensionNodeEncoderWithChildHash{},
                                ValueNodeWithPathLengthEncoderWithoutNodeHash{}
                }</span>
                <span class="cov8" title="1">return AccountNodeEncoderWithChildHash{},
                        BranchNodeEncoderWithChildHashes{},
                        ExtensionNodeEncoderWithChildHash{},
                        ValueNodeEncoderWithoutNodeHash{}</span>
        case HashStoredWithNode:<span class="cov8" title="1">
                if config.TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                        return AccountNodeWithPathLengthEncoderWithNodeHash{},
                                BranchNodeEncoderWithNodeHash{},
                                ExtensionNodeEncoderWithNodeHash{},
                                ValueNodeWithPathLengthEncoderWithNodeHash{}
                }</span>
                <span class="cov8" title="1">return AccountNodeEncoderWithNodeHash{},
                        BranchNodeEncoderWithNodeHash{},
                        ExtensionNodeEncoderWithNodeHash{},
                        ValueNodeEncoderWithNodeHash{}</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unknown mode: %v", config.HashStorageLocation))</span>
        }
}

type writeBufferSink struct {
        forest *Forest
}

func (s writeBufferSink) Write(id NodeId, handle shared.ViewHandle[Node]) error <span class="cov8" title="1">{
        return s.forest.flushNode(id, handle.Get())
}</span>

// -- Forest metadata --

// ForestMetadata is the helper type to read and write metadata from/to the disk.
type ForestMetadata struct {
        Configuration string
        Mutable       bool
}

// ReadForestMetadata parses the content of the given file if it exists or returns
// a default-initialized metadata struct if there is no such file.
func ReadForestMetadata(filename string) (ForestMetadata, bool, error) <span class="cov8" title="1">{

        // If there is no file, initialize and return default metadata.
        if _, err := os.Stat(filename); err != nil </span><span class="cov8" title="1">{
                return ForestMetadata{}, false, nil
        }</span>

        // If the file exists, parse it and return its content.
        <span class="cov8" title="1">data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return ForestMetadata{}, false, err
        }</span>

        <span class="cov8" title="1">var meta ForestMetadata
        if err := json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov8" title="1">{
                return meta, false, err
        }</span>
        <span class="cov8" title="1">return meta, true, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "fmt"
        "sync"
        "sync/atomic"
        "unsafe"

        "github.com/Fantom-foundation/Carmen/go/common"
)

type CachedHasher[T any] interface {
        Hash(T) (common.Hash, bool)
        common.MemoryFootprintProvider
}

func NewAddressHasher() CachedHasher[common.Address] <span class="cov8" title="1">{
        return newGenericHasher[common.Address](
                func(addr common.Address) int </span><span class="cov8" title="1">{ return int(addr[0]) | (int(addr[1]) &lt;&lt; 8) | (int(addr[2]) &lt;&lt; 16) }</span>,
                func(addr common.Address) common.Hash <span class="cov8" title="1">{ return common.Keccak256ForAddress(addr) }</span>,
        )
}

func NewKeyHasher() CachedHasher[common.Key] <span class="cov8" title="1">{
        return newGenericHasher[common.Key](
                func(key common.Key) int </span><span class="cov8" title="1">{
                        // Here the last 3 bytes are used since some keys are low-range big-endian values.
                        return int(key[31]) | (int(key[30]) &lt;&lt; 8) | (int(key[29]) &lt;&lt; 16)
                }</span>,
                func(key common.Key) common.Hash <span class="cov8" title="1">{ return common.Keccak256ForKey(key) }</span>,
        )
}

const hashCacheSize = 1 &lt;&lt; 17 // ~128K entries

type genericHasher[T comparable] struct {
        entries    []cachedHasherEntry[T]
        simpleHash func(T) int
        cryptoHash func(T) common.Hash
}

// newGenericHasher creates a generic hash cache for a fixed type using the
// given simpleHash function for managing cached instances and the provided
// cryptoHash function for computing hashes of missing entries.
func newGenericHasher[T comparable](
        simpleHash func(T) int,
        cryptoHash func(T) common.Hash,
) CachedHasher[T] <span class="cov8" title="1">{
        return &amp;genericHasher[T]{
                entries:    make([]cachedHasherEntry[T], hashCacheSize),
                simpleHash: simpleHash,
                cryptoHash: cryptoHash,
        }
}</span>

func (h *genericHasher[T]) Hash(key T) (common.Hash, bool) <span class="cov8" title="1">{
        pos := h.simpleHash(key)
        entry := &amp;h.entries[pos%hashCacheSize]
        entry.mutex.Lock()
        if entry.key == key &amp;&amp; entry.used </span><span class="cov8" title="1">{
                res := entry.hash
                entry.mutex.Unlock()
                return res, true
        }</span>
        <span class="cov8" title="1">entry.used = true
        entry.key = key
        entry.hash = h.cryptoHash(key)
        res := entry.hash
        entry.mutex.Unlock()
        return res, false</span>
}

func (h *genericHasher[T]) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        selfSize := unsafe.Sizeof(*h)
        entrySize := unsafe.Sizeof(cachedHasherEntry[T]{})
        mf := common.NewMemoryFootprint(selfSize + uintptr(len(h.entries))*(entrySize))
        return mf
}</span>

type cachedHasherEntry[K comparable] struct {
        key   K
        hash  common.Hash
        mutex sync.Mutex
        used  bool // TODO [perf]: eliminate the used field by initializing the cache
}

type HitMissTrackingCachedHasher[T any] struct {
        cache  CachedHasher[T]
        hits   atomic.Uint64
        misses atomic.Uint64
}

// NewHitMissTrackingCache wraps the given cache into a version tracking hits and misses.
func NewHitMissTrackingCache[T any](cache CachedHasher[T]) *HitMissTrackingCachedHasher[T] <span class="cov8" title="1">{
        return &amp;HitMissTrackingCachedHasher[T]{cache: cache}
}</span>

func (h *HitMissTrackingCachedHasher[T]) Hash(value T) (common.Hash, bool) <span class="cov8" title="1">{
        res, hit := h.cache.Hash(value)
        if hit </span><span class="cov8" title="1">{
                h.hits.Add(1)
        }</span> else<span class="cov8" title="1"> {
                h.misses.Add(1)
        }</span>
        <span class="cov8" title="1">return res, hit</span>
}

func (h *HitMissTrackingCachedHasher[T]) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        mf := common.NewMemoryFootprint(unsafe.Sizeof(*h))
        mf.AddChild("cache", h.cache.GetMemoryFootprint())
        hits := h.hits.Load()
        misses := h.misses.Load()
        mf.SetNote(fmt.Sprintf("(hash-cache, hits %d, misses %d, hit ratio %f)", hits, misses, float64(hits)/float64(hits+misses)))
        return mf
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

//go:generate mockgen -source hasher.go -destination hasher_mocks.go -package mpt

import (
        "crypto/sha256"
        "fmt"
        "reflect"
        "sync"

        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/rlp"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
)

// ----------------------------------------------------------------------------
//                             Public Interfaces
// ----------------------------------------------------------------------------

// hashAlgorithm is the type of a configuration toke selecting the algorithm to
// be used for hashing nodes in an MPT. Its main application is to serve as a
// configuration parameter in the MPT Config.
type hashAlgorithm struct {
        Name         string
        createHasher func() hasher
}

// DirectHashing is a simple, fast hashing algorithm which is taking a simple
// serialization of node content or the hashes of referenced nodes to compute
// the hash of individual nodes.
var DirectHashing = hashAlgorithm{
        Name:         "DirectHashing",
        createHasher: makeDirectHasher,
}

// EthereumLikeHashing is an implementation following the specification of the
// State and Storage Trie hashing as defined in Ethereum's yellow paper.
var EthereumLikeHashing = hashAlgorithm{
        Name:         "EthereumLikeHashing",
        createHasher: makeEthereumLikeHasher,
}

// hasher is an entity retaining hashing information for individual nodes,
// computing them as required.
type hasher interface {
        // updateHash refreshes the hash of the given node and all nested nodes.
        updateHashes(root *NodeReference, nodes NodeManager) (common.Hash, *NodeHashes, error)

        // getHash computes the hash of the node without modifying it. It is used
        // for debugging, when checking a trie without the intend of modifying it.
        getHash(*NodeReference, NodeSource) (common.Hash, error)

        // isEmbedded determines whether the given node is embedded in the parent
        // or represented by its hash.
        isEmbedded(Node, NodeSource) (bool, error)
}

// ----------------------------------------------------------------------------
//                             Direct Hasher
// ----------------------------------------------------------------------------

// makeDirectHasher creates a hasher using a simple, direct node-value hashing
// algorithm that combines the content of individual nodes with the hashes of
// referenced child nodes into a hash for individual nodes.
func makeDirectHasher() hasher <span class="cov8" title="1">{
        return directHasher{}
}</span>

type directHasher struct{}

// updateHashes implements the DirectHasher's hashing algorithm to refresh
// the hashes stored within all nodes reachable from the given node.
func (h directHasher) updateHashes(ref *NodeReference, source NodeManager) (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        hashCollector := &amp;nodeHashCollector{hashes: NewNodeHashes()}
        hash, err := h.updateHashesInternal(ref, source, EmptyPath(), hashCollector)
        return hash, hashCollector.GetHashes(), err
}</span>

func (h directHasher) updateHashesInternal(
        ref *NodeReference,
        manager NodeManager,
        path NodePath,
        hashCollector *nodeHashCollector,
) (common.Hash, error) <span class="cov8" title="1">{
        hash := common.Hash{}
        if ref.Id().IsEmpty() </span><span class="cov8" title="1">{
                return hash, nil
        }</span>

        // Get write access to the node (hashes may be updated).
        <span class="cov8" title="1">handle, err := manager.getHashAccess(ref)
        if err != nil </span><span class="cov8" title="1">{
                return hash, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()

        // If the hash in the node is up-to-date we can skip re-hashing.
        hash, dirty := handle.Get().GetHash()
        if !dirty </span><span class="cov8" title="1">{
                return hash, nil
        }</span>

        <span class="cov8" title="1">hash, err = h.hash(ref, handle.Get(), handle, manager, path, hashCollector)
        if err != nil </span><span class="cov0" title="0">{
                return hash, err
        }</span>
        <span class="cov8" title="1">handle.Get().SetHash(hash)
        return hash, nil</span>
}

// getHash implements the DirectHasher's hashing algorithm.
func (h directHasher) getHash(ref *NodeReference, source NodeSource) (common.Hash, error) <span class="cov8" title="1">{
        hash := common.Hash{}
        if ref.Id().IsEmpty() </span><span class="cov8" title="1">{
                return hash, nil
        }</span>

        // Get read access to the node (no update is conducted).
        <span class="cov8" title="1">handle, err := source.getViewAccess(ref)
        if err != nil </span><span class="cov8" title="1">{
                return hash, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        return h.hash(ref, handle.Get(), shared.HashHandle[Node]{}, nil, EmptyPath(), nil)</span>
}

// hash is the internal implementation of the direct hasher to compute the hash
// of a given node or to recursively refresh the hashes. If manager is nil, only
// the hash for the given node is computed, without modifying it, otherwise the
// hash of all recursively reachable nodes is refreshed.
func (h directHasher) hash(
        ref *NodeReference,
        node Node,
        handle shared.HashHandle[Node],
        manager NodeManager,
        path NodePath,
        hashCollector *nodeHashCollector,
) (common.Hash, error) <span class="cov8" title="1">{
        hash := common.Hash{}

        // Compute a simple hash for the node.
        hasher := sha256.New()
        switch node := node.(type) </span>{
        case *AccountNode:<span class="cov8" title="1">

                // Refresh storage hash if needed.
                if manager != nil &amp;&amp; node.storageHashDirty </span><span class="cov8" title="1">{
                        hash, err := h.updateHashesInternal(&amp;node.storage, manager, path.Next(), hashCollector)
                        if err != nil </span><span class="cov0" title="0">{
                                return hash, err
                        }</span>
                        <span class="cov8" title="1">node.storageHash = hash
                        node.storageHashDirty = false</span>
                }

                <span class="cov8" title="1">hasher.Write([]byte{'A'})
                hasher.Write(node.address[:])
                b := node.info.Balance.Bytes32()
                hasher.Write(b[:])
                hasher.Write(node.info.Nonce[:])
                hasher.Write(node.info.CodeHash[:])
                hasher.Write(node.storageHash[:])</span>

        case *BranchNode:<span class="cov8" title="1">
                // TODO [perf]: compute sub-tree hashes in parallel
                if manager != nil </span><span class="cov8" title="1">{
                        for i, child := range node.children </span><span class="cov8" title="1">{
                                if !child.Id().IsEmpty() &amp;&amp; node.isChildHashDirty(byte(i)) </span><span class="cov8" title="1">{
                                        hash, err := h.updateHashesInternal(&amp;child, manager, path.Child(Nibble(i)), hashCollector)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return hash, err
                                        }</span>
                                        <span class="cov8" title="1">node.hashes[byte(i)] = hash</span>
                                }
                        }
                        <span class="cov8" title="1">node.clearChildHashDirtyFlags()</span>
                }

                <span class="cov8" title="1">hasher.Write([]byte{'B'})
                for i, child := range node.children </span><span class="cov8" title="1">{
                        if child.Id().IsEmpty() </span><span class="cov8" title="1">{
                                hasher.Write([]byte{'E'})
                        }</span> else<span class="cov8" title="1"> {
                                hasher.Write(node.hashes[byte(i)][:])
                        }</span>
                }

        case *ExtensionNode:<span class="cov8" title="1">

                if manager != nil &amp;&amp; node.nextHashDirty </span><span class="cov8" title="1">{
                        hash, err := h.updateHashesInternal(&amp;node.next, manager, path.Next(), hashCollector)
                        if err != nil </span><span class="cov0" title="0">{
                                return hash, err
                        }</span>
                        <span class="cov8" title="1">node.nextHash = hash
                        node.nextHashDirty = false</span>
                }

                <span class="cov8" title="1">hasher.Write([]byte{'E'})
                hasher.Write(node.path.path[:])
                hasher.Write(node.nextHash[:])</span>

        case *ValueNode:<span class="cov8" title="1">
                hasher.Write([]byte{'V'})
                hasher.Write(node.key[:])
                hasher.Write(node.value[:])</span>

        case EmptyNode:<span class="cov0" title="0">
                return common.Hash{}, nil</span>

        default:<span class="cov0" title="0">
                return hash, fmt.Errorf("unsupported node type: %v", reflect.TypeOf(node))</span>
        }
        <span class="cov8" title="1">hasher.Sum(hash[0:0])
        if hashCollector != nil </span><span class="cov8" title="1">{
                hashCollector.Add(path, hash)
        }</span>
        <span class="cov8" title="1">return hash, nil</span>
}

func (h directHasher) isEmbedded(Node, NodeSource) (bool, error) <span class="cov8" title="1">{
        return false, nil // nothing is embedded
}</span>

// ----------------------------------------------------------------------------
//                          Ethereum Like Hasher
// ----------------------------------------------------------------------------

// makeEthereumLikeHasher creates a hasher producing hashes according to
// Ethereum's State and Storage Trie specification.
// See Appendix D of https://ethereum.github.io/yellowpaper/paper.pdf
func makeEthereumLikeHasher() hasher <span class="cov8" title="1">{
        return &amp;ethHasher{}
}</span>

type ethHasher struct{}

var EmptyNodeEthereumHash = common.Keccak256(rlp.Encode(rlp.String{}))

func (h ethHasher) updateHashes(
        ref *NodeReference,
        manager NodeManager,
) (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        hashCollector := &amp;nodeHashCollector{hashes: NewNodeHashes()}
        hash, err := h.updateHashesInternal(ref, manager, hashCollector)
        return hash, hashCollector.GetHashes(), err
}</span>

func (h ethHasher) updateHashesInternal(
        ref *NodeReference,
        manager NodeManager,
        hashCollector *nodeHashCollector,
) (common.Hash, error) <span class="cov8" title="1">{
        if ref.Id().IsEmpty() </span><span class="cov8" title="1">{
                return EmptyNodeEthereumHash, nil
        }</span>

        <span class="cov8" title="1">type task struct {
                node   *NodeReference
                handle shared.HashHandle[Node]
                step   int
                path   NodePath
        }

        storesHashesInNodes := manager.getConfig().HashStorageLocation == HashStoredWithNode

        embedded := map[NodeId]bool{}

        tasks := make([]task, 0, 128)

        var err error
        var hash common.Hash
        data := make([]byte, 0, 1024)
        tasks = append(tasks, task{node: ref, path: EmptyPath()})
        for len(tasks) &gt; 0 </span><span class="cov8" title="1">{
                cur := tasks[len(tasks)-1]
                tasks = tasks[0 : len(tasks)-1]

                if cur.step == 0 </span><span class="cov8" title="1">{
                        // Get write access to the node (hashes may be updated).
                        handle, e := manager.getHashAccess(cur.node)
                        if e != nil </span><span class="cov0" title="0">{
                                err = e
                                break</span>
                        }
                        <span class="cov8" title="1">node := handle.Get()

                        // If the hash in the node is up-to-date we can skip re-hashing.
                        dirty := false
                        hash, dirty = node.GetHash()
                        if !dirty </span><span class="cov8" title="1">{

                                if storesHashesInNodes </span><span class="cov8" title="1">{
                                        // If the hashes are stored in nodes, not with the parents, embedded
                                        // flags in parent nodes may not be valid even for child nodes with
                                        // up-to-date hashes. Thus, whether the nodes is embedded or not
                                        // needs to be computed for all child nodes.
                                        if res, e := h.isEmbedded(handle.Get(), manager); err != nil </span><span class="cov0" title="0">{
                                                cur.handle.Release()
                                                err = e
                                                break</span>
                                        } else<span class="cov8" title="1"> if res </span><span class="cov8" title="1">{
                                                embedded[cur.node.Id()] = true
                                        }</span>
                                }

                                <span class="cov8" title="1">handle.Release()
                                continue</span>
                        }

                        // The node's hash needs to be refreshed. To do so, schedule
                        // the re-hashing of all children with dirty hashes followed
                        // by a second pass of this node. Note: the task list is a
                        // last-in-first-out stack.
                        <span class="cov8" title="1">tasks = append(tasks, task{cur.node, handle, 1, cur.path})

                        switch node := node.(type) </span>{
                        case *BranchNode:<span class="cov8" title="1">
                                for i := 0; i &lt; len(node.children); i++ </span><span class="cov8" title="1">{
                                        if !node.children[i].Id().IsEmpty() &amp;&amp; node.isChildHashDirty(byte(i)) </span><span class="cov8" title="1">{
                                                tasks = append(tasks, task{node: &amp;node.children[i], path: cur.path.Child(Nibble(i))})
                                        }</span>
                                }
                        case *ExtensionNode:<span class="cov8" title="1">
                                if node.nextHashDirty </span><span class="cov8" title="1">{
                                        tasks = append(tasks, task{node: &amp;node.next, path: cur.path.Next()})
                                }</span>
                        case *AccountNode:<span class="cov8" title="1">
                                if node.storageHashDirty </span><span class="cov8" title="1">{
                                        if node.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                                                node.storageHash = EmptyNodeEthereumHash
                                                node.storageHashDirty = false
                                        }</span> else<span class="cov8" title="1"> {
                                                tasks = append(tasks, task{node: &amp;node.storage, path: cur.path.Next()})
                                        }</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        // At this point the hashes of all children are up-to-date.
                        // They can now be transferred to the parents.
                        node := cur.handle.Get()
                        if e := updateChildrenHashes(manager, node, embedded); e != nil </span><span class="cov0" title="0">{
                                err = e
                                break</span>
                        }

                        // Test whether this node is to be embedded.
                        <span class="cov8" title="1">if res, e := h.isEmbedded(cur.handle.Get(), manager); err != nil </span><span class="cov0" title="0">{
                                cur.handle.Release()
                                err = e
                                break</span>
                        } else<span class="cov8" title="1"> if res </span><span class="cov8" title="1">{
                                // Fix hash of embedded nodes to be 0.
                                hash = common.Hash{}
                                embedded[cur.node.Id()] = true
                        }</span> else<span class="cov8" title="1"> {
                                // Encode the node using RLP and compute its hash.
                                data, e := encodeToRlp(node, manager, data)
                                if e != nil </span><span class="cov0" title="0">{
                                        cur.handle.Release()
                                        err = e
                                        break</span>
                                }
                                <span class="cov8" title="1">hash = common.Keccak256(data)</span>
                        }

                        <span class="cov8" title="1">node.SetHash(hash)

                        if hashCollector != nil </span><span class="cov8" title="1">{
                                hashCollector.Add(cur.path, hash)
                        }</span>

                        <span class="cov8" title="1">cur.handle.Release()</span>
                }
        }

        <span class="cov8" title="1">for i := 0; i &lt; len(tasks); i++ </span><span class="cov0" title="0">{
                if tasks[i].handle.Valid() </span><span class="cov0" title="0">{
                        tasks[i].handle.Release()
                }</span>
        }

        <span class="cov8" title="1">return hash, err</span>
}

func (h ethHasher) getHash(ref *NodeReference, source NodeSource) (common.Hash, error) <span class="cov8" title="1">{
        if ref.Id().IsEmpty() </span><span class="cov8" title="1">{
                return EmptyNodeEthereumHash, nil
        }</span>
        // Get read access to the node (hashes may not be updated).
        <span class="cov8" title="1">handle, err := source.getViewAccess(ref)
        if err != nil </span><span class="cov0" title="0">{
                return common.Hash{}, err
        }</span>
        <span class="cov8" title="1">node := handle.Get()

        // Encode the node in RLP and compute its hash.
        data := make([]byte, 0, 1024)
        data, err = encodeToRlp(node, source, data)
        handle.Release()
        if err != nil </span><span class="cov0" title="0">{
                return common.Hash{}, err
        }</span>

        // The hash for embedded nodes is the node representation.
        <span class="cov8" title="1">if len(data) &lt; 32 </span><span class="cov8" title="1">{
                return common.Hash{}, nil
        }</span>

        <span class="cov8" title="1">return common.Keccak256(data), nil</span>
}

// updateChildrenHashes refreshes the hashes of all children of the given node.
func updateChildrenHashes(manager NodeSource, node Node, embedded map[NodeId]bool) error <span class="cov8" title="1">{
        switch cur := node.(type) </span>{
        case *BranchNode:<span class="cov8" title="1">
                for i := 0; i &lt; len(cur.children); i++ </span><span class="cov8" title="1">{
                        if !cur.children[i].Id().IsEmpty() &amp;&amp; cur.isChildHashDirty(byte(i)) </span><span class="cov8" title="1">{
                                handle, e := manager.getViewAccess(&amp;cur.children[i])
                                if e != nil </span><span class="cov8" title="1">{
                                        return e
                                }</span>
                                <span class="cov8" title="1">hash, dirty := handle.Get().GetHash()
                                if dirty </span><span class="cov0" title="0">{
                                        panic("FATAL: detected dirty child of branch node\n")</span>
                                }
                                <span class="cov8" title="1">cur.hashes[i] = hash
                                cur.setEmbedded(byte(i), embedded[cur.children[i].Id()])
                                handle.Release()</span>
                        }
                }
                <span class="cov8" title="1">cur.clearChildHashDirtyFlags()</span>
        case *ExtensionNode:<span class="cov8" title="1">
                if cur.nextHashDirty </span><span class="cov8" title="1">{
                        handle, e := manager.getViewAccess(&amp;cur.next)
                        if e != nil </span><span class="cov0" title="0">{
                                return e
                        }</span>
                        <span class="cov8" title="1">hash, dirty := handle.Get().GetHash()
                        if dirty </span><span class="cov0" title="0">{
                                panic("FATAL: detected dirty child of extension node\n")</span>
                        }
                        <span class="cov8" title="1">cur.nextIsEmbedded = embedded[cur.next.Id()]
                        cur.nextHash = hash
                        handle.Release()
                        cur.nextHashDirty = false</span>
                }
        case *AccountNode:<span class="cov8" title="1">
                if cur.storageHashDirty &amp;&amp; !cur.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                        handle, e := manager.getViewAccess(&amp;cur.storage)
                        if e != nil </span><span class="cov0" title="0">{
                                return e
                        }</span>
                        <span class="cov8" title="1">hash, dirty := handle.Get().GetHash()
                        if dirty </span><span class="cov0" title="0">{
                                panic("FATAL: detected dirty child of account node\n")</span>
                        }
                        <span class="cov8" title="1">cur.storageHash = hash
                        handle.Release()
                        cur.storageHashDirty = false</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// encodeToRlp computes the RLP encoding of the given node. If needed, additional nodes are
// fetched from the given source for deriving the encoding.
// The node and source parameter must not be nil.
// The result is stored in the input slice, and the slice is returned as well.
// The reason for having the slice on the input is that the encoding of nodes
// is a frequent operation and the slice can be reused to reduce memory allocations.
func encodeToRlp(
        node Node,
        source NodeSource,
        target []byte,
) ([]byte, error) <span class="cov8" title="1">{
        switch trg := node.(type) </span>{
        case EmptyNode:<span class="cov8" title="1">
                return encodeEmptyToRlp()</span>
        case *AccountNode:<span class="cov8" title="1">
                return encodeAccountToRlp(trg, source, target)</span>
        case *BranchNode:<span class="cov8" title="1">
                return encodeBranchToRlp(trg, source, target)</span>
        case *ExtensionNode:<span class="cov8" title="1">
                return encodeExtensionToRlp(trg, source, target)</span>
        case *ValueNode:<span class="cov8" title="1">
                return encodeValueToRlp(trg, source, target)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported node type: %v", reflect.TypeOf(node))</span>
        }
}

var emptyStringRlpEncoded = rlp.Encode(rlp.String{})

// rlpEncodingBufferPool is a pool for temporary buffers required to encode RLP fragments.
var rlpEncodingBufferPool = sync.Pool{New: func() any <span class="cov8" title="1">{
        s := make([]byte, 0, 1024)
        return &amp;s
}</span>,
}

func encodeEmptyToRlp() ([]byte, error) <span class="cov8" title="1">{
        return emptyStringRlpEncoded, nil
}</span>

// This pools stores not only the slice, but also its pointer, to reduce calls to runtime.convTslice(),
// inspired by:
// https://blog.mike.norgate.xyz/unlocking-go-slice-performance-navigating-sync-pool-for-enhanced-efficiency-7cb63b0b453e
var branchRlpStreamPool = sync.Pool{New: func() any <span class="cov8" title="1">{
        s := make([]rlp.Item, 16+1)
        return &amp;s
}</span>,
}

func encodeBranchToRlp(
        node *BranchNode,
        source NodeSource,
        target []byte,
) ([]byte, error) <span class="cov8" title="1">{
        children := &amp;node.children

        ptr := branchRlpStreamPool.Get().(*[]rlp.Item)
        items := *ptr

        for i := 0; i &lt; len(children); i++ </span><span class="cov8" title="1">{
                child := &amp;children[i]
                if child.Id().IsEmpty() </span><span class="cov8" title="1">{
                        items[i] = rlp.String{}
                        continue</span>
                }

                <span class="cov8" title="1">if node.isEmbedded(byte(i)) </span><span class="cov8" title="1">{
                        node, err := source.getViewAccess(child)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">var encoded = make([]byte, 0, 1024)
                        encoded, err = encodeToRlp(node.Get(), source, encoded)
                        node.Release()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">items[i] = rlp.Encoded{Data: encoded}</span>
                } else<span class="cov8" title="1"> {
                        // passing by pointer to hash limits convTslice() calls
                        items[i] = rlp.Hash{Hash: &amp;node.hashes[i]}
                }</span>
        }

        // There is one 17th entry which would be filled if this node is a terminator. However,
        // branch nodes are never terminators in State or Storage Tries.
        <span class="cov8" title="1">items[len(children)] = rlp.String{}

        res := rlp.EncodeInto(target[0:0], rlp.List{Items: items})
        branchRlpStreamPool.Put(ptr)
        return res, nil</span>
}

var extensionRlpStreamPool = sync.Pool{New: func() any <span class="cov8" title="1">{
        s := make([]rlp.Item, 2)
        return &amp;s
}</span>,
}

func encodeExtensionToRlp(
        node *ExtensionNode,
        source NodeSource,
        target []byte,
) ([]byte, error) <span class="cov8" title="1">{
        ptr := extensionRlpStreamPool.Get().(*[]rlp.Item)
        defer extensionRlpStreamPool.Put(ptr)
        items := *ptr

        numNibbles := node.path.Length()
        packedNibbles := node.path.GetPackedNibbles()

        pathBufferPtr := rlpEncodingBufferPool.Get().(*[]byte)
        pathBuffer := *pathBufferPtr

        items[0] = &amp;rlp.String{Str: encodePartialPath(packedNibbles, numNibbles, false, pathBuffer)}

        // TODO [cleanup]: the use of the same encoding as for the branch nodes is
        // done for symmetry, but there is no unit test for this yet; it
        // would require to find two keys or address with a very long
        // common hash prefix.
        if node.nextIsEmbedded </span><span class="cov8" title="1">{
                next, err := source.getViewAccess(&amp;node.next)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer next.Release()
                encoded := make([]byte, 0, 1024)
                encoded, err = encodeToRlp(next.Get(), source, encoded)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items[1] = rlp.Encoded{Data: encoded}</span>
        } else<span class="cov8" title="1"> {
                items[1] = rlp.String{Str: node.nextHash[:]}
        }</span>

        <span class="cov8" title="1">res := rlp.EncodeInto(target[0:0], rlp.List{Items: items})

        *pathBufferPtr = pathBuffer
        rlpEncodingBufferPool.Put(pathBufferPtr)

        return res, nil</span>
}

var accountRlpStreamPool = sync.Pool{New: func() any <span class="cov8" title="1">{
        s := make([]rlp.Item, 4)
        return &amp;s
}</span>,
}

func encodeAccountToRlp(
        node *AccountNode,
        source NodeSource,
        target []byte,
) ([]byte, error) <span class="cov8" title="1">{
        storageRoot := &amp;node.storage

        // Encode the account information to get the value.
        ptr := accountRlpStreamPool.Get().(*[]rlp.Item)
        items := *ptr

        items[0] = rlp.Uint64{Value: node.info.Nonce.ToUint64()}
        items[1] = rlp.BigInt{Value: node.info.Balance.ToBig()}
        if storageRoot.Id().IsEmpty() </span><span class="cov8" title="1">{
                items[2] = rlp.Hash{Hash: &amp;EmptyNodeEthereumHash}
        }</span> else<span class="cov8" title="1"> {
                items[2] = rlp.Hash{Hash: &amp;node.storageHash}
        }</span>
        <span class="cov8" title="1">items[3] = rlp.Hash{Hash: &amp;node.info.CodeHash}

        addressBufferPtr := rlpEncodingBufferPool.Get().(*[]byte)
        addressBuffer := *addressBufferPtr

        contentBufferPtr := rlpEncodingBufferPool.Get().(*[]byte)
        contentBuffer := *contentBufferPtr

        contentBuffer = rlp.EncodeInto(contentBuffer[0:0], rlp.List{Items: items})

        // Encode the leaf node by combining the partial path with the value.
        items = items[0:2]
        items[0] = rlp.String{Str: encodeAddressPath(node.address, int(node.pathLength), source, addressBuffer)}
        items[1] = rlp.String{Str: contentBuffer}
        res := rlp.EncodeInto(target[0:0], rlp.List{Items: items})

        *addressBufferPtr = addressBuffer
        rlpEncodingBufferPool.Put(addressBufferPtr)

        *contentBufferPtr = contentBuffer
        rlpEncodingBufferPool.Put(contentBufferPtr)

        accountRlpStreamPool.Put(ptr)
        return res, nil</span>
}

var valueRlpStreamPool = sync.Pool{New: func() any <span class="cov8" title="1">{
        s := make([]rlp.Item, 2)
        return &amp;s
}</span>,
}

func encodeValueToRlp(
        node *ValueNode,
        source NodeSource,
        target []byte,
) ([]byte, error) <span class="cov8" title="1">{
        ptr := valueRlpStreamPool.Get().(*[]rlp.Item)
        defer valueRlpStreamPool.Put(ptr)
        items := *ptr

        // The first item is an encoded path fragment.
        encodedPathPtr := rlpEncodingBufferPool.Get().(*[]byte)
        encodedPath := *encodedPathPtr
        items[0] = &amp;rlp.String{Str: encodeKeyPath(node.key, int(node.pathLength), source, encodedPath)}

        // The second item is the value without leading zeros.
        value := node.value[:]
        for len(value) &gt; 0 &amp;&amp; value[0] == 0 </span><span class="cov8" title="1">{
                value = value[1:]
        }</span>

        <span class="cov8" title="1">encodedValuePtr := rlpEncodingBufferPool.Get().(*[]byte)
        encodedValue := *encodedValuePtr
        encodedValue = rlp.EncodeInto(encodedValue[0:0], &amp;rlp.String{Str: value[:]})
        items[1] = &amp;rlp.String{Str: encodedValue}

        res := rlp.EncodeInto(target[0:0], rlp.List{Items: items})

        *encodedPathPtr = encodedPath
        rlpEncodingBufferPool.Put(encodedPathPtr)
        *encodedValuePtr = encodedValue
        rlpEncodingBufferPool.Put(encodedValuePtr)
        return res, nil</span>
}

func encodeKeyPath(key common.Key, numNibbles int, nodes NodeSource, target []byte) []byte <span class="cov8" title="1">{
        path := nodes.hashKey(key)
        return encodePartialPath(path[32-(numNibbles/2+numNibbles%2):], numNibbles, true, target)
}</span>

func encodeAddressPath(address common.Address, numNibbles int, nodes NodeSource, target []byte) []byte <span class="cov8" title="1">{
        path := nodes.hashAddress(address)
        return encodePartialPath(path[32-(numNibbles/2+numNibbles%2):], numNibbles, true, target)
}</span>

// Requires packedNibbles to include nibbles as [0a bc de] or [ab cd ef]
func encodePartialPath(packedNibbles []byte, numNibbles int, targetsValue bool, target []byte) []byte <span class="cov8" title="1">{
        // Path encoding derived from Ethereum.
        // see https://github.com/ethereum/go-ethereum/blob/v1.12.0/trie/encoding.go#L37
        oddLength := numNibbles%2 == 1
        compact := target[0:getEncodedPartialPathSize(numNibbles)]

        // The high nibble of the first byte encodes the 'is-value' mark
        // and whether the length is even or odd.
        compact[0] = 0
        if targetsValue </span><span class="cov8" title="1">{
                compact[0] |= 1 &lt;&lt; 5
        }</span>
        <span class="cov8" title="1">compact[0] |= (byte(numNibbles) % 2) &lt;&lt; 4 // odd flag

        // If there is an odd number of nibbles, the first is included in the
        // low-part of the compact path encoding.
        if oddLength </span><span class="cov8" title="1">{
                compact[0] |= packedNibbles[0] &amp; 0xf
                packedNibbles = packedNibbles[1:]
        }</span>
        // The rest of the nibbles can be copied.
        <span class="cov8" title="1">copy(compact[1:], packedNibbles)
        return compact</span>
}

func getEncodedPartialPathSize(numNibbles int) int <span class="cov8" title="1">{
        return numNibbles/2 + 1
}</span>

// isEmbedded determines whether the given node is an embedded node or not.
// If information required for determining the embedded-state of the node is
// marked dirty, this information is updated. Thus, calls to this function may
// cause updates to the state of some nodes.
func (h ethHasher) isEmbedded(
        node Node,
        source NodeSource,
) (bool, error) <span class="cov8" title="1">{
        return isNodeEmbedded(node, source)
}</span>

// isNodeEmbedded determines whether the given node is an embedded node or not.
// If information required for determining the embedded-state of the node is
// marked dirty, this information is updated. Thus, calls to this function may
// cause updates to the state of some nodes.
func isNodeEmbedded(
        node Node,
        source NodeSource,
) (bool, error) <span class="cov8" title="1">{
        // Start by estimating a lower bound for the node size.
        minSize, err := getLowerBoundForEncodedSize(node, 32, source)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // If the lower boundary exceeds the limit we can be sure it is not an embedded node.
        <span class="cov8" title="1">if minSize &gt;= 32 </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // We need to encodeToRlp it to be certain.
        <span class="cov8" title="1">var encoded = make([]byte, 0, 1024)
        encoded, err = encodeToRlp(node, source, encoded)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return len(encoded) &lt; 32, nil</span>
}

func getLowerBoundForEncodedSize(node Node, limit int, nodes NodeSource) (int, error) <span class="cov8" title="1">{
        switch trg := node.(type) </span>{
        case EmptyNode:<span class="cov8" title="1">
                return getLowerBoundForEncodedSizeEmpty(trg, limit, nodes)</span>
        case *AccountNode:<span class="cov8" title="1">
                return getLowerBoundForEncodedSizeAccount(trg, limit, nodes)</span>
        case *BranchNode:<span class="cov8" title="1">
                return getLowerBoundForEncodedSizeBranch(trg, limit, nodes)</span>
        case *ExtensionNode:<span class="cov8" title="1">
                return getLowerBoundForEncodedSizeExtension(trg, limit, nodes)</span>
        case *ValueNode:<span class="cov8" title="1">
                return getLowerBoundForEncodedSizeValue(trg, limit, nodes)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unsupported node type: %v", reflect.TypeOf(node))</span>
        }
}

func getLowerBoundForEncodedSizeEmpty(node EmptyNode, limit int, nodes NodeSource) (int, error) <span class="cov8" title="1">{
        return len(emptyStringRlpEncoded), nil
}</span>

func getLowerBoundForEncodedSizeAccount(node *AccountNode, limit int, nodes NodeSource) (int, error) <span class="cov8" title="1">{
        size := 32 + 32 // storage and code hash
        // There is no need for anything more accurate so far, since
        // all queries will use a limit &lt;= 32.
        return size, nil
}</span>

func getLowerBoundForEncodedSizeBranch(node *BranchNode, limit int, nodes NodeSource) (int, error) <span class="cov8" title="1">{
        var emptySize = len(emptyStringRlpEncoded)
        sum := 1        // children are encoded as elements of a list and the list adds at least 1 byte for the size
        sum = emptySize // the 17th element.

        // Sum up non-embedded hashes first (because they are cheap to compute).
        for i := 0; i &lt; len(node.children); i++ </span><span class="cov8" title="1">{
                child := node.children[i]
                if child.Id().IsEmpty() </span><span class="cov8" title="1">{
                        sum += emptySize
                        continue</span>
                }
                <span class="cov8" title="1">if !node.isChildHashDirty(byte(i)) &amp;&amp; !node.isEmbedded(byte(i)) </span><span class="cov8" title="1">{
                        sum += common.HashSize
                }</span>
        }

        <span class="cov8" title="1">if sum &gt;= limit </span><span class="cov8" title="1">{
                return sum, nil
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(node.children); i++ </span><span class="cov8" title="1">{
                child := node.children[i]
                if sum &gt;= limit </span><span class="cov8" title="1">{
                        return limit, nil
                }</span>
                <span class="cov8" title="1">if child.Id().IsEmpty() || !(node.isChildHashDirty(byte(i)) || node.isEmbedded(byte(i))) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">node, err := nodes.getViewAccess(&amp;child)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">size, err := getLowerBoundForEncodedSize(node.Get(), limit-sum, nodes)
                node.Release()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if size &gt;= 32 </span><span class="cov8" title="1">{
                        size = 32
                }</span>
                <span class="cov8" title="1">sum += size</span>
        }
        <span class="cov8" title="1">return sum, nil</span>
}

func getLowerBoundForEncodedSizeExtension(node *ExtensionNode, limit int, nodes NodeSource) (int, error) <span class="cov8" title="1">{
        sum := 1 // list header

        sum += getEncodedPartialPathSize(node.path.Length())
        if sum &gt;= limit </span><span class="cov0" title="0">{
                return sum, nil
        }</span>

        <span class="cov8" title="1">next, err := nodes.getViewAccess(&amp;node.next)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer next.Release()

        size, err := getLowerBoundForEncodedSize(next.Get(), limit-sum, nodes)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">if size &gt; 32 </span><span class="cov8" title="1">{
                size = 32
        }</span>
        <span class="cov8" title="1">sum += size

        return sum, nil</span>
}

func getLowerBoundForEncodedSizeValue(node *ValueNode, limit int, nodes NodeSource) (int, error) <span class="cov8" title="1">{
        size := getEncodedPartialPathSize(int(node.pathLength))
        if size &gt; 1 </span><span class="cov8" title="1">{
                size++ // one extra byte for the length
        }</span>
        <span class="cov8" title="1">if size &gt;= limit </span><span class="cov8" title="1">{
                return size, nil
        }</span>

        <span class="cov8" title="1">value := node.value[:]
        for len(value) &gt; 0 &amp;&amp; value[0] == 0 </span><span class="cov8" title="1">{
                value = value[1:]
        }</span>
        <span class="cov8" title="1">return size + len(value) + 1, nil</span>
}

type nodeHashCollector struct {
        hashes *NodeHashes
}

func (n *nodeHashCollector) Add(path NodePath, hash common.Hash) <span class="cov8" title="1">{
        n.hashes.Add(path, hash)
}</span>

func (n *nodeHashCollector) GetHashes() *NodeHashes <span class="cov8" title="1">{
        return n.hashes
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: hasher.go
//
// Generated by this command:
//
//        mockgen -source hasher.go -destination hasher_mocks.go -package mpt
//

// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        common "github.com/Fantom-foundation/Carmen/go/common"
        gomock "go.uber.org/mock/gomock"
)

// Mockhasher is a mock of hasher interface.
type Mockhasher struct {
        ctrl     *gomock.Controller
        recorder *MockhasherMockRecorder
}

// MockhasherMockRecorder is the mock recorder for Mockhasher.
type MockhasherMockRecorder struct {
        mock *Mockhasher
}

// NewMockhasher creates a new mock instance.
func NewMockhasher(ctrl *gomock.Controller) *Mockhasher <span class="cov0" title="0">{
        mock := &amp;Mockhasher{ctrl: ctrl}
        mock.recorder = &amp;MockhasherMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockhasher) EXPECT() *MockhasherMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// getHash mocks base method.
func (m *Mockhasher) getHash(arg0 *NodeReference, arg1 NodeSource) (common.Hash, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getHash", arg0, arg1)
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getHash indicates an expected call of getHash.
func (mr *MockhasherMockRecorder) getHash(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getHash", reflect.TypeOf((*Mockhasher)(nil).getHash), arg0, arg1)
}</span>

// isEmbedded mocks base method.
func (m *Mockhasher) isEmbedded(arg0 Node, arg1 NodeSource) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "isEmbedded", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// isEmbedded indicates an expected call of isEmbedded.
func (mr *MockhasherMockRecorder) isEmbedded(arg0, arg1 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "isEmbedded", reflect.TypeOf((*Mockhasher)(nil).isEmbedded), arg0, arg1)
}</span>

// updateHashes mocks base method.
func (m *Mockhasher) updateHashes(root *NodeReference, nodes NodeManager) (common.Hash, *NodeHashes, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "updateHashes", root, nodes)
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(*NodeHashes)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// updateHashes indicates an expected call of updateHashes.
func (mr *MockhasherMockRecorder) updateHashes(root, nodes any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "updateHashes", reflect.TypeOf((*Mockhasher)(nil).updateHashes), root, nodes)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "unsafe"

        "github.com/Fantom-foundation/Carmen/go/common"
)

// LiveTrie retains a single trie encoding state information with destructible
// updates. Thus, whenever updating some information, the previous state is
// lost.
//
// Its main role is to adapt the maintain a root node and to provide a single-
// trie view on a forest.
type LiveTrie struct {
        // The node structure of the trie.
        forest Database
        // The root node of the trie.
        root NodeReference
        // The file name for storing trie metadata.
        metadatafile string
}

// OpenInMemoryLiveTrie loads trie information from the given directory and
// creates a LiveTrie instance retaining all information in memory. If the
// directory is empty, an empty trie is created.
func OpenInMemoryLiveTrie(directory string, config MptConfig, cacheConfig NodeCacheConfig) (*LiveTrie, error) <span class="cov8" title="1">{
        forestConfig := ForestConfig{Mode: Mutable, NodeCacheConfig: cacheConfig}
        forest, err := OpenInMemoryForest(directory, config, forestConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return makeTrie(directory, forest)</span>
}

// OpenInMemoryLiveTrie loads trie information from the given directory and
// creates a LiveTrie instance using a fixed-size cache for retaining nodes in
// memory, backed by a file-based storage automatically kept in sync. If the
// directory is empty, an empty trie is created.
func OpenFileLiveTrie(directory string, config MptConfig, cacheConfig NodeCacheConfig) (*LiveTrie, error) <span class="cov8" title="1">{
        forestConfig := ForestConfig{Mode: Mutable, NodeCacheConfig: cacheConfig}
        forest, err := OpenFileForest(directory, config, forestConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return makeTrie(directory, forest)</span>
}

// VerifyFileLiveTrie validates a file-based live trie stored in the given
// directory. If the test passes, the data stored in the respective directory
// can be considered to be a valid Live Trie of the given configuration.
func VerifyFileLiveTrie(directory string, config MptConfig, observer VerificationObserver) error <span class="cov8" title="1">{
        metadata, exists, err := readMetadata(directory + "/meta.json")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return verifyFileForest(directory, config, []Root{{
                NewNodeReference(metadata.RootNode),
                metadata.RootHash,
        }}, observer)</span>
}

func makeTrie(
        directory string,
        forest *Forest,
) (*LiveTrie, error) <span class="cov8" title="1">{
        if err := forest.CheckErrors(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unable to open corrupted forest: %w", err)
        }</span>
        // Parse metadata file.
        <span class="cov8" title="1">metadatafile := directory + "/meta.json"
        metadata, _, err := readMetadata(metadatafile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;LiveTrie{
                root:         NewNodeReference(metadata.RootNode),
                metadatafile: metadatafile,
                forest:       forest,
        }, nil</span>
}

// getTrieView creates a live trie based on an existing Forest instance.
func getTrieView(root NodeReference, forest Database) *LiveTrie <span class="cov8" title="1">{
        return &amp;LiveTrie{
                root:   root,
                forest: forest,
        }
}</span>

// HasEmptyStorage returns true if account has empty storage.
func (s *LiveTrie) HasEmptyStorage(addr common.Address) (bool, error) <span class="cov8" title="1">{
        return s.forest.HasEmptyStorage(&amp;s.root, addr)
}</span>

func (s *LiveTrie) GetAccountInfo(addr common.Address) (AccountInfo, bool, error) <span class="cov8" title="1">{
        return s.forest.GetAccountInfo(&amp;s.root, addr)
}</span>

func (s *LiveTrie) SetAccountInfo(addr common.Address, info AccountInfo) error <span class="cov8" title="1">{
        newRoot, err := s.forest.SetAccountInfo(&amp;s.root, addr, info)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.root = newRoot
        return nil</span>
}

func (s *LiveTrie) GetValue(addr common.Address, key common.Key) (common.Value, error) <span class="cov8" title="1">{
        return s.forest.GetValue(&amp;s.root, addr, key)
}</span>

func (s *LiveTrie) SetValue(addr common.Address, key common.Key, value common.Value) error <span class="cov8" title="1">{
        newRoot, err := s.forest.SetValue(&amp;s.root, addr, key, value)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.root = newRoot
        return nil</span>
}

func (s *LiveTrie) ClearStorage(addr common.Address) error <span class="cov8" title="1">{
        newRoot, err := s.forest.ClearStorage(&amp;s.root, addr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.root = newRoot
        return nil</span>
}

func (s *LiveTrie) UpdateHashes() (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        return s.forest.updateHashesFor(&amp;s.root)
}</span>

func (s *LiveTrie) setHashes(hashes *NodeHashes) error <span class="cov8" title="1">{
        return s.forest.setHashesFor(&amp;s.root, hashes)
}</span>

func (s *LiveTrie) VisitTrie(visitor NodeVisitor) error <span class="cov8" title="1">{
        return s.forest.VisitTrie(&amp;s.root, visitor)
}</span>

func (s *LiveTrie) Flush() error <span class="cov8" title="1">{
        // Update hashes to eliminate dirty hashes before flushing.
        hash, _, err := s.UpdateHashes()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update on-disk meta-data.
        <span class="cov8" title="1">metadata, err := json.Marshal(metadata{
                RootNode: s.root.Id(),
                RootHash: hash,
        })

        if err == nil </span><span class="cov8" title="1">{
                if err := os.WriteFile(s.metadatafile, metadata, 0600); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return errors.Join(err, s.forest.Flush())</span>
}

func (s *LiveTrie) Close() error <span class="cov8" title="1">{
        return errors.Join(
                s.Flush(),
                s.forest.Close(),
        )
}</span>

// GetMemoryFootprint provides sizes of individual components of the state in the memory
func (s *LiveTrie) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        mf := common.NewMemoryFootprint(unsafe.Sizeof(*s))
        mf.AddChild("forest", s.forest.GetMemoryFootprint())
        return mf
}</span>

// Dump prints the content of the Trie to the console. Mainly intended for debugging.
func (s *LiveTrie) Dump() <span class="cov8" title="1">{
        s.forest.Dump(&amp;s.root)
}</span>

// Check verifies internal invariants of the Trie instance. If the trie is
// self-consistent, nil is returned and the Trie is read to be accessed. If
// errors are detected, the Trie is to be considered in an invalid state and
// the behavior of all other operations is undefined.
func (s *LiveTrie) Check() error <span class="cov8" title="1">{
        return s.forest.Check(&amp;s.root)
}</span>

// -- LiveTrie metadata --

// metadata is the helper type to read and write metadata from/to the disk.
type metadata struct {
        RootNode NodeId
        RootHash common.Hash
}

// readMetadata parses the content of the given file if it exists or returns
// a default-initialized metadata struct if there is no such file.
func readMetadata(filename string) (metadata, bool, error) <span class="cov8" title="1">{

        // If there is no file, initialize and return default metadata.
        if _, err := os.Stat(filename); err != nil </span><span class="cov8" title="1">{
                return metadata{}, false, nil
        }</span>

        // If the file exists, parse it and return its content.
        <span class="cov8" title="1">data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return metadata{}, false, err
        }</span>

        <span class="cov8" title="1">var meta metadata
        if err := json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov8" title="1">{
                return meta, false, err
        }</span>
        <span class="cov8" title="1">return meta, true, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import "github.com/Fantom-foundation/Carmen/go/common"

// Nibble is a 4-bit signed integer in the range 0-F. It is a single letter
// used to navigate in the MPT structure.
type Nibble byte

// Rune converts a Nibble in a hexa-decimal rune (0-9a-f).
func (n Nibble) Rune() rune <span class="cov8" title="1">{
        if n &lt; 10 </span><span class="cov8" title="1">{
                return rune('0' + n)
        }</span> else<span class="cov8" title="1"> if n &lt; 16 </span><span class="cov8" title="1">{
                return rune('a' + n - 10)
        }</span> else<span class="cov8" title="1"> {
                return '?'
        }</span>
}

// String converts a Nibble in a hexa-decimal string (0-9a-f).
func (n Nibble) String() string <span class="cov8" title="1">{
        return string(n.Rune())
}</span>

// AddressToNibblePath converts the given path into a slice of Nibbles. Optionally, the
// path is hashed before being converted. The path is hashed when hashing is enabled in configuration.
func AddressToNibblePath(address common.Address, source NodeSource) []Nibble <span class="cov8" title="1">{
        var path []byte
        if source != nil &amp;&amp; source.getConfig().UseHashedPaths </span><span class="cov8" title="1">{
                hash := source.hashAddress(address)
                path = hash[:]
        }</span> else<span class="cov8" title="1"> {
                path = address[:]
        }</span>

        <span class="cov8" title="1">res := make([]Nibble, len(path)*2)
        parseNibbles(res, path)
        return res</span>
}

// KeyToNibblePath converts the given path into a slice of Nibbles. Optionally, the
// path is hashed before being converted. The path is hashed when hashing is enabled in configuration.
func KeyToNibblePath(key common.Key, source NodeSource) []Nibble <span class="cov8" title="1">{
        var path []byte
        if source != nil &amp;&amp; source.getConfig().UseHashedPaths </span><span class="cov8" title="1">{
                hash := source.hashKey(key)
                path = hash[:]
        }</span> else<span class="cov8" title="1"> {
                path = key[:]
        }</span>

        <span class="cov8" title="1">res := make([]Nibble, len(path)*2)
        parseNibbles(res, path)
        return res</span>
}

// addressToHashedNibbles converts the given path into a slice of Nibbles.
// It always hashes the path before converting it.
func addressToHashedNibbles(address common.Address) []Nibble <span class="cov8" title="1">{
        path := common.Keccak256(address[:])
        res := make([]Nibble, len(path)*2)
        parseNibbles(res, path[:])
        return res
}</span>

// keyToHashedPathNibbles converts the given path into a slice of Nibbles.
// It always hashes the path before converting it.
func keyToHashedPathNibbles(key common.Key) []Nibble <span class="cov8" title="1">{
        path := common.Keccak256(key[:])
        res := make([]Nibble, len(path)*2)
        parseNibbles(res, path[:])
        return res
}</span>

func parseNibbles(dst []Nibble, src []byte) <span class="cov8" title="1">{
        for i := 0; i &lt; len(src); i++ </span><span class="cov8" title="1">{
                dst[2*i] = Nibble(src[i] &gt;&gt; 4)
                dst[2*i+1] = Nibble(src[i] &amp; 0xF)
        }</span>
}

// GetCommonPrefixLength computes the length of the common prefix of the given
// Nibble-slices.
func GetCommonPrefixLength(a, b []Nibble) int <span class="cov8" title="1">{
        lengthA := len(a)
        if lengthA &gt; len(b) </span><span class="cov8" title="1">{
                return GetCommonPrefixLength(b, a)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; lengthA; i++ </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return lengthA</span>
}

// IsPrefixOf tests whether one Nibble slice is the prefix of another.
func IsPrefixOf(a, b []Nibble) bool <span class="cov8" title="1">{
        return len(a) &lt;= len(b) &amp;&amp; GetCommonPrefixLength(a, b) == len(a)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "sync"
        "sync/atomic"
        "unsafe"

        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
)

//go:generate mockgen -source node_cache.go -destination node_cache_mocks.go -package mpt

// NodeReference is used to address a node within an MPT. The node is
// identified by a NodeId and may either be in memory or on disk. In
// combination with a NodeCache, a reference can be used to resolve and
// access nodes while navigating an MPT instance. Internally, references
// cache information enabling efficient access to nodes.
// NOTE: NodeReferences must be consistently used with a single NodeCache
// instance. Mixing references to nodes in different caches can lead to
// failures and corrupted content.
type NodeReference struct {
        id  NodeId // the ID of the referenced node
        pos uint32 // the position of the node within the cache
        tag uint64 // a tag used to invalidate references on cache changes
}

// NewNodeReference creates a new node reference pointing to the addressed
// Node.
func NewNodeReference(id NodeId) NodeReference <span class="cov8" title="1">{
        return NodeReference{id: id, pos: uint32(unknownPosition)}
}</span>

func (r *NodeReference) Id() NodeId <span class="cov8" title="1">{
        return r.id
}</span>

func (r *NodeReference) String() string <span class="cov8" title="1">{
        return r.id.String()
}</span>

// NodeCache is managing the life cycle of nodes in memory and limits the
// overall memory usage of nodes retained. Nodes can be accessed through
// NodeReferences. All accesses are thread safe.
type NodeCache interface {
        // Get tries to resolve the given node reference, returning the
        // corresponding node or nil if not found.
        Get(r *NodeReference) (node *shared.Shared[Node], found bool)

        // GetOrSet attempts to bind a new node to a given reference. If a node is
        // already bound to the referenced ID, the present value is returned.
        // Otherwise the provided node is registered in the cache and returned.
        // If the insertion causes a node to be evicted, the evicted node's ID,
        // the node itself, and a boolean flag indicating the eviction is returned.
        GetOrSet(*NodeReference, *shared.Shared[Node]) (
                after *shared.Shared[Node],
                present bool,
                evictedId NodeId,
                evictedNode *shared.Shared[Node],
                evicted bool,
        )

        // Touch signals the cache that the given node has been used. This signals
        // are used by implementation to manage the eviction order of elements.
        Touch(r *NodeReference)

        // Release signals the cache that the given node is unlikely to be reused in the near future.
        // It means that the node still remains in the cache, but it is marked
        // as the least recently used and thus next to be evicted when the cache becomes full.
        Release(r *NodeReference)

        // ForEach iterates through all elements in this cache.
        ForEach(func(NodeId, *shared.Shared[Node]))

        // MemoryFootprintProvider is embedded to require implementations to
        // produces a summary of the overall memory usage of this cache, including
        // the size of all owned node instances.
        common.MemoryFootprintProvider
}

// nodeCache implements the NodeCache interface using a fixed capacity cache
// of nodes and an LRU policy for evicting nodes.
//
// Internally, this implementation maintains a list of node-owners, each
// equipped with a tag to indicate mutations. Node references retain the
// position of referenced nodes in the list of owners and the tag. When
// resolving a node through a reference, the position and tag enable a direct,
// lock free lookup of the targeted node.
type nodeCache struct {
        owners     []nodeOwner              // fixed length list of all owned nodes
        index      map[NodeId]ownerPosition // an index on the owned nodes
        tagCounter uint64                   // a counter to generate fresh tags
        head       ownerPosition            // head of the LRU list of owners
        tail       ownerPosition            // tail of the LRU list of owners
        mutex      sync.Mutex               // for everything except the owner list
}

func NewNodeCache(capacity int) NodeCache <span class="cov8" title="1">{
        return newNodeCache(capacity)
}</span>

func newNodeCache(capacity int) *nodeCache <span class="cov8" title="1">{
        if capacity &lt; 1 </span><span class="cov0" title="0">{
                capacity = 1
        }</span>
        <span class="cov8" title="1">return &amp;nodeCache{
                owners: make([]nodeOwner, capacity),
                index:  make(map[NodeId]ownerPosition, capacity),
        }</span>
}

func (c *nodeCache) Get(r *NodeReference) (*shared.Shared[Node], bool) <span class="cov8" title="1">{
        // Node references cache the position of the owner retaining the referenced
        // node such that lookups are reduced to simple array lookups. However, at
        // any time the cache may chose to evict an element and replace it with
        // another. To do so, the owner at the corresponding position is simply
        // updated. To allow node references to identify situations in which the
        // referenced node got evicted, an additional tag is stored. This tag is
        // incremented every time an owner is recycled, allowing references to
        // identify modifications.
        pos := atomic.LoadUint32(&amp;r.pos)
        tag := atomic.LoadUint64(&amp;r.tag)
        for </span><span class="cov8" title="1">{
                // Resolve the owner position if needed.
                if pos &gt;= uint32(len(c.owners)) </span><span class="cov8" title="1">{
                        c.mutex.Lock()
                        position, found := c.index[r.id]
                        if !found </span><span class="cov8" title="1">{
                                c.mutex.Unlock()
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">pos = uint32(position)
                        tag = c.owners[pos].tag.Load()
                        atomic.StoreUint32(&amp;r.pos, pos)
                        atomic.StoreUint64(&amp;r.tag, tag)
                        c.mutex.Unlock()</span>
                }
                // Fetch the owner and check the tag.
                <span class="cov8" title="1">owner := &amp;c.owners[pos]
                res := owner.Node()
                // Check that the tag is still correct and the fetched result is valid.
                if owner.tag.Load() == tag &amp;&amp; isStableTag(tag) </span><span class="cov8" title="1">{
                        return res, true
                }</span>
                // If the tag has changed the position is out-dated and the true owner
                // needs to be resolved through the index.
                <span class="cov8" title="1">pos = uint32(unknownPosition)</span>
        }
}

func (c *nodeCache) GetOrSet(
        ref *NodeReference,
        node *shared.Shared[Node],
) (
        current *shared.Shared[Node],
        present bool,
        evictedId NodeId,
        evictedNode *shared.Shared[Node],
        evicted bool,
) <span class="cov8" title="1">{
        c.mutex.Lock()
        // Lookup element - if present, we are done.
        if pos, found := c.index[ref.id]; found </span><span class="cov8" title="1">{
                current := c.owners[pos].Node()
                c.mutex.Unlock()
                atomic.StoreUint32(&amp;ref.pos, uint32(pos))
                atomic.StoreUint64(&amp;ref.tag, c.owners[pos].tag.Load())
                return current, true, NodeId(0), nil, false
        }</span>

        // If not present, the capacity needs to be checked.
        <span class="cov8" title="1">var pos ownerPosition
        var target *nodeOwner
        if len(c.index) &gt;= len(c.owners) </span><span class="cov8" title="1">{
                // an element needs to be evicted
                pos = c.tail

                target = &amp;c.owners[pos]
                delete(c.index, target.Id())
                c.tail = target.prev

                // remember the evicted node
                evictedId = target.Id()
                evictedNode = target.Node()
                evicted = true

        }</span> else<span class="cov8" title="1"> {
                // start using a new node from the owner list
                pos = ownerPosition(len(c.index))
                target = &amp;c.owners[pos]
        }</span>

        // update the owner to own the new ID and node
        <span class="cov8" title="1">c.tagCounter++
        transition, stable := getUpdateTagPair(c.tagCounter)
        target.tag.Store(transition)
        target.id.Store(uint64(ref.Id()))
        target.node.Store(node)
        target.tag.Store(stable)

        // Move new owner to head of the LRU list.
        target.next = c.head
        c.owners[c.head].prev = pos
        c.head = pos

        c.index[ref.Id()] = pos
        c.mutex.Unlock()
        atomic.StoreUint32(&amp;ref.pos, uint32(pos))
        atomic.StoreUint64(&amp;ref.tag, stable)
        return node, false, evictedId, evictedNode, evicted</span>
}

func (c *nodeCache) Touch(r *NodeReference) <span class="cov8" title="1">{
        // During a touch we need to update the double-linked list
        // formed by owners such that the referenced node is at the
        // head position.
        pos := ownerPosition(atomic.LoadUint32(&amp;r.pos))
        if uint32(pos) &gt;= uint32(len(c.owners)) </span><span class="cov0" title="0">{
                // In this reference does not point to a valid owner; the
                // reference is not extra resolved to perform a touch, and
                // thus the operation can stop here.
                return
        }</span>
        <span class="cov8" title="1">target := &amp;c.owners[pos]
        c.mutex.Lock()
        if c.head == pos </span><span class="cov8" title="1">{
                c.mutex.Unlock()
                return
        }</span>
        <span class="cov8" title="1">if c.tail == pos </span><span class="cov8" title="1">{
                c.tail = target.prev
        }</span> else<span class="cov8" title="1"> {
                c.owners[target.next].prev = target.prev
        }</span>
        <span class="cov8" title="1">c.owners[target.prev].next = target.next

        c.owners[c.head].prev = pos
        target.next = c.head
        c.head = pos
        c.mutex.Unlock()</span>
}

func (c *nodeCache) Release(r *NodeReference) <span class="cov8" title="1">{
        // During a release we need to update the double-linked list
        // formed by owners such that the referenced node is at the
        // tail position.
        pos := ownerPosition(atomic.LoadUint32(&amp;r.pos))
        if uint32(pos) &gt;= uint32(len(c.owners)) </span><span class="cov8" title="1">{
                // This reference does not point to a valid owner; the
                // reference is not extra resolved to perform a release, and
                // thus the operation can stop here.
                return
        }</span>
        <span class="cov8" title="1">target := &amp;c.owners[pos]
        c.mutex.Lock()
        if c.tail == pos </span><span class="cov8" title="1">{
                c.mutex.Unlock()
                return
        }</span>
        <span class="cov8" title="1">if c.head == pos </span><span class="cov8" title="1">{
                c.head = target.next
        }</span> else<span class="cov8" title="1"> {
                c.owners[target.prev].next = target.next
        }</span>
        <span class="cov8" title="1">c.owners[target.next].prev = target.prev

        c.owners[c.tail].next = pos
        target.prev = c.tail
        c.tail = pos
        c.mutex.Unlock()</span>
}

func (c *nodeCache) ForEach(consume func(NodeId, *shared.Shared[Node])) <span class="cov8" title="1">{
        for i := 0; i &lt; len(c.owners); i++ </span><span class="cov8" title="1">{
                cur := &amp;c.owners[i]
                for </span><span class="cov8" title="1">{
                        tag := cur.tag.Load()
                        if tag == 0 </span><span class="cov8" title="1">{ // &lt; the owner is empty
                                break</span>
                        }
                        <span class="cov8" title="1">if isTransitionTag(tag) </span><span class="cov8" title="1">{ // &lt; the owner is being updated
                                continue</span>
                        }
                        <span class="cov8" title="1">id := cur.Id()
                        node := cur.Node()
                        if tag != cur.tag.Load() </span><span class="cov8" title="1">{
                                // The owner was updated in the meantime, repeat.
                                continue</span>
                        }
                        <span class="cov8" title="1">consume(id, node)
                        break</span>
                }
        }
}

func (c *nodeCache) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        mf := common.NewMemoryFootprint(unsafe.Sizeof(*c))
        mf.AddChild("owners", common.NewMemoryFootprint(unsafe.Sizeof(nodeOwner{})*uintptr(len(c.owners))))
        mf.AddChild("index", common.NewMemoryFootprint((unsafe.Sizeof(ownerPosition(0))+unsafe.Sizeof(NodeId(0)))*uintptr(len(c.index))))

        emptySize := unsafe.Sizeof(EmptyNode{})
        branchSize := unsafe.Sizeof(BranchNode{})
        extensionSize := unsafe.Sizeof(ExtensionNode{})
        accountSize := unsafe.Sizeof(AccountNode{})
        valueSize := unsafe.Sizeof(ValueNode{})

        size := uintptr(0)
        for i := 0; i &lt; len(c.owners); i++ </span><span class="cov8" title="1">{
                cur := &amp;c.owners[i]
                if cur.Node() == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">id := cur.Id()
                if id.IsEmpty() </span><span class="cov0" title="0">{
                        size += emptySize
                }</span> else<span class="cov0" title="0"> if id.IsBranch() </span><span class="cov0" title="0">{
                        size += branchSize
                }</span> else<span class="cov0" title="0"> if id.IsValue() </span><span class="cov0" title="0">{
                        size += valueSize
                }</span> else<span class="cov0" title="0"> if id.IsAccount() </span><span class="cov0" title="0">{
                        size += accountSize
                }</span> else<span class="cov0" title="0"> if id.IsExtension() </span><span class="cov0" title="0">{
                        size += extensionSize
                }</span>

        }
        <span class="cov8" title="1">mf.AddChild("nodes", common.NewMemoryFootprint(size))
        return mf</span>
}

func (c *nodeCache) getIdsInReverseEvictionOrder() []NodeId <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        res := make([]NodeId, 0, len(c.owners))
        for cur := c.head; cur != c.tail; cur = c.owners[cur].next </span><span class="cov8" title="1">{
                res = append(res, c.owners[cur].Id())
        }</span>
        <span class="cov8" title="1">if c.owners[c.tail].tag.Load() &gt; 0 </span><span class="cov8" title="1">{
                res = append(res, c.owners[c.tail].Id())
        }</span>
        <span class="cov8" title="1">return res</span>
}

// nodeOwner is a single entry of the node cache. It servers two roles:
// - provide synchronized access to an owned node
// - be an element of a LRU list to manage eviction order
type nodeOwner struct {
        tag  atomic.Uint64                       // a tag vor versioning the owned node
        id   atomic.Uint64                       // the ID of the owned node (protected by seq lock, but atomic for race detection check)
        node atomic.Pointer[shared.Shared[Node]] // the owned node (protected by seq lock, but atomic for race detection check)
        prev ownerPosition                       // predecessor in the LRU list
        next ownerPosition                       // successor in the LRU list
}

func (o *nodeOwner) Id() NodeId <span class="cov8" title="1">{
        return NodeId(o.id.Load())
}</span>

func (o *nodeOwner) Node() *shared.Shared[Node] <span class="cov8" title="1">{
        return o.node.Load()
}</span>

type ownerPosition uint32

const unknownPosition = ownerPosition(0xFFFFFFFF)

func isTransitionTag(tag uint64) bool <span class="cov8" title="1">{
        return tag&amp;0x1 == 0
}</span>

func isStableTag(tag uint64) bool <span class="cov8" title="1">{
        return tag&amp;0x1 == 1
}</span>

func getUpdateTagPair(id uint64) (uint64, uint64) <span class="cov8" title="1">{
        return id &lt;&lt; 1, (id &lt;&lt; 1) | 1
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: node_cache.go
//
// Generated by this command:
//
//        mockgen -source node_cache.go -destination node_cache_mocks.go -package mpt
//
// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        common "github.com/Fantom-foundation/Carmen/go/common"
        shared "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        gomock "go.uber.org/mock/gomock"
)

// MockNodeCache is a mock of NodeCache interface.
type MockNodeCache struct {
        ctrl     *gomock.Controller
        recorder *MockNodeCacheMockRecorder
}

// MockNodeCacheMockRecorder is the mock recorder for MockNodeCache.
type MockNodeCacheMockRecorder struct {
        mock *MockNodeCache
}

// NewMockNodeCache creates a new mock instance.
func NewMockNodeCache(ctrl *gomock.Controller) *MockNodeCache <span class="cov8" title="1">{
        mock := &amp;MockNodeCache{ctrl: ctrl}
        mock.recorder = &amp;MockNodeCacheMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNodeCache) EXPECT() *MockNodeCacheMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// ForEach mocks base method.
func (m *MockNodeCache) ForEach(arg0 func(NodeId, *shared.Shared[Node])) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "ForEach", arg0)
}</span>

// ForEach indicates an expected call of ForEach.
func (mr *MockNodeCacheMockRecorder) ForEach(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForEach", reflect.TypeOf((*MockNodeCache)(nil).ForEach), arg0)
}</span>

// Get mocks base method.
func (m *MockNodeCache) Get(r *NodeReference) (*shared.Shared[Node], bool) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", r)
        ret0, _ := ret[0].(*shared.Shared[Node])
        ret1, _ := ret[1].(bool)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockNodeCacheMockRecorder) Get(r any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockNodeCache)(nil).Get), r)
}</span>

// GetMemoryFootprint mocks base method.
func (m *MockNodeCache) GetMemoryFootprint() *common.MemoryFootprint <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMemoryFootprint")
        ret0, _ := ret[0].(*common.MemoryFootprint)
        return ret0
}</span>

// GetMemoryFootprint indicates an expected call of GetMemoryFootprint.
func (mr *MockNodeCacheMockRecorder) GetMemoryFootprint() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMemoryFootprint", reflect.TypeOf((*MockNodeCache)(nil).GetMemoryFootprint))
}</span>

// GetOrSet mocks base method.
func (m *MockNodeCache) GetOrSet(arg0 *NodeReference, arg1 *shared.Shared[Node]) (*shared.Shared[Node], bool, NodeId, *shared.Shared[Node], bool) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrSet", arg0, arg1)
        ret0, _ := ret[0].(*shared.Shared[Node])
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(NodeId)
        ret3, _ := ret[3].(*shared.Shared[Node])
        ret4, _ := ret[4].(bool)
        return ret0, ret1, ret2, ret3, ret4
}</span>

// GetOrSet indicates an expected call of GetOrSet.
func (mr *MockNodeCacheMockRecorder) GetOrSet(arg0, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrSet", reflect.TypeOf((*MockNodeCache)(nil).GetOrSet), arg0, arg1)
}</span>

// Release mocks base method.
func (m *MockNodeCache) Release(r *NodeReference) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Release", r)
}</span>

// Release indicates an expected call of Release.
func (mr *MockNodeCacheMockRecorder) Release(r any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockNodeCache)(nil).Release), r)
}</span>

// Touch mocks base method.
func (m *MockNodeCache) Touch(r *NodeReference) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Touch", r)
}</span>

// Touch indicates an expected call of Touch.
func (mr *MockNodeCacheMockRecorder) Touch(r any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockNodeCache)(nil).Touch), r)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "errors"
        "slices"
        "time"

        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
)

type nodeFlusher struct {
        shutdown chan&lt;- struct{}
        done     &lt;-chan struct{}
        errs     []error
}

type nodeFlusherConfig struct {
        period time.Duration // uses a default period if zero and disables flushing if negative
}

func startNodeFlusher(cache NodeCache, sink NodeSink, config nodeFlusherConfig) *nodeFlusher <span class="cov8" title="1">{

        shutdown := make(chan struct{})
        done := make(chan struct{})

        res := &amp;nodeFlusher{
                shutdown: shutdown,
                done:     done,
        }

        period := config.period
        if period == 0 </span><span class="cov8" title="1">{
                period = 5 * time.Second
        }</span>

        <span class="cov8" title="1">if period &gt; 0 </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        defer close(done)
                        ticker := time.NewTicker(period)
                        defer ticker.Stop()
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-shutdown:<span class="cov8" title="1">
                                        return</span>
                                case &lt;-ticker.C:<span class="cov8" title="1">
                                        if err := tryFlushDirtyNodes(cache, sink); err != nil </span><span class="cov8" title="1">{
                                                res.errs = append(res.errs, err)
                                        }</span>
                                }
                        }
                }()
        } else<span class="cov8" title="1"> {
                close(done)
        }</span>

        <span class="cov8" title="1">return res</span>
}

func (f *nodeFlusher) Stop() error <span class="cov8" title="1">{
        close(f.shutdown)
        &lt;-f.done
        return errors.Join(f.errs...)
}</span>

func tryFlushDirtyNodes(cache NodeCache, sink NodeSink) error <span class="cov8" title="1">{
        // Collect a list of dirty nodes to be flushed.
        dirtyIds := make([]NodeId, 0, 1_000_000)
        cache.ForEach(func(id NodeId, node *shared.Shared[Node]) </span><span class="cov8" title="1">{
                handle, success := node.TryGetViewHandle()
                if !success </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">dirty := handle.Get().IsDirty()
                handle.Release()
                if !dirty </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">dirtyIds = append(dirtyIds, id)</span>
        })

        // The IDs are sorted to increase the chance of sequential
        // writes to the disk.
        <span class="cov8" title="1">slices.Sort(dirtyIds)

        var errs []error
        for _, id := range dirtyIds </span><span class="cov8" title="1">{
                ref := NewNodeReference(id)
                node, success := cache.Get(&amp;ref)
                if !success </span><span class="cov8" title="1">{
                        continue</span>
                }

                // This service is a best-effort service. If the
                // node is in use right now, we skip the flush and
                // continue with the next node.
                <span class="cov8" title="1">handle, success := node.TryGetWriteHandle()
                if !success </span><span class="cov8" title="1">{
                        continue</span>
                }

                // If the node was cleaned otherwise, we can skip the flush.
                // The cleaning may have been conducted by the write buffer
                // or by releasing the node.
                <span class="cov8" title="1">if !handle.Get().IsDirty() </span><span class="cov8" title="1">{
                        handle.Release()
                        continue</span>
                }

                // Nodes with dirty hashes cannot be flushed.
                <span class="cov8" title="1">_, dirtyHash := handle.Get().GetHash()
                if dirtyHash </span><span class="cov8" title="1">{
                        handle.Release()
                        continue</span>
                }

                <span class="cov8" title="1">err := sink.Write(id, handle.AsViewHandle())
                if err == nil </span><span class="cov8" title="1">{
                        handle.Get().MarkClean()
                }</span>
                <span class="cov8" title="1">handle.Release()

                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "sync"

        "github.com/Fantom-foundation/Carmen/go/common"
)

// NodeHash is a utility type linking a path in an MPT to a hash. Its main
// use case is to transfer computed hashes from LiveDB instances to archives
// to avoid double-computation and thus improve efficiency.
type NodeHash struct {
        Path NodePath
        Hash common.Hash
}

// Equal returns true if the given NodeHash is the same as this one.
func (h *NodeHash) Equal(other *NodeHash) bool <span class="cov8" title="1">{
        return h == other || (h.Hash == other.Hash &amp;&amp; h.Path.Equal(other.Path))
}</span>

// NodeHashes provides a recyclable list of NodeHash instances. NodeHashes
// should be created using NewNodeHashes() and released by calling its Release
// method. It is not an error to fail to release an instance, but it may harm
// performance and increase memory usage temporarily.
type NodeHashes struct {
        hashes []NodeHash
}

// nodeHashPool is a pool for the repeated reuse of hash lists
var nodeHashPool = sync.Pool{New: func() any <span class="cov8" title="1">{
        return &amp;NodeHashes{hashes: make([]NodeHash, 0, 4096)}
}</span>,
}

// NewNodeHashes obtains an empty instance to be owned by the caller.
func NewNodeHashes() *NodeHashes <span class="cov8" title="1">{
        return nodeHashPool.Get().(*NodeHashes)
}</span>

// Add adds an entry to this node hash collection.
func (h *NodeHashes) Add(path NodePath, hash common.Hash) <span class="cov8" title="1">{
        h.hashes = append(h.hashes, NodeHash{path, hash})
}</span>

// GetHashes retains a (shared) view on the retained hashes.
func (h *NodeHashes) GetHashes() []NodeHash <span class="cov8" title="1">{
        return h.hashes
}</span>

// Release frees internal resources for future reuse and invalidates this object.
// Release must not be called more than once on a valid NodeHashes instance.
func (h *NodeHashes) Release() <span class="cov8" title="1">{
        h.hashes = h.hashes[:0]
        nodeHashPool.Put(h)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "encoding/binary"
        "fmt"
)

// NodeId is used to address nodes within tries. Each node ID encodes the type
// of node encoded (either empty, branch, extension, account, or value), and an
// index allowing different instances to be differentiated.
// NodeIds serve the same role as pointers in in-memory implementations of
// tries. They allow to reference one node from another.
//
// For efficiency, each NodeId is represented as a single, 64-bit value. The
// type of addressed node is encoded in the value using the following rules:
//
//   - the value is 0 ... empty node
//   - the value has a binary suffix of 0 ... branch node
//   - the value has a binary suffix of 01 ... value node
//   - the value has a binary suffix of 011 ... account node
//   - the value has a binary suffix of 111 ... extension node
//
// This allows to address 2^63 different branch nodes, 2^62 different values
// and 2^61 account and extension nodes, sufficient for any forseeable future.
type NodeId uint64

// EmptyId returns the node ID representing the empty node.
func EmptyId() NodeId <span class="cov8" title="1">{
        return NodeId(0)
}</span>

// BranchId returns the NodeID of the branch node with the given index.
func BranchId(index uint64) NodeId <span class="cov8" title="1">{
        return NodeId((index + 1) &lt;&lt; 1)
}</span>

// ExtensionId returns the NodeID of the extension node with the given index.
func ExtensionId(index uint64) NodeId <span class="cov8" title="1">{
        return NodeId((index &lt;&lt; 3) | 0b111)
}</span>

// AccountId returns the NodeID of the account node with the given index.
func AccountId(index uint64) NodeId <span class="cov8" title="1">{
        return NodeId((index &lt;&lt; 3) | 0b011)
}</span>

// ValueId returns the NodeID of the value node with the given index.
func ValueId(index uint64) NodeId <span class="cov8" title="1">{
        return NodeId((index &lt;&lt; 2) | 0b01)
}</span>

// IsEmpty is true if node n is addressing the empty node.
func (n NodeId) IsEmpty() bool <span class="cov8" title="1">{
        return n == 0
}</span>

// IsBranch is true if node n is addressing a branch node.
func (n NodeId) IsBranch() bool <span class="cov8" title="1">{
        return !n.IsEmpty() &amp;&amp; (n&amp;0b1 == 0b0)
}</span>

// IsExtension is true if node n is addressing an extension node.
func (n NodeId) IsExtension() bool <span class="cov8" title="1">{
        return n&amp;0b111 == 0b111
}</span>

// IsAccount is true if node n is addressing an account node.
func (n NodeId) IsAccount() bool <span class="cov8" title="1">{
        return n&amp;0b111 == 0b011
}</span>

// IsValue is true if node n is addressing a value node.
func (n NodeId) IsValue() bool <span class="cov8" title="1">{
        return n&amp;0b11 == 0b01
}</span>

// Index returns the index of the addressed node type.
func (n NodeId) Index() uint64 <span class="cov8" title="1">{
        if n.IsBranch() </span><span class="cov8" title="1">{
                return uint64(n&gt;&gt;1) - 1
        }</span>
        <span class="cov8" title="1">if n.IsValue() </span><span class="cov8" title="1">{
                return uint64(n &gt;&gt; 2)
        }</span>
        <span class="cov8" title="1">return uint64(n &gt;&gt; 3)</span>
}

func (n NodeId) String() string <span class="cov8" title="1">{
        if n.IsEmpty() </span><span class="cov8" title="1">{
                return "E"
        }</span>
        <span class="cov8" title="1">if n.IsAccount() </span><span class="cov8" title="1">{
                return fmt.Sprintf("A-%d", n.Index())
        }</span>
        <span class="cov8" title="1">if n.IsBranch() </span><span class="cov8" title="1">{
                return fmt.Sprintf("B-%d", n.Index())
        }</span>
        <span class="cov8" title="1">if n.IsExtension() </span><span class="cov8" title="1">{
                return fmt.Sprintf("E-%d", n.Index())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("V-%d", n.Index())</span>
}

// ----------------------------------------------------------------------------
//                               NodeId Encoder
// ----------------------------------------------------------------------------

// NodeIdEncoder encodes the internal 8-byte node IDs using a fixed-length
// 6-byte disk format ignoring the two most significant bytes which are always
// zero for any state DB bellow ~1PB.
type NodeIdEncoder struct{}

func (NodeIdEncoder) GetEncodedSize() int <span class="cov8" title="1">{
        return 6
}</span>

func (NodeIdEncoder) Store(dst []byte, id *NodeId) <span class="cov8" title="1">{
        var buffer [8]byte
        binary.BigEndian.PutUint64(buffer[:], uint64(*id))
        copy(dst, buffer[2:])
}</span>

func (NodeIdEncoder) Load(src []byte, id *NodeId) <span class="cov8" title="1">{
        var buffer [8]byte
        copy(buffer[2:], src)
        *id = NodeId(binary.BigEndian.Uint64(buffer[:]))
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "slices"
        "strings"
)

// NodePath is a simple navigation path into an MPT structure that can be used
// to effectively address nodes by their positions. Unlike Path instances,
// describing the path encoding the key value of some object stored in an MPT,
// this path merely addresses the navigation paths on a node bases. In
// particular, it ignores path sections introduced by extension nodes and does
// not terminate at the account node level.
type NodePath struct {
        path []Nibble
}

// EmptyPath creates an empty path addressing the root node of an MPT.
func EmptyPath() NodePath <span class="cov8" title="1">{
        return NodePath{}
}</span>

// CreateNodePath creates a path into a tree following the given nibbles. The
// Nibble given for navigation through an extension node or account node must
// be zero.
func CreateNodePath(steps ...Nibble) NodePath <span class="cov8" title="1">{
        return NodePath{steps}
}</span>

// Equal returns true if the given path is equal to this path.
func (p NodePath) Equal(o NodePath) bool <span class="cov8" title="1">{
        return slices.Equal(p.path, o.path)
}</span>

// Length returns the length of this path if valid. The result is undefined for
// invalid paths.
func (p NodePath) Length() int <span class="cov8" title="1">{
        return len(p.path)
}</span>

// Get returns the entry at the given position along the path. The result is
// undefined for invalid paths or if the position is out of range.
func (p NodePath) Get(pos byte) Nibble <span class="cov8" title="1">{
        return p.path[pos]
}</span>

// Next produces a path extending this path by one step, addressing a unique
// child of a node. This may be the next-node referenced by an extension or the
// storage referenced by an account.
func (p NodePath) Next() NodePath <span class="cov8" title="1">{
        return p.Child(0)
}</span>

// Child produces a path referencing a child node of the node addressed by the
// path p. To be meaningful, the node referenced by p must be a branch node.
func (p NodePath) Child(step Nibble) NodePath <span class="cov8" title="1">{
        res := make([]Nibble, len(p.path)+1)
        copy(res, p.path)
        res[len(p.path)] = step
        return NodePath{res}
}</span>

func (p NodePath) String() string <span class="cov8" title="1">{
        var builder strings.Builder
        builder.WriteRune('[')
        for i := 0; i &lt; p.Length(); i++ </span><span class="cov8" title="1">{
                if i != 0 </span><span class="cov8" title="1">{
                        builder.WriteRune(',')
                }</span>
                <span class="cov8" title="1">builder.WriteString(p.Get(byte(i)).String())</span>
        }
        <span class="cov8" title="1">builder.WriteRune(']')
        return builder.String()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

//go:generate mockgen -source nodes.go -destination nodes_mocks.go -package mpt

import (
        "encoding/binary"
        "errors"
        "fmt"
        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/common/tribool"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        "io"
        "slices"
)

// This file defines the interface and implementation of all node types in a
// Merkle Patricia Tries (MPT). There are five different types of nodes:
//
//  - empty nodes     ... the root node of empty sub-tries
//  - branch nodes    ... inner trie nodes splitting navigation paths
//  - extension nodes ... shortcuts for long-sequences of 1-child branches
//  - account nodes   ... mid-level nodes reached after consuming an address
//                        path storing account information and being the root
//                        of the account's storage trie. It can be considered
//                        the leaf nodes of the state trie and the root of the
//                        per-account storage tries.
//  - value nodes     ... leaf-level nodes reached after consuming a key path
//                        rooted by an account's storage root node.
//
// All nodes implement a common interface as defined below. Besides allowing
// the encoding of account and storage information in the node structure, nodes
// can also be frozen or released. Frozen nodes can no longer be modified and
// subsequent modifications cause modifications to be applied on a clone of the
// targeted node. Releasing nodes frees up allocated resources for itself and
// all nodes in the sub-tree rooted by the released node.
//
// To address nodes during navigation, NodeIds are used.
//
// Nodes are designed to be used in Forests, which is a multi-rooted extension
// of trees. Thus, individual nodes may be part of multiple trees induced by
// different root nodes in the forest. Tree-shaped MPTs are a special case of
// a forest with a single root. To avoid unwanted side-effects, all nodes
// shared as part of multiple trees should be frozen before being shared.

// Node defines an interface for all nodes in the MPT.
type Node interface {
        // GetAccount retrieves the account information associated to a given
        // account. All non-covered accounts have the implicit empty-info
        // associated.
        // The function requires the following parameters:
        //  - source  ... providing abstract access to resolving other nodes
        //  - address ... the address of the account to be located
        //  - path    ... the remaining path to be navigated to reach the account
        // The following results are produced:
        //  - info    ... the value associated to the key or zero
        //  - exists  ... true if the value is present, false otherwise
        //  - err     ... if the resolution of some node failed
        // This function is only supported for nodes in the MPT located between
        // the root node and an AccountNode.
        GetAccount(source NodeSource, address common.Address, path []Nibble) (info AccountInfo, exists bool, err error)

        // SetAccount updates the AccountInformation associated to a given
        // address in this trie. If the new AccountInfo is empty, the
        // account and all its storage is deleted.
        // The function requires the following parameters:
        //  - manager ... to look-up, create, and release nodes
        //  - thisId  ... the NodeID of the node this function has been called on
        //  - address ... the Address of the account to be updated
        //  - path    ... the remaining path to be navigated to reach the account
        //  - info    ... the new information to be assigned to the account
        // The following results are produced:
        //  - newRoot ... the new root of the sub-trie after the update (it may no
        //                longer be thisId and callers need to react accordingly)
        //  - changed ... true if the content of the sub-trie has changed and, for
        //                instance, the node's hash needs to be updated
        //  - err     ... if resolving, creating, or releasing nodes failed at some
        //                point during the update.
        // This function is only supported for nodes in the MPT located between
        // the root node and an AccountNode.
        SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (newRoot NodeReference, changed bool, err error)

        // GetValue retrieves a value associated to a key in the storage trie
        // associated to an account in an MPT. All non-covered locations have the
        // implicit zero value.
        // The function requires the following parameters:
        //  - source  ... providing abstract access to resolving other nodes
        //  - key     ... the key of the value to be located
        //  - path    ... the remaining path to be navigated to reach the value
        // The following results are produced:
        //  - value   ... the value associated to the key or zero
        //  - exists  ... true if the value is present, false otherwise
        //  - err     ... if the resolution of some node failed
        // This function is only supported for nodes in the MPT located in a
        // storage trie rooted by an AccountNode.
        GetValue(source NodeSource, key common.Key, path []Nibble) (value common.Value, exists bool, err error)

        // SetValue updates the value associated to a given key in the storage
        // trie associated to an account in an MPT. If the new value is zero the
        // path reaching the value is removed from the MPT.
        // The function requires the following parameters:
        //  - manager ... to look-up, create, and release nodes
        //  - thisId  ... the NodeID of the node this function has been called on
        //  - key     ... the key of the value to be updated
        //  - path    ... the remaining path to be navigated to reach the value
        //  - value    ... the new value to be assigned with the key
        // The following results are produced:
        //  - newRoot ... the new root of the sub-trie after the update (it may no
        //                longer be thisId and callers need to react accordingly)
        //  - changed ... true if the content of the sub-trie has changed and, for
        //                instance, the node's hash needs to be updated
        //  - err     ... if resolving, creating, or releasing nodes failed at some
        //                point during the update.
        // This function is only supported for nodes in the MPT located in a
        // storage trie rooted by an AccountNode.
        SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (newRoot NodeReference, changed bool, err error)

        // GetSlot retrieves a value of a slot addressed by a given key being part
        // of a given account. It is a combination of GetAccount() followed by
        // GetValue().
        // The function requires the following parameters:
        //  - source  ... providing abstract access to resolving other nodes
        //  - address ... the Address of the account to be updated
        //  - key     ... the key of the value to be located
        //  - path    ... the remaining path to be navigated to reach the account
        //                or, if already passed, the value
        // The following results are produced:
        //  - value   ... the value associated to the key or zero
        //  - exists  ... true if the value is present, false otherwise
        //  - err     ... if the resolution of some node failed
        // This function is only supported for nodes in the MPT located between
        // the root node and an AccountNode.
        GetSlot(source NodeSource, address common.Address, path []Nibble, key common.Key) (value common.Value, exists bool, err error)

        // SetSlot updates a value of a slot addressed by a given key being part
        // of a given account. It is a combination of GetAccount() followed by
        // SetValue().
        // The function requires the following parameters:
        //  - manager ... to look-up, create, and release nodes
        //  - thisId  ... the NodeID of the node this function has been called on
        //  - address ... the Address of the account to be updated
        //  - key     ... the key of the value to be updated
        //  - path    ... the remaining path to be navigated to reach the account
        //                or, if already passed, the value
        //  - value   ... the new value to be assigned with the key
        // The following results are produced:
        //  - newRoot ... the new root of the sub-trie after the update (it may no
        //                longer be thisId and callers need to react accordingly)
        //  - changed ... true if the content of the sub-trie has changed and, for
        //                instance, the node's hash needs to be updated
        //  - err     ... if resolving, creating, or releasing nodes failed at some
        //                point during the update.
        // This function is only supported for nodes in the MPT located between
        // the root node and an AccountNode.
        SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (newRoot NodeReference, changed bool, err error)

        // ClearStorage deletes the entire storage associated to an account. For
        // parameter information and return values see SetValue().
        ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (newRoot NodeReference, changed bool, err error)

        // Release releases this node and all non-frozen nodes in the sub-tree
        // rooted by this node. Only non-frozen nodes can be released.
        Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error

        // IsDirty returns whether this node's state is different in memory than it
        // is on disk. All nodes are created dirty and may only be cleaned by marking
        // them as such.
        IsDirty() bool

        // MarkClean marks this node as clean. This function should be called when an
        // in memory version of a node got synced with its on-disk copy.
        MarkClean()

        // GetHash obtains the potentially dirty hash currently retained for this node.
        GetHash() (hash common.Hash, dirty bool)

        // SetHash updates this nodes hash.
        SetHash(common.Hash)

        // IsFrozen indicates whether the given node is frozen or not.
        IsFrozen() bool

        // Freeze freezes this node and the entire sub-tree induced by it. After
        // freezing the node it can no longer be modified or released.
        Freeze(manager NodeManager, this shared.WriteHandle[Node]) error

        // MarkFrozen marks the current node as frozen, without freezing the
        // sub-tree. This might be used when loading frozen nodes from secondary
        // storage.
        MarkFrozen()

        // Check verifies internal invariants of this node. It is mainly intended
        // to validate invariants in unit tests and for issue diagnostics.
        Check(source NodeSource, thisRef *NodeReference, path []Nibble) error

        // Dump dumps this node and its sub-trees to the console. It is mainly
        // intended for debugging and may be very costly for larger instances.
        Dump(dest io.Writer, source NodeSource, thisRef *NodeReference, indent string) error

        // Visit visits this and all nodes in the respective sub-tree. The
        // visitor is called by each encountered node, with the proper NodeInfo
        // set. Visiting aborts if the visitor returns or prune sub-tree as
        // requested by the visitor. The function returns whether the visiting
        // process has been aborted and/or an error occurred.
        Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (abort bool, err error)
}

// NodeSource is an interface for any object capable of resolving NodeIds into
// Nodes. It is intended to be implemented by a Node-governing component
// handling the life-cycle of nodes and loading/storing nodes to persistent
// storage. It also serves as a central source for trie configuration flags.
type NodeSource interface {
        getConfig() MptConfig
        getReadAccess(*NodeReference) (shared.ReadHandle[Node], error)
        getViewAccess(*NodeReference) (shared.ViewHandle[Node], error)
        getHashFor(*NodeReference) (common.Hash, error)
        hashKey(common.Key) common.Hash
        hashAddress(address common.Address) common.Hash
}

// NodeManager is a mutable extension of a NodeSource enabling the creation,
// update, invalidation, and releasing of nodes.
type NodeManager interface {
        NodeSource

        getHashAccess(*NodeReference) (shared.HashHandle[Node], error)
        getWriteAccess(*NodeReference) (shared.WriteHandle[Node], error)

        createAccount() (NodeReference, shared.WriteHandle[Node], error)
        createBranch() (NodeReference, shared.WriteHandle[Node], error)
        createExtension() (NodeReference, shared.WriteHandle[Node], error)
        createValue() (NodeReference, shared.WriteHandle[Node], error)

        release(*NodeReference) error
        releaseTrieAsynchronous(NodeReference)
}

// ----------------------------------------------------------------------------
//                               Utilities
// ----------------------------------------------------------------------------

// VisitPathToStorage visits all nodes from the input storage root following the input storage key.
// Each encountered node is passed to the visitor.
// If no more nodes are available on the path, the execution ends.
// If the key does not exist, the function returns false.
// The function returns an error if the path cannot be iterated due to error propagated from the node source.
// Nodes provided via the visitor are made available with the view privilege.
func VisitPathToStorage(source NodeSource, storageRoot *NodeReference, key common.Key, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        path := KeyToNibblePath(key, source)
        return visitPathTo(source, storageRoot, path, nil, &amp;key, visitor)
}</span>

// VisitPathToAccount visits all nodes from the input root following the input account address.
// Each encountered node is passed to the visitor.
// If no more nodes are available on the path, the execution ends.
// If the account address does not exist, the function returns false.
// The function returns an error if the path cannot be iterated due to error propagated from the node source.
// Nodes provided via the visitor are made available with the view privilege.
func VisitPathToAccount(source NodeSource, root *NodeReference, address common.Address, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        path := AddressToNibblePath(address, source)
        return visitPathTo(source, root, path, &amp;address, nil, visitor)
}</span>

// visitPathTo visits all nodes from the input root following the input path.
// Each encountered node is passed to the visitor.
// If no more nodes are available on the path, the execution ends.
// If the path does not exist, the function returns false.
// The function returns an error if the path cannot be iterated due to error propagated from the node source.
// When the function reaches either an account node or a value node it is compared to the input address or key.
// If either the address or key matches the node, this function terminates.
// It means this function can be used to find either an account node or a value node,
// but it cannot find both at the same time.
func visitPathTo(source NodeSource, root *NodeReference, path []Nibble, address *common.Address, key *common.Key, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        nodeId := root

        var last shared.ViewHandle[Node]
        var found, done bool
        var lastNodeId *NodeReference
        var nextEmbedded, currentEmbedded bool
        for !done </span><span class="cov8" title="1">{
                handle, err := source.getViewAccess(nodeId)
                if last.Valid() </span><span class="cov8" title="1">{
                        last.Release()
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">last = handle
                lastNodeId = nodeId
                node := handle.Get()

                switch n := node.(type) </span>{
                case *ExtensionNode:<span class="cov8" title="1">
                        if n.path.IsPrefixOf(path) </span><span class="cov8" title="1">{
                                nodeId = &amp;n.next
                                path = path[n.path.Length():]
                                nextEmbedded = n.nextIsEmbedded
                                done = len(path) == 0
                        }</span> else<span class="cov8" title="1"> {
                                done = true
                        }</span>
                case *BranchNode:<span class="cov8" title="1">
                        if len(path) == 0 </span><span class="cov8" title="1">{
                                done = true
                        }</span> else<span class="cov8" title="1"> {
                                nodeId = &amp;n.children[path[0]]
                                nextEmbedded = n.isEmbedded(byte(path[0]))
                                path = path[1:]
                        }</span>
                case *AccountNode:<span class="cov8" title="1">
                        if address != nil &amp;&amp; n.address == *address </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                        <span class="cov8" title="1">done = true</span>
                case *ValueNode:<span class="cov8" title="1">
                        if key != nil &amp;&amp; n.key == *key </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                        <span class="cov8" title="1">done = true</span>
                default:<span class="cov8" title="1">
                        last.Release()
                        return false, nil</span>
                }

                <span class="cov8" title="1">if res := visitor.Visit(last.Get(), NodeInfo{Id: lastNodeId.Id(), Embedded: tribool.New(currentEmbedded)}); res != VisitResponseContinue </span><span class="cov8" title="1">{
                        done = true
                }</span>
                <span class="cov8" title="1">currentEmbedded = nextEmbedded</span>
        }

        <span class="cov8" title="1">last.Release()
        return found, nil</span>
}

// CheckForest evaluates invariants throughout all nodes reachable from the
// given list of roots. Executed checks include node-specific checks like the
// minimum number of child nodes of a BranchNode, the correct placement of
// nodes within the forest, and the absence of zero values. The function also
// checks the proper sharing of nodes in multiple tries rooted by different
// nodes. A reuse is only valid if the node's position within the respective
// tries is compatible -- thus, the node is reachable through the same
// navigation path.
func CheckForest(source NodeSource, roots []*NodeReference) error <span class="cov8" title="1">{
        // The check algorithm is based on an iterative depth-first traversal
        // where information on encountered nodes is cached to avoid multiple
        // evaluations.
        workList := []NodeId{}
        contexts := map[NodeId]nodeCheckContext{}
        for _, ref := range roots </span><span class="cov8" title="1">{
                workList = append(workList, ref.Id())
                contexts[ref.Id()] = nodeCheckContext{
                        root:           ref.Id(),
                        hasSeenAccount: false,
                        path:           nil,
                }
        }</span>

        // scheduleNode verifies that the given node is reached consistently
        // with earlier encounters or schedules the node for future checks
        // if this is the first time a path to this node was discovered.
        <span class="cov8" title="1">scheduleNode := func(ref *NodeReference, root NodeId, accountSeen bool, path []Nibble) error </span><span class="cov8" title="1">{
                context := nodeCheckContext{
                        root:           root,
                        hasSeenAccount: accountSeen,
                        path:           path,
                }
                previous, found := contexts[ref.Id()]
                if found </span><span class="cov8" title="1">{
                        if !context.isCompatible(&amp;previous) </span><span class="cov8" title="1">{
                                return fmt.Errorf(
                                        "invalid reuse of node %v: reachable from %v through %v and from %v through %v",
                                        ref.Id(), previous.root, previous.path, context.root, context.path,
                                )
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                } else<span class="cov8" title="1"> {
                        contexts[ref.Id()] = context
                }</span>
                <span class="cov8" title="1">workList = append(workList, ref.Id())
                return nil</span>
        }

        <span class="cov8" title="1">count := 0
        for len(workList) &gt; 0 </span><span class="cov8" title="1">{
                curId := workList[len(workList)-1]
                workList = workList[:len(workList)-1]

                // TODO [cleanup]: replace this by an observer
                count++
                if count%100000 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Checking %v (%d), |ws| = %d, |contexts| = %d\n", curId, count, len(workList), len(contexts))
                }</span>

                <span class="cov8" title="1">context := contexts[curId]
                curNodeRef := NewNodeReference(curId)
                handle, err := source.getViewAccess(&amp;curNodeRef)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">node := handle.Get()
                err = node.Check(source, &amp;curNodeRef, context.path)
                if err != nil </span><span class="cov8" title="1">{
                        handle.Release()
                        return err
                }</span>

                // schedule child nodes to be checked
                <span class="cov8" title="1">switch cur := node.(type) </span>{
                case EmptyNode:<span class="cov8" title="1"></span>
                        // terminal node without children
                case *AccountNode:<span class="cov8" title="1">
                        storage := cur.storage
                        if !storage.id.IsEmpty() </span><span class="cov8" title="1">{
                                err = scheduleNode(&amp;storage, context.root, true, nil)
                        }</span>
                case *BranchNode:<span class="cov8" title="1">
                        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                                child := cur.children[i]
                                if !child.id.IsEmpty() </span><span class="cov8" title="1">{
                                        path := make([]Nibble, len(context.path)+1)
                                        copy(path, context.path)
                                        path[len(context.path)] = Nibble(i)
                                        if err = scheduleNode(&amp;child, context.root, context.hasSeenAccount, path); err != nil </span><span class="cov8" title="1">{
                                                break</span>
                                        }
                                }
                        }
                case *ExtensionNode:<span class="cov8" title="1">
                        next := cur.next
                        if !next.id.IsEmpty() </span><span class="cov8" title="1">{
                                path := make([]Nibble, len(context.path), len(context.path)+cur.path.Length())
                                copy(path, context.path)
                                for i := 0; i &lt; cur.path.Length(); i++ </span><span class="cov8" title="1">{
                                        path = append(path, cur.path.Get(i))
                                }</span>
                                <span class="cov8" title="1">err = scheduleNode(&amp;next, context.root, context.hasSeenAccount, path)</span>
                        }
                case *ValueNode:<span class="cov8" title="1">
                        // terminal node without children
                        if !context.hasSeenAccount </span><span class="cov8" title="1">{
                                err = fmt.Errorf("value node %v is reachable without passing an account", curNodeRef.Id())
                        }</span>
                }

                <span class="cov8" title="1">handle.Release()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type nodeCheckContext struct {
        root           NodeId
        path           []Nibble
        hasSeenAccount bool
}

func (c *nodeCheckContext) isCompatible(other *nodeCheckContext) bool <span class="cov8" title="1">{
        return c.hasSeenAccount == other.hasSeenAccount &amp;&amp; slices.Equal(c.path, other.path)
}</span>

// nodeBase is an optional common base type for nodes.
type nodeBase struct {
        hash       common.Hash // the hash of this node (may be dirty)
        hashStatus hashStatus  // indicating whether this node's hash is valid
        clean      bool        // by default nodes are dirty (clean == false)
        frozen     bool        // a flag marking the node as immutable (default: mutable)
}

type hashStatus byte

const (
        hashStatusClean   hashStatus = 0 // the hash is up-to-date, matching the nodes content
        hashStatusDirty   hashStatus = 1 // the hash is out-of-date and needs to be refreshed
        hashStatusUnknown hashStatus = 2 // the hash is missing / invalid
)

func (s hashStatus) String() string <span class="cov8" title="1">{
        switch s </span>{
        case hashStatusClean:<span class="cov8" title="1">
                return "clean"</span>
        case hashStatusDirty:<span class="cov8" title="1">
                return "dirty"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

func (n *nodeBase) GetHash() (common.Hash, bool) <span class="cov8" title="1">{
        return n.hash, n.hashStatus != hashStatusClean
}</span>

func (n *nodeBase) SetHash(hash common.Hash) <span class="cov8" title="1">{
        n.hash = hash
        n.hashStatus = hashStatusClean
}</span>

func (n *nodeBase) hasCleanHash() bool <span class="cov8" title="1">{
        return n.hashStatus == hashStatusClean
}</span>

func (n *nodeBase) getHashStatus() hashStatus <span class="cov8" title="1">{
        return n.hashStatus
}</span>

func (n *nodeBase) IsFrozen() bool <span class="cov8" title="1">{
        return n.frozen
}</span>

func (n *nodeBase) MarkFrozen() <span class="cov8" title="1">{
        n.frozen = true
}</span>

func (n *nodeBase) markMutable() <span class="cov8" title="1">{
        n.frozen = false
}</span>

func (n *nodeBase) IsDirty() bool <span class="cov8" title="1">{
        return !n.clean
}</span>

func (n *nodeBase) MarkClean() <span class="cov8" title="1">{
        n.clean = true
}</span>

func (n *nodeBase) markDirty() <span class="cov8" title="1">{
        n.clean = false
        n.hashStatus = hashStatusDirty
}</span>

func (n *nodeBase) Release() <span class="cov8" title="1">{
        // The node is disconnected from the disk version and thus clean.
        n.clean = true
        n.hashStatus = hashStatusClean
}</span>

func (n *nodeBase) check(thisRef *NodeReference) error <span class="cov8" title="1">{
        var errs []error
        if !n.IsDirty() &amp;&amp; n.hashStatus == hashStatusDirty </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v is marked clean but hash is dirty", thisRef.Id()))
        }</span>
        <span class="cov8" title="1">if n.IsDirty() &amp;&amp; n.hashStatus == hashStatusUnknown </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v is marked dirty but hash is marked unknown (should be dirty or clean)", thisRef.Id()))
        }</span>
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

// ----------------------------------------------------------------------------
//                               Empty Node
// ----------------------------------------------------------------------------

// EmptyNode is the node type used to represent an empty sub-trie. Empty nodes
// have no state and can thus not be modified. Any modification results in the
// creation of new nodes representing the new state.
type EmptyNode struct{}

func (EmptyNode) GetAccount(source NodeSource, address common.Address, path []Nibble) (AccountInfo, bool, error) <span class="cov8" title="1">{
        return AccountInfo{}, false, nil
}</span>

func (EmptyNode) GetValue(NodeSource, common.Key, []Nibble) (common.Value, bool, error) <span class="cov8" title="1">{
        return common.Value{}, false, nil
}</span>

func (EmptyNode) GetSlot(NodeSource, common.Address, []Nibble, common.Key) (common.Value, bool, error) <span class="cov8" title="1">{
        return common.Value{}, false, nil
}</span>

func (e EmptyNode) SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (NodeReference, bool, error) <span class="cov8" title="1">{
        if info.IsEmpty() </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>
        <span class="cov8" title="1">ref, handle, err := manager.createAccount()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        res := handle.Get().(*AccountNode)
        res.markDirty()
        res.address = address
        res.info = info
        res.pathLength = byte(len(path))
        return ref, false, nil</span>
}

func (e EmptyNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        if value == (common.Value{}) </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>
        <span class="cov8" title="1">ref, handle, err := manager.createValue()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        res := handle.Get().(*ValueNode)
        res.key = key
        res.value = value
        res.markDirty()
        res.pathLength = byte(len(path))
        return ref, true, nil</span>
}

func (e EmptyNode) SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        // We can stop here, since the account does not exist and it should not
        // be implicitly created by setting a value.
        // Note: this function can only be reached while looking for the account.
        // Once the account is reached, the SetValue(..) function is used.
        return *thisRef, false, nil
}</span>

func (e EmptyNode) ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (newRoot NodeReference, changed bool, err error) <span class="cov8" title="1">{
        return *thisRef, false, nil
}</span>

func (e EmptyNode) Release(NodeManager, *NodeReference, shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        return nil
}</span>

func (e EmptyNode) IsDirty() bool <span class="cov8" title="1">{
        return false
}</span>

func (e EmptyNode) MarkClean() {<span class="cov8" title="1">}</span>

func (e EmptyNode) GetHash() (common.Hash, bool) <span class="cov8" title="1">{
        // The hash of an empty node should be defined by the hash algorithm as
        // a constant, and not stored in an empty node instance. Thus, the empty
        // node is not required to store a hash and if asked for it, it is always
        // appearing as to have a dirty hash.
        return common.Hash{}, true
}</span>

func (e EmptyNode) SetHash(common.Hash) {<span class="cov8" title="1"> /* ignored */ }</span>

func (e EmptyNode) IsFrozen() bool <span class="cov8" title="1">{
        return true
}</span>

func (e EmptyNode) MarkFrozen() {<span class="cov8" title="1">}</span>

func (e EmptyNode) Freeze(NodeManager, shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        // empty nodes are always frozen
        return nil
}</span>

func (EmptyNode) Check(NodeSource, *NodeReference, []Nibble) error <span class="cov8" title="1">{
        // No invariants to be checked.
        return nil
}</span>

func (EmptyNode) Dump(out io.Writer, _ NodeSource, thisRef *NodeReference, indent string) error <span class="cov8" title="1">{
        fmt.Fprintf(out, "%s-empty- (ID: %v)\n", indent, thisRef.Id())
        return nil
}</span>

func (EmptyNode) Visit(_ NodeSource, ref *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        return visitor.Visit(EmptyNode{}, NodeInfo{Id: ref.Id(), Depth: &amp;depth}) == VisitResponseAbort, nil
}</span>

// ----------------------------------------------------------------------------
//                               Branch Node
// ----------------------------------------------------------------------------

// BranchNode implements a node consuming one Nibble along the path from the
// root to a leaf node in a trie. The Nibble is used to select one out of 16
// potential child nodes. Each BranchNode has at least 2 non-empty children.
type BranchNode struct {
        nodeBase
        children         [16]NodeReference // the ID of child nodes
        hashes           [16]common.Hash   // the hashes of child nodes
        dirtyHashes      uint16            // a bit mask marking hashes as dirty; 0 .. clean, 1 .. dirty
        embeddedChildren uint16            // a bit mask marking children as embedded; 0 .. not, 1 .. embedded
        frozenChildren   uint16            // a bit mask marking frozen children; not persisted
}

func (n *BranchNode) getNextNodeInBranch(
        source NodeSource,
        path []Nibble,
) (shared.ReadHandle[Node], []Nibble, error) <span class="cov8" title="1">{
        next := &amp;n.children[path[0]]
        node, err := source.getReadAccess(next)
        if err != nil </span><span class="cov8" title="1">{
                return shared.ReadHandle[Node]{}, nil, err
        }</span>
        <span class="cov8" title="1">return node, path[1:], err</span>
}

func (n *BranchNode) GetAccount(source NodeSource, address common.Address, path []Nibble) (AccountInfo, bool, error) <span class="cov8" title="1">{
        next, subPath, err := n.getNextNodeInBranch(source, path)
        if err != nil </span><span class="cov8" title="1">{
                return AccountInfo{}, false, err
        }</span>
        <span class="cov8" title="1">defer next.Release()
        return next.Get().GetAccount(source, address, subPath)</span>
}

func (n *BranchNode) GetValue(source NodeSource, key common.Key, path []Nibble) (common.Value, bool, error) <span class="cov8" title="1">{
        next, subPath, err := n.getNextNodeInBranch(source, path)
        if err != nil </span><span class="cov8" title="1">{
                return common.Value{}, false, err
        }</span>
        <span class="cov8" title="1">defer next.Release()
        return next.Get().GetValue(source, key, subPath)</span>
}

func (n *BranchNode) GetSlot(source NodeSource, address common.Address, path []Nibble, key common.Key) (common.Value, bool, error) <span class="cov8" title="1">{
        next, subPath, err := n.getNextNodeInBranch(source, path)
        if err != nil </span><span class="cov8" title="1">{
                return common.Value{}, false, err
        }</span>
        <span class="cov8" title="1">defer next.Release()
        return next.Get().GetSlot(source, address, subPath, key)</span>
}

func (n *BranchNode) setNextNode(
        manager NodeManager,
        thisRef *NodeReference,
        this shared.WriteHandle[Node],
        path []Nibble,
        createSubTree func(*NodeReference, shared.WriteHandle[Node], []Nibble) (NodeReference, bool, error),
) (NodeReference, bool, error) <span class="cov8" title="1">{
        // Forward call to child node.
        child := &amp;n.children[path[0]]
        node, err := manager.getWriteAccess(child)
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">newRoot, hasChanged, err := createSubTree(child, node, path[1:])
        node.Release()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>

        <span class="cov8" title="1">if newRoot.Id() == child.Id() </span><span class="cov8" title="1">{
                if hasChanged </span><span class="cov8" title="1">{
                        n.markDirty()
                        n.markChildHashDirty(byte(path[0]))
                }</span>
                <span class="cov8" title="1">return *thisRef, hasChanged, nil</span>
        }

        // If frozen, clone the current node and modify copy.
        <span class="cov8" title="1">isClone := false
        if n.IsFrozen() </span><span class="cov8" title="1">{
                newRef, handle, err := manager.createBranch()
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, false, err
                }</span>
                <span class="cov8" title="1">defer handle.Release()
                newNode := handle.Get().(*BranchNode)
                *newNode = *n
                newNode.markDirty()
                newNode.markMutable()
                n = newNode
                thisRef = &amp;newRef
                isClone = true</span>
        }

        <span class="cov8" title="1">wasEmpty := child.Id().IsEmpty()
        n.children[path[0]] = newRoot
        n.markChildHashDirty(byte(path[0]))
        n.setChildFrozen(byte(path[0]), false)

        // If a branch got removed, check that there are enough children left.
        if !wasEmpty &amp;&amp; newRoot.Id().IsEmpty() </span><span class="cov8" title="1">{
                n.markChildHashClean(byte(path[0]))
                count := 0
                var remainingPos Nibble
                var remaining NodeReference
                for i, cur := range n.children </span><span class="cov8" title="1">{
                        if !cur.Id().IsEmpty() </span><span class="cov8" title="1">{
                                count++
                                if count &gt; 1 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">remainingPos = Nibble(i)
                                remaining = cur</span>
                        }
                }
                <span class="cov8" title="1">if count &lt; 2 </span><span class="cov8" title="1">{
                        newRoot := remaining
                        // This branch became obsolete and needs to be removed.
                        if remaining.Id().IsExtension() </span><span class="cov8" title="1">{
                                // The present extension can be extended.
                                extension, err := manager.getWriteAccess(&amp;remaining)
                                if err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>
                                <span class="cov8" title="1">defer extension.Release()
                                extensionNode := extension.Get().(*ExtensionNode)

                                // If the extension is frozen, we need to modify a copy.
                                if extensionNode.IsFrozen() </span><span class="cov8" title="1">{
                                        copyId, handle, err := manager.createExtension()
                                        if err != nil </span><span class="cov8" title="1">{
                                                return NodeReference{}, false, err
                                        }</span>
                                        <span class="cov8" title="1">defer handle.Release()
                                        copy := handle.Get().(*ExtensionNode)
                                        *copy = *extensionNode
                                        copy.markMutable()
                                        extensionNode = copy
                                        remaining = copyId
                                        newRoot = copyId</span>
                                }

                                <span class="cov8" title="1">extensionNode.path.Prepend(remainingPos)
                                extensionNode.markDirty()</span>
                        } else<span class="cov8" title="1"> if remaining.Id().IsBranch() </span><span class="cov8" title="1">{
                                // An extension needs to replace this branch.
                                extensionRef, handle, err := manager.createExtension()
                                if err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>
                                <span class="cov8" title="1">defer handle.Release()
                                extension := handle.Get().(*ExtensionNode)
                                extension.path = SingleStepPath(remainingPos)
                                extension.next = remaining
                                extension.nextHashDirty = n.isChildHashDirty(byte(remainingPos))
                                if !extension.nextHashDirty </span><span class="cov8" title="1">{
                                        extension.nextIsEmbedded = n.isEmbedded(byte(remainingPos))
                                        extension.nextHash = n.hashes[byte(remainingPos)]
                                }</span>
                                <span class="cov8" title="1">extension.markDirty()
                                newRoot = extensionRef</span>
                        } else<span class="cov8" title="1"> if manager.getConfig().TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                                // If suffix lengths need to be tracked, leaf nodes require an update.
                                if remaining.Id().IsAccount() </span><span class="cov8" title="1">{
                                        handle, err := manager.getWriteAccess(&amp;remaining)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return NodeReference{}, false, err
                                        }</span>
                                        <span class="cov8" title="1">newRoot, _, err = handle.Get().(*AccountNode).setPathLength(manager, &amp;remaining, handle, byte(len(path)))
                                        handle.Release()
                                        if err != nil </span><span class="cov8" title="1">{
                                                return NodeReference{}, false, err
                                        }</span>
                                } else<span class="cov8" title="1"> if remaining.Id().IsValue() </span><span class="cov8" title="1">{
                                        handle, err := manager.getWriteAccess(&amp;remaining)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return NodeReference{}, false, err
                                        }</span>
                                        <span class="cov8" title="1">newRoot, _, err = handle.Get().(*ValueNode).setPathLength(manager, &amp;remaining, handle, byte(len(path)))
                                        handle.Release()
                                        if err != nil </span><span class="cov8" title="1">{
                                                return NodeReference{}, false, err
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">n.nodeBase.Release()
                        return newRoot, !isClone, manager.release(thisRef)</span>
                }
        }

        <span class="cov8" title="1">n.markDirty()
        return *thisRef, !isClone, err</span>
}

func (n *BranchNode) SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (NodeReference, bool, error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, this, path,
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().SetAccount(manager, next, node, address, path, info)
                }</span>,
        )
}

func (n *BranchNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, this, path,
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().SetValue(manager, next, node, key, path, value)
                }</span>,
        )
}

func (n *BranchNode) SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, this, path,
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().SetSlot(manager, next, node, address, path, key, value)
                }</span>,
        )
}

func (n *BranchNode) ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (newRoot NodeReference, changed bool, err error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, this, path,
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().ClearStorage(manager, next, node, address, path)
                }</span>,
        )
}

func (n *BranchNode) Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.nodeBase.Release()
        for _, cur := range n.children </span><span class="cov8" title="1">{
                if !cur.Id().IsEmpty() </span><span class="cov8" title="1">{
                        handle, err := manager.getWriteAccess(&amp;cur)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = handle.Get().Release(manager, &amp;cur, handle)
                        handle.Release()
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return manager.release(thisRef)</span>
}

func (n *BranchNode) MarkFrozen() <span class="cov8" title="1">{
        n.nodeBase.MarkFrozen()
        n.frozenChildren = ^uint16(0)
}</span>

func (n *BranchNode) Freeze(manager NodeManager, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.nodeBase.MarkFrozen()
        for i := 0; i &lt; len(n.children); i++ </span><span class="cov8" title="1">{
                if n.children[i].Id().IsEmpty() || n.isChildFrozen(byte(i)) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">handle, err := manager.getWriteAccess(&amp;n.children[i])
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">err = handle.Get().Freeze(manager, handle)
                handle.Release()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">n.setChildFrozen(byte(i), true)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (n *BranchNode) Check(source NodeSource, thisRef *NodeReference, _ []Nibble) error <span class="cov8" title="1">{
        // Checked invariants:
        //  - must have 2+ children
        //  - non-dirty hashes for child nodes are valid
        //  - mask of frozen children is consistent
        numChildren := 0
        var errs []error

        if err := n.nodeBase.check(thisRef); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, err)
        }</span>

        <span class="cov8" title="1">hashWithParent := source.getConfig().HashStorageLocation == HashStoredWithParent
        if hashWithParent &amp;&amp; n.hasCleanHash() &amp;&amp; n.dirtyHashes != 0 </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v is has clean hash but child hashes are dirty: %016b", thisRef.Id(), n.dirtyHashes))
        }</span>

        <span class="cov8" title="1">for i, child := range n.children </span><span class="cov8" title="1">{
                if child.Id().IsEmpty() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">numChildren++
                if !n.isChildHashDirty(byte(i)) &amp;&amp; !n.isEmbedded(byte(i)) </span><span class="cov8" title="1">{
                        want, err := source.getHashFor(&amp;child)
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                        }</span> else<span class="cov8" title="1"> if got := n.hashes[i]; want != got </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("in node %v the hash for child %d is invalid\nwant: %v\ngot: %v", thisRef.Id(), i, want, got))
                        }</span>
                }
                <span class="cov8" title="1">handle, err := source.getViewAccess(&amp;child)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">childIsFrozen := handle.Get().IsFrozen()
                handle.Release()

                // rule: child is marked as frozen -&gt; childIsFrozen (implication)
                if flag := n.isChildFrozen(byte(i)); flag &amp;&amp; !childIsFrozen </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("in node %v the frozen flag for child 0x%X is invalid, flag: %t, actual: %t", thisRef.Id(), i, flag, childIsFrozen))
                }</span>

                // rule: if this node is frozen, all children must be frozen
                <span class="cov8" title="1">if n.IsFrozen() &amp;&amp; !childIsFrozen </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("the frozen node %v must not have a non-frozen child at position 0x%X", thisRef.Id(), i))
                }</span>
        }
        <span class="cov8" title="1">if numChildren &lt; 2 </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v has an insufficient number of child nodes: %d", thisRef.Id(), numChildren))
        }</span>
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (n *BranchNode) Dump(out io.Writer, source NodeSource, thisRef *NodeReference, indent string) error <span class="cov8" title="1">{
        errs := []error{}
        fmt.Fprintf(out, "%sBranch (ID: %v, dirty: %t, frozen: %t, Dirty: %016b, Embedded: %016b, Frozen: %016b, Hash: %v, hashState: %v):\n", indent, thisRef.Id(), n.IsDirty(), n.IsFrozen(), n.dirtyHashes, n.embeddedChildren, n.frozenChildren, formatHashForDump(n.hash), n.getHashStatus())
        for i, child := range n.children </span><span class="cov8" title="1">{
                if child.Id().IsEmpty() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if handle, err := source.getViewAccess(&amp;child); err == nil </span><span class="cov8" title="1">{
                        defer handle.Release()
                        if err := handle.Get().Dump(out, source, &amp;child, fmt.Sprintf("%s  %v ", indent, Nibble(i))); err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        fmt.Fprintf(out, "%s  ERROR: unable to load node %v: %v", indent, child, err)
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (b *BranchNode) Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        switch visitor.Visit(b, NodeInfo{Id: thisRef.Id(), Depth: &amp;depth}) </span>{
        case VisitResponseAbort:<span class="cov8" title="1">
                return true, nil</span>
        case VisitResponsePrune:<span class="cov8" title="1">
                return false, nil</span>
        case VisitResponseContinue:<span class="cov8" title="1"></span> /* keep going */
        }
        <span class="cov8" title="1">for _, child := range b.children </span><span class="cov8" title="1">{
                if child.Id().IsEmpty() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if handle, err := source.getViewAccess(&amp;child); err == nil </span><span class="cov8" title="1">{
                        defer handle.Release()
                        if abort, err := handle.Get().Visit(source, &amp;child, depth+1, visitor); abort || err != nil </span><span class="cov8" title="1">{
                                return abort, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        return false, err
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func (n *BranchNode) markChildHashDirty(index byte) <span class="cov8" title="1">{
        n.dirtyHashes = n.dirtyHashes | (1 &lt;&lt; index)
}</span>

func (n *BranchNode) markChildHashClean(index byte) <span class="cov8" title="1">{
        n.dirtyHashes = n.dirtyHashes &amp; ^(1 &lt;&lt; index)
}</span>

func (n *BranchNode) isChildHashDirty(index byte) bool <span class="cov8" title="1">{
        return (n.dirtyHashes &amp; (1 &lt;&lt; index)) != 0
}</span>

func (n *BranchNode) clearChildHashDirtyFlags() <span class="cov8" title="1">{
        n.dirtyHashes = 0
}</span>

func (n *BranchNode) isEmbedded(index byte) bool <span class="cov8" title="1">{
        return (n.embeddedChildren &amp; (1 &lt;&lt; index)) != 0
}</span>

func (n *BranchNode) setEmbedded(index byte, embedded bool) <span class="cov8" title="1">{
        if embedded </span><span class="cov8" title="1">{
                n.embeddedChildren = n.embeddedChildren | (1 &lt;&lt; index)
        }</span> else<span class="cov8" title="1"> {
                n.embeddedChildren = n.embeddedChildren &amp; ^(1 &lt;&lt; index)
        }</span>
}

func (n *BranchNode) isChildFrozen(index byte) bool <span class="cov8" title="1">{
        return (n.frozenChildren &amp; (1 &lt;&lt; index)) != 0
}</span>

func (n *BranchNode) setChildFrozen(index byte, frozen bool) <span class="cov8" title="1">{
        if frozen </span><span class="cov8" title="1">{
                n.frozenChildren = n.frozenChildren | (1 &lt;&lt; index)
        }</span> else<span class="cov8" title="1"> {
                n.frozenChildren = n.frozenChildren &amp; ^(1 &lt;&lt; index)
        }</span>
}

// ----------------------------------------------------------------------------
//                              Extension Node
// ----------------------------------------------------------------------------

// ExtensionNode are covering one or more Nibbles along the path from a root
// node to a leaf node in a trie. Neither the path nor the referenced sub-trie
// must be empty.
type ExtensionNode struct {
        nodeBase
        path           Path
        next           NodeReference
        nextHash       common.Hash
        nextHashDirty  bool
        nextIsEmbedded bool
}

func (n *ExtensionNode) getNextNodeInExtension(
        source NodeSource,
        path []Nibble,
) (shared.ReadHandle[Node], []Nibble, error) <span class="cov8" title="1">{
        if !n.path.IsPrefixOf(path) </span><span class="cov8" title="1">{
                shared := shared.MakeShared[Node](EmptyNode{})
                return shared.GetReadHandle(), nil, nil
        }</span>
        <span class="cov8" title="1">handle, err := source.getReadAccess(&amp;n.next)
        if err != nil </span><span class="cov8" title="1">{
                return shared.ReadHandle[Node]{}, nil, err
        }</span>
        <span class="cov8" title="1">return handle, path[n.path.Length():], nil</span>
}

func (n *ExtensionNode) GetAccount(source NodeSource, address common.Address, path []Nibble) (AccountInfo, bool, error) <span class="cov8" title="1">{
        handle, rest, err := n.getNextNodeInExtension(source, path)
        if err != nil </span><span class="cov8" title="1">{
                return AccountInfo{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        return handle.Get().GetAccount(source, address, rest)</span>
}

func (n *ExtensionNode) GetValue(source NodeSource, key common.Key, path []Nibble) (common.Value, bool, error) <span class="cov8" title="1">{
        handle, rest, err := n.getNextNodeInExtension(source, path)
        if err != nil </span><span class="cov8" title="1">{
                return common.Value{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        return handle.Get().GetValue(source, key, rest)</span>
}

func (n *ExtensionNode) GetSlot(source NodeSource, address common.Address, path []Nibble, key common.Key) (common.Value, bool, error) <span class="cov8" title="1">{
        handle, rest, err := n.getNextNodeInExtension(source, path)
        if err != nil </span><span class="cov8" title="1">{
                return common.Value{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        return handle.Get().GetSlot(source, address, rest, key)</span>
}

func (n *ExtensionNode) setNextNode(
        manager NodeManager,
        thisRef *NodeReference,
        path []Nibble,
        valueIsEmpty bool,
        createSubTree func(*NodeReference, shared.WriteHandle[Node], []Nibble) (NodeReference, bool, error),
) (NodeReference, bool, error) <span class="cov8" title="1">{
        // Check whether the updates targets the node referenced by this extension.
        if n.path.IsPrefixOf(path) </span><span class="cov8" title="1">{
                handle, err := manager.getWriteAccess(&amp;n.next)
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, false, err
                }</span>
                <span class="cov8" title="1">defer handle.Release()
                newRoot, hasChanged, err := createSubTree(&amp;n.next, handle, path[n.path.Length():])
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, false, err
                }</span>

                // The modified sub-trie is either a branch, extension, account, or
                // value node. It can not be empty, since a single modification cannot
                // convert a branch node into an empty node.

                <span class="cov8" title="1">if newRoot != n.next </span><span class="cov8" title="1">{

                        // If frozen, modify a clone.
                        isClone := false
                        if n.IsFrozen() </span><span class="cov8" title="1">{
                                newRef, handle, err := manager.createExtension()
                                if err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>
                                <span class="cov8" title="1">defer handle.Release()
                                newNode := handle.Get().(*ExtensionNode)
                                *newNode = *n
                                newNode.markDirty()
                                newNode.markMutable()
                                thisRef, n = &amp;newRef, newNode
                                isClone = true</span>
                        }

                        // The referenced sub-tree has changed, so the hash needs to be updated.
                        <span class="cov8" title="1">n.nextHashDirty = true

                        if newRoot.Id().IsExtension() </span><span class="cov8" title="1">{
                                // If the new next is an extension, merge it into this extension.
                                handle, err := manager.getWriteAccess(&amp;newRoot)
                                if err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>
                                <span class="cov8" title="1">defer handle.Release()
                                extension := handle.Get().(*ExtensionNode)
                                n.path.AppendAll(&amp;extension.path)
                                n.next = extension.next
                                n.nextHashDirty = extension.nextHashDirty
                                if !extension.nextHashDirty </span><span class="cov8" title="1">{
                                        n.nextHash = extension.nextHash
                                        n.nextIsEmbedded = extension.nextIsEmbedded
                                }</span>
                                <span class="cov8" title="1">n.markDirty()
                                extension.nodeBase.Release()
                                if err := manager.release(&amp;newRoot); err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>
                        } else<span class="cov8" title="1"> if newRoot.Id().IsBranch() </span><span class="cov8" title="1">{
                                n.next = newRoot
                                n.nextHashDirty = true
                                n.markDirty()
                        }</span> else<span class="cov8" title="1"> {
                                // If the next node is anything but a branch or extension, remove this extension.
                                n.nodeBase.Release()
                                if err := manager.release(thisRef); err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>

                                // Grow path length of next nodes if tracking of length is enabled.
                                <span class="cov8" title="1">if manager.getConfig().TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                                        root, err := manager.getWriteAccess(&amp;newRoot)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return NodeReference{}, false, err
                                        }</span>
                                        <span class="cov8" title="1">if newRoot.Id().IsAccount() </span><span class="cov8" title="1">{
                                                newRoot, _, err = root.Get().(*AccountNode).setPathLength(manager, &amp;newRoot, root, byte(len(path)))
                                        }</span> else<span class="cov8" title="1"> if newRoot.Id().IsValue() </span><span class="cov8" title="1">{
                                                newRoot, _, err = root.Get().(*ValueNode).setPathLength(manager, &amp;newRoot, root, byte(len(path)))
                                        }</span> else<span class="cov0" title="0"> {
                                                panic(fmt.Sprintf("unsupported new next node type: %v", newRoot))</span>
                                        }
                                        <span class="cov8" title="1">root.Release()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return NodeReference{}, false, err
                                        }</span>
                                }

                                <span class="cov8" title="1">return newRoot, !isClone, nil</span>
                        }
                } else<span class="cov8" title="1"> if hasChanged </span><span class="cov8" title="1">{
                        n.markDirty()
                        n.nextHashDirty = true
                }</span>
                <span class="cov8" title="1">return *thisRef, hasChanged, err</span>
        }

        // Skip creation of a new sub-tree if the info is empty.
        <span class="cov8" title="1">if valueIsEmpty </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>

        // If frozen, modify a clone.
        <span class="cov8" title="1">isClone := false
        if n.IsFrozen() </span><span class="cov8" title="1">{
                newRef, handle, err := manager.createExtension()
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, false, err
                }</span>
                <span class="cov8" title="1">defer handle.Release()
                newNode := handle.Get().(*ExtensionNode)
                *newNode = *n
                newNode.markDirty()
                newNode.markMutable()
                thisRef, n = &amp;newRef, newNode
                isClone = true</span>
        }

        // Extension needs to be replaced by a combination of
        //  - an optional common prefix extension
        //  - a branch node
        //  - an optional extension connecting to the previous next node

        // Create the branch node that will be needed in any case.
        <span class="cov8" title="1">branchRef, branchHandle, err := manager.createBranch()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">defer branchHandle.Release()
        newRoot := branchRef
        branch := branchHandle.Get().(*BranchNode)

        // Determine the point at which the prefix need to be split.
        commonPrefixLength := n.path.GetCommonPrefixLength(path)

        // Build the extension connecting the branch to the next node.
        thisNodeWasReused := false
        if commonPrefixLength &lt; n.path.Length()-1 </span><span class="cov8" title="1">{
                // We re-use the current node for this - all we need is to update the path.
                branch.children[n.path.Get(commonPrefixLength)] = *thisRef
                branch.markChildHashDirty(byte(n.path.Get(commonPrefixLength)))
                n.path.ShiftLeft(commonPrefixLength + 1)
                n.markDirty()
                thisNodeWasReused = true
        }</span> else<span class="cov8" title="1"> {
                pos := byte(n.path.Get(commonPrefixLength))
                branch.children[pos] = n.next
                if n.nextHashDirty </span><span class="cov8" title="1">{
                        branch.markChildHashDirty(pos)
                }</span> else<span class="cov8" title="1"> {
                        branch.hashes[pos] = n.nextHash
                        branch.setEmbedded(pos, n.nextIsEmbedded)
                }</span>
                <span class="cov8" title="1">branch.setChildFrozen(pos, isClone)</span>
        }

        // Build the extension covering the common prefix.
        <span class="cov8" title="1">if commonPrefixLength &gt; 0 </span><span class="cov8" title="1">{
                // Reuse current node unless already taken.
                extension := n
                extensionRef := *thisRef
                if thisNodeWasReused </span><span class="cov8" title="1">{
                        var extensionHandle shared.WriteHandle[Node]
                        extensionRef, extensionHandle, err = manager.createExtension()
                        if err != nil </span><span class="cov8" title="1">{
                                return NodeReference{}, false, err
                        }</span>
                        <span class="cov8" title="1">defer extensionHandle.Release()
                        extension = extensionHandle.Get().(*ExtensionNode)</span>
                } else<span class="cov8" title="1"> {
                        thisNodeWasReused = true
                }</span>

                <span class="cov8" title="1">extension.path = CreatePathFromNibbles(path[0:commonPrefixLength])
                extension.next = branchRef
                extension.nextHashDirty = true
                extension.markDirty()
                newRoot = extensionRef</span>
        }

        // Continue insertion of new account at new branch level.
        <span class="cov8" title="1">_, _, err = createSubTree(&amp;branchRef, branchHandle, path[commonPrefixLength:])
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>

        // If this node was not needed any more, we can discard it.
        <span class="cov8" title="1">if !thisNodeWasReused </span><span class="cov8" title="1">{
                n.nodeBase.Release()
                return newRoot, false, manager.release(thisRef)
        }</span>

        <span class="cov8" title="1">return newRoot, !isClone, nil</span>
}

func (n *ExtensionNode) SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (NodeReference, bool, error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, path, info.IsEmpty(),
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().SetAccount(manager, next, node, address, path, info)
                }</span>,
        )
}

func (n *ExtensionNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, path, value == (common.Value{}),
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().SetValue(manager, next, node, key, path, value)
                }</span>,
        )
}

func (n *ExtensionNode) SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, path, true,
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().SetSlot(manager, next, node, address, path, key, value)
                }</span>,
        )
}

func (n *ExtensionNode) ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (newRoot NodeReference, hasChanged bool, err error) <span class="cov8" title="1">{
        return n.setNextNode(manager, thisRef, path, true,
                func(next *NodeReference, node shared.WriteHandle[Node], path []Nibble) (NodeReference, bool, error) </span><span class="cov8" title="1">{
                        return node.Get().ClearStorage(manager, next, node, address, path)
                }</span>,
        )
}

func (n *ExtensionNode) Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.nodeBase.Release()
        handle, err := manager.getWriteAccess(&amp;n.next)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        err = handle.Get().Release(manager, &amp;n.next, handle)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return manager.release(thisRef)</span>
}

func (n *ExtensionNode) Freeze(manager NodeManager, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.MarkFrozen()
        handle, err := manager.getWriteAccess(&amp;n.next)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        return handle.Get().Freeze(manager, handle)</span>
}

func (n *ExtensionNode) Check(source NodeSource, thisRef *NodeReference, _ []Nibble) error <span class="cov8" title="1">{
        // Checked invariants:
        //  - extension path have a length &gt; 0
        //  - extension can only be followed by a branch
        //  - hash of sub-tree is either dirty or correct
        //  - frozen flags are consistent
        var errs []error

        if err := n.nodeBase.check(thisRef); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, err)
        }</span>

        <span class="cov8" title="1">hashWithParent := source.getConfig().HashStorageLocation == HashStoredWithParent
        if hashWithParent &amp;&amp; n.hasCleanHash() &amp;&amp; n.nextHashDirty </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v is marked to have a clean hash but next hash is dirty", thisRef.Id()))
        }</span>

        <span class="cov8" title="1">if n.path.Length() &lt;= 0 </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v - extension path must not be empty", thisRef.Id()))
        }</span>
        <span class="cov8" title="1">if !n.next.Id().IsBranch() </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v - extension path must be followed by a branch", thisRef.Id()))
        }</span>
        <span class="cov8" title="1">if !n.nextHashDirty &amp;&amp; !n.nextIsEmbedded </span><span class="cov8" title="1">{
                want, err := source.getHashFor(&amp;n.next)
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span> else<span class="cov8" title="1"> if want != n.nextHash </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("node %v - next node hash invalid\nwant: %v\ngot: %v", thisRef.Id(), want, n.nextHash))
                }</span>
        }

        <span class="cov8" title="1">if !n.next.Id().IsEmpty() </span><span class="cov8" title="1">{
                handle, err := source.getViewAccess(&amp;n.next)
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span> else<span class="cov8" title="1"> {
                        nextIsFrozen := handle.Get().IsFrozen()
                        handle.Release()
                        if n.IsFrozen() &amp;&amp; !nextIsFrozen </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("the frozen node %v must have a frozen next", thisRef.Id()))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (n *ExtensionNode) Dump(out io.Writer, source NodeSource, thisRef *NodeReference, indent string) error <span class="cov8" title="1">{
        errs := []error{}
        fmt.Fprintf(out, "%sExtension (ID: %v/%t, nextHashDirty: %t, Embedded: %t, Hash: %v, hashState: %v): %v\n", indent, thisRef.Id(), n.IsFrozen(), n.nextHashDirty, n.nextIsEmbedded, formatHashForDump(n.hash), n.getHashStatus(), &amp;n.path)
        if handle, err := source.getViewAccess(&amp;n.next); err == nil </span><span class="cov8" title="1">{
                defer handle.Release()
                if err := handle.Get().Dump(out, source, &amp;n.next, indent+"  "); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(out, "%s  ERROR: unable to load node %v: %v", indent, n.next, err)
                errs = append(errs, err)
        }</span>
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (n *ExtensionNode) Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        response := visitor.Visit(n, NodeInfo{Id: thisRef.Id(), Depth: &amp;depth})
        switch response </span>{
        case VisitResponseAbort:<span class="cov8" title="1">
                return true, nil</span>
        case VisitResponsePrune:<span class="cov8" title="1">
                return false, nil</span>
        }
        <span class="cov8" title="1">if handle, err := source.getViewAccess(&amp;n.next); err == nil </span><span class="cov8" title="1">{
                defer handle.Release()
                return handle.Get().Visit(source, &amp;n.next, depth+1, visitor)
        }</span> else<span class="cov8" title="1"> {
                return false, err
        }</span>
}

// ----------------------------------------------------------------------------
//                               Account Node
// ----------------------------------------------------------------------------

// AccountNode is the node type found in the middle of an MPT structure
// representing an account. It stores the account's information and references
// the root node of the account's storage trie. It forms the boundary between
// the usage of addresses for navigating the trie and the usage of keys.
// No AccountNode may be present in the trie rooted by an accounts storage
// root. Also, the retained account information must not be empty.
type AccountNode struct {
        nodeBase
        address          common.Address
        info             AccountInfo
        storage          NodeReference
        storageHash      common.Hash
        storageHashDirty bool
        // pathLength is the number of nibbles of the key (or its hash) not covered
        // by the navigation path to this node. It is only maintained if the
        // `TrackSuffixLengthsInLeafNodes` of the `MptConfig` is enabled.
        pathLength byte
}

func (n *AccountNode) Address() common.Address <span class="cov8" title="1">{
        return n.address
}</span>

func (n *AccountNode) Info() AccountInfo <span class="cov8" title="1">{
        return n.info
}</span>

func (n *AccountNode) GetAccount(source NodeSource, address common.Address, path []Nibble) (AccountInfo, bool, error) <span class="cov8" title="1">{
        if n.address == address </span><span class="cov8" title="1">{
                return n.info, true, nil
        }</span>
        <span class="cov8" title="1">return AccountInfo{}, false, nil</span>
}

func (n *AccountNode) GetValue(NodeSource, common.Key, []Nibble) (common.Value, bool, error) <span class="cov8" title="1">{
        return common.Value{}, false, fmt.Errorf("invalid request: value query should not reach accounts")
}</span>

func (n *AccountNode) GetSlot(source NodeSource, address common.Address, path []Nibble, key common.Key) (common.Value, bool, error) <span class="cov8" title="1">{
        if n.address != address </span><span class="cov8" title="1">{
                return common.Value{}, false, nil
        }</span>
        <span class="cov8" title="1">subPath := KeyToNibblePath(key, source)
        root, err := source.getReadAccess(&amp;n.storage)
        if err != nil </span><span class="cov8" title="1">{
                return common.Value{}, false, err
        }</span>
        <span class="cov8" title="1">defer root.Release()
        return root.Get().GetValue(source, key, subPath[:])</span>
}

func (n *AccountNode) SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (NodeReference, bool, error) <span class="cov8" title="1">{
        // Check whether this is the correct account.
        if n.address == address </span><span class="cov8" title="1">{
                if info == n.info </span><span class="cov8" title="1">{
                        return *thisRef, false, nil
                }</span>
                <span class="cov8" title="1">if info.IsEmpty() </span><span class="cov8" title="1">{
                        if n.IsFrozen() </span><span class="cov8" title="1">{
                                return NewNodeReference(EmptyId()), false, nil
                        }</span>
                        // Recursively release the entire state DB.
                        <span class="cov8" title="1">if !n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                                manager.releaseTrieAsynchronous(n.storage)
                        }</span>
                        // Release this account node and remove it from the trie.
                        <span class="cov8" title="1">n.nodeBase.Release()
                        return NewNodeReference(EmptyId()), false, manager.release(thisRef)</span>
                }

                // If this node is frozen, we need to write the result in
                // a new account node.
                <span class="cov8" title="1">if n.IsFrozen() </span><span class="cov8" title="1">{
                        newRef, handle, err := manager.createAccount()
                        if err != nil </span><span class="cov8" title="1">{
                                return NodeReference{}, false, err
                        }</span>
                        <span class="cov8" title="1">defer handle.Release()
                        newNode := handle.Get().(*AccountNode)
                        *newNode = *n
                        newNode.markDirty()
                        newNode.markMutable()
                        newNode.info = info
                        return newRef, false, nil</span>
                }

                <span class="cov8" title="1">n.info = info
                n.markDirty()
                return *thisRef, true, nil</span>
        }

        // Skip restructuring the tree if the new info is empty.
        <span class="cov8" title="1">if info.IsEmpty() </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>

        // Create a new node for the sibling to be added.
        <span class="cov8" title="1">siblingRef, handle, err := manager.createAccount()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        sibling := handle.Get().(*AccountNode)
        sibling.address = address
        sibling.info = info
        sibling.markDirty()

        thisPath := AddressToNibblePath(n.address, manager)
        newRoot, err := splitLeafNode(manager, thisRef, thisPath[:], n, this, path, &amp;siblingRef, sibling, handle)
        return newRoot, !n.IsFrozen() &amp;&amp; manager.getConfig().TrackSuffixLengthsInLeafNodes, err</span>
}

type leafNode interface {
        Node
        setPathLength(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], length byte) (newRoot NodeReference, changed bool, err error)
}

func splitLeafNode(
        manager NodeManager,
        thisRef *NodeReference,
        thisPath []Nibble,
        this leafNode,
        thisHandle shared.WriteHandle[Node],
        siblingPath []Nibble,
        siblingRef *NodeReference,
        sibling leafNode,
        siblingHandle shared.WriteHandle[Node],
) (NodeReference, error) <span class="cov8" title="1">{
        // This single node needs to be split into
        //  - an optional common prefix extension
        //  - a branch node linking this node and
        //  - a new sibling account node to be returned

        branchRef, branchHandle, err := manager.createBranch()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, err
        }</span>
        <span class="cov8" title="1">defer branchHandle.Release()
        branch := branchHandle.Get().(*BranchNode)
        newRoot := branchRef

        // Check whether there is a common prefix.
        partialPath := thisPath[len(thisPath)-len(siblingPath):]
        commonPrefixLength := GetCommonPrefixLength(partialPath, siblingPath)
        if commonPrefixLength &gt; 0 </span><span class="cov8" title="1">{
                extensionRef, handle, err := manager.createExtension()
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, err
                }</span>
                <span class="cov8" title="1">defer handle.Release()
                extension := handle.Get().(*ExtensionNode)
                newRoot = extensionRef

                extension.path = CreatePathFromNibbles(siblingPath[0:commonPrefixLength])
                extension.next = branchRef
                extension.nextHashDirty = true
                extension.markDirty()</span>
        }

        // If enabled, keep track of the suffix length of leaf values.
        <span class="cov8" title="1">thisModified := false
        thisIsFrozen := this.IsFrozen()
        remainingPathLength := byte(len(partialPath)-commonPrefixLength) - 1
        if manager.getConfig().TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                sibling.setPathLength(manager, siblingRef, siblingHandle, remainingPathLength)
                ref, _, err := this.setPathLength(manager, thisRef, thisHandle, remainingPathLength)
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, err
                }</span>
                <span class="cov8" title="1">thisModified = true
                thisRef = &amp;ref
                thisIsFrozen = false</span>
        }

        // Add this node and the new sibling node to the branch node.
        <span class="cov8" title="1">branch.children[partialPath[commonPrefixLength]] = *thisRef
        branch.children[siblingPath[commonPrefixLength]] = *siblingRef
        branch.markChildHashDirty(byte(siblingPath[commonPrefixLength]))
        branch.markDirty()

        // Update hash if present.
        if hash, dirty := this.GetHash(); thisModified || dirty </span><span class="cov8" title="1">{
                branch.markChildHashDirty(byte(partialPath[commonPrefixLength]))
        }</span> else<span class="cov8" title="1"> {
                branch.hashes[partialPath[commonPrefixLength]] = hash
                // The embedded flag can be ignored in this case as long as direct
                // hashing is used.
                if manager.getConfig().Hashing.Name != DirectHashing.Name </span><span class="cov0" title="0">{
                        panic("unsupported mode: disabled TrackSuffixLengthsInLeafNodes is not (yet) supported with hash algorithms depending on embedded nodes.")</span>
                }
        }

        // Track frozen state of split node.
        <span class="cov8" title="1">if thisIsFrozen </span><span class="cov8" title="1">{
                branch.setChildFrozen(byte(partialPath[commonPrefixLength]), true)
        }</span>

        <span class="cov8" title="1">return newRoot, nil</span>
}

func (n *AccountNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        return NodeReference{}, false, fmt.Errorf("setValue call should not reach account nodes")
}</span>

func (n *AccountNode) SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        // If this is not the correct account, the real account does not exist
        // and the insert can be skipped. The insertion of a slot value shall
        // not create an account.
        if n.address != address </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>

        // Continue from here with a value insertion.
        <span class="cov8" title="1">handle, err := manager.getWriteAccess(&amp;n.storage)
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        subPath := KeyToNibblePath(key, manager)
        root, hasChanged, err := handle.Get().SetValue(manager, &amp;n.storage, handle, key, subPath[:], value)
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">if root != n.storage </span><span class="cov8" title="1">{
                // If this node is frozen, we need to write the result in
                // a new account node.
                if n.IsFrozen() </span><span class="cov8" title="1">{
                        newRef, newHandle, err := manager.createAccount()
                        if err != nil </span><span class="cov8" title="1">{
                                return NodeReference{}, false, err
                        }</span>
                        <span class="cov8" title="1">defer newHandle.Release()
                        newNode := newHandle.Get().(*AccountNode)
                        *newNode = *n
                        newNode.markDirty()
                        newNode.markMutable()
                        newNode.storage = root
                        newNode.storageHashDirty = true
                        return newRef, false, nil</span>
                }
                <span class="cov8" title="1">n.storage = root
                n.storageHashDirty = true
                n.markDirty()
                hasChanged = true</span>
        } else<span class="cov8" title="1"> if hasChanged </span><span class="cov8" title="1">{
                n.storageHashDirty = true
                n.markDirty()
        }</span>
        <span class="cov8" title="1">return *thisRef, hasChanged, nil</span>
}

func (n *AccountNode) ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (newRoot NodeReference, changed bool, err error) <span class="cov8" title="1">{
        if n.address != address || n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>

        // If this node is frozen, we need to write the result in
        // a new account node.
        <span class="cov8" title="1">if n.IsFrozen() </span><span class="cov8" title="1">{
                newRef, newHandle, err := manager.createAccount()
                if err != nil </span><span class="cov8" title="1">{
                        return *thisRef, false, err
                }</span>
                <span class="cov8" title="1">defer newHandle.Release()
                newNode := newHandle.Get().(*AccountNode)
                *newNode = *n
                newNode.markDirty()
                newNode.markMutable()
                newNode.storage = NewNodeReference(EmptyId())
                newNode.storageHashDirty = true
                return newRef, false, nil</span>
        }

        <span class="cov8" title="1">if !n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                manager.releaseTrieAsynchronous(n.storage)
        }</span>

        <span class="cov8" title="1">n.storage = NewNodeReference(EmptyId())
        n.markDirty()
        n.storageHashDirty = true
        return *thisRef, true, err</span>
}

func (n *AccountNode) Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.nodeBase.Release()
        if !n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                rootHandle, err := manager.getWriteAccess(&amp;n.storage)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">err = rootHandle.Get().Release(manager, &amp;n.storage, rootHandle)
                rootHandle.Release()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return manager.release(thisRef)</span>
}

func (n *AccountNode) setPathLength(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], length byte) (NodeReference, bool, error) <span class="cov8" title="1">{
        if n.pathLength == length </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>
        <span class="cov8" title="1">if n.IsFrozen() </span><span class="cov8" title="1">{
                newRef, newHandle, err := manager.createAccount()
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, false, err
                }</span>
                <span class="cov8" title="1">defer newHandle.Release()
                newNode := newHandle.Get().(*AccountNode)
                *newNode = *n
                newNode.markDirty()
                newNode.markMutable()
                newNode.pathLength = length
                return newRef, false, nil</span>
        }

        <span class="cov8" title="1">n.pathLength = length
        n.markDirty()
        return *thisRef, true, nil</span>
}

func (n *AccountNode) Freeze(manager NodeManager, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.MarkFrozen()
        handle, err := manager.getWriteAccess(&amp;n.storage)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer handle.Release()
        return handle.Get().Freeze(manager, handle)</span>
}

func (n *AccountNode) Check(source NodeSource, thisRef *NodeReference, path []Nibble) error <span class="cov8" title="1">{
        // Checked invariants:
        //  - account information must not be empty
        //  - the account is at a correct position in the trie
        //  - frozen flags are consistent
        //  - path length
        var errs []error

        if err := n.nodeBase.check(thisRef); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, err)
        }</span>

        <span class="cov8" title="1">hashWithParent := source.getConfig().HashStorageLocation == HashStoredWithParent
        if hashWithParent &amp;&amp; n.hasCleanHash() &amp;&amp; n.storageHashDirty </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v is marked to have a clean hash but storage hash is dirty", thisRef.Id()))
        }</span>

        <span class="cov8" title="1">fullPath := AddressToNibblePath(n.address, source)
        if !IsPrefixOf(path, fullPath[:]) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v - account node %v located in wrong branch: %v", thisRef.Id(), n.address, path))
        }</span>

        <span class="cov8" title="1">if n.info.IsEmpty() </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v - account information must not be empty", thisRef.Id()))
        }</span>

        <span class="cov8" title="1">if source.getConfig().TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                maxPathLength := 40
                if source.getConfig().UseHashedPaths </span><span class="cov8" title="1">{
                        maxPathLength = 64
                }</span>
                <span class="cov8" title="1">if got, want := n.pathLength, byte(maxPathLength-len(path)); got != want </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("node %v - invalid path length, wanted %d, got %d", thisRef.Id(), want, got))
                }</span>
        }

        <span class="cov8" title="1">if !n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                handle, err := source.getViewAccess(&amp;n.storage)
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span> else<span class="cov8" title="1"> {
                        storageIsFrozen := handle.Get().IsFrozen()
                        handle.Release()
                        if n.IsFrozen() &amp;&amp; !storageIsFrozen </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("the frozen node %v must not have a non-frozen storage", thisRef.Id()))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (n *AccountNode) Dump(out io.Writer, source NodeSource, thisRef *NodeReference, indent string) error <span class="cov8" title="1">{
        errs := []error{}
        fmt.Fprintf(out, "%sAccount (ID: %v, dirty: %t, frozen: %t, path length: %v, Hash: %v, hashState: %v): %v - %v\n", indent, thisRef.Id(), n.IsDirty(), n.IsFrozen(), n.pathLength, formatHashForDump(n.hash), n.getHashStatus(), n.address, n.info)
        if n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if node, err := source.getViewAccess(&amp;n.storage); err == nil </span><span class="cov8" title="1">{
                defer node.Release()
                if err := node.Get().Dump(out, source, &amp;n.storage, indent+"  "); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(out, "%s  ERROR: unable to load node %v: %v", indent, n.storage, err)
                errs = append(errs, err)
        }</span>
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (n *AccountNode) Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        response := visitor.Visit(n, NodeInfo{Id: thisRef.Id(), Depth: &amp;depth})
        switch response </span>{
        case VisitResponseAbort:<span class="cov8" title="1">
                return true, nil</span>
        case VisitResponsePrune:<span class="cov8" title="1">
                return false, nil</span>
        }
        <span class="cov8" title="1">if n.storage.Id().IsEmpty() </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if node, err := source.getViewAccess(&amp;n.storage); err == nil </span><span class="cov8" title="1">{
                defer node.Release()
                return node.Get().Visit(source, &amp;n.storage, depth+1, visitor)
        }</span> else<span class="cov8" title="1"> {
                return false, err
        }</span>
}

// ----------------------------------------------------------------------------
//                               Value Node
// ----------------------------------------------------------------------------

// ValueNode store the value of a storage slot of an account. Values must not
// be zero. Also, value nodes must not be reachable in a trie before crossing
// exactly one AccountNode.
type ValueNode struct {
        nodeBase
        key   common.Key
        value common.Value
        // pathLength is the number of nibbles of the key (or its hash) not covered
        // by the navigation path to this node. It is only maintained if the
        // `TrackSuffixLengthsInLeafNodes` of the `MptConfig` is enabled.
        pathLength byte
}

func (n *ValueNode) Key() common.Key <span class="cov8" title="1">{
        return n.key
}</span>

func (n *ValueNode) Value() common.Value <span class="cov8" title="1">{
        return n.value
}</span>

func (n *ValueNode) GetAccount(NodeSource, common.Address, []Nibble) (AccountInfo, bool, error) <span class="cov8" title="1">{
        return AccountInfo{}, false, fmt.Errorf("invalid request: account query should not reach values")
}</span>

func (n *ValueNode) GetValue(source NodeSource, key common.Key, path []Nibble) (common.Value, bool, error) <span class="cov8" title="1">{
        if n.key == key </span><span class="cov8" title="1">{
                return n.value, true, nil
        }</span>
        <span class="cov8" title="1">return common.Value{}, false, nil</span>
}

func (n *ValueNode) GetSlot(NodeSource, common.Address, []Nibble, common.Key) (common.Value, bool, error) <span class="cov8" title="1">{
        return common.Value{}, false, fmt.Errorf("invalid request: slot query should not reach values")
}</span>

func (n *ValueNode) SetAccount(NodeManager, *NodeReference, shared.WriteHandle[Node], common.Address, []Nibble, AccountInfo) (NodeReference, bool, error) <span class="cov8" title="1">{
        return NodeReference{}, false, fmt.Errorf("invalid request: account update should not reach values")
}</span>

func (n *ValueNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        // Check whether this is the correct value node.
        if n.key == key </span><span class="cov8" title="1">{
                if value == n.value </span><span class="cov8" title="1">{
                        return *thisRef, false, nil
                }</span>
                <span class="cov8" title="1">if value == (common.Value{}) </span><span class="cov8" title="1">{
                        if !n.IsFrozen() </span><span class="cov8" title="1">{
                                n.nodeBase.Release()
                                if err := manager.release(thisRef); err != nil </span><span class="cov8" title="1">{
                                        return NodeReference{}, false, err
                                }</span>
                        }
                        <span class="cov8" title="1">return NewNodeReference(EmptyId()), !n.IsFrozen(), nil</span>
                }
                <span class="cov8" title="1">if n.IsFrozen() </span><span class="cov8" title="1">{
                        newRef, newHandle, err := manager.createValue()
                        if err != nil </span><span class="cov8" title="1">{
                                return NodeReference{}, false, nil
                        }</span>
                        <span class="cov8" title="1">defer newHandle.Release()
                        newNode := newHandle.Get().(*ValueNode)
                        newNode.key = n.key
                        newNode.value = value
                        newNode.markDirty()
                        newNode.pathLength = n.pathLength
                        return newRef, false, nil</span>
                }
                <span class="cov8" title="1">n.value = value
                n.markDirty()
                return *thisRef, true, nil</span>
        }

        // Skip restructuring the tree if the new info is empty.
        <span class="cov8" title="1">if value == (common.Value{}) </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>

        // Create a new node for the sibling to be added.
        <span class="cov8" title="1">siblingRef, siblingHandle, err := manager.createValue()
        if err != nil </span><span class="cov8" title="1">{
                return NodeReference{}, false, err
        }</span>
        <span class="cov8" title="1">defer siblingHandle.Release()
        sibling := siblingHandle.Get().(*ValueNode)
        sibling.key = key
        sibling.value = value
        sibling.markDirty()

        thisPath := KeyToNibblePath(n.key, manager)
        newRootId, err := splitLeafNode(manager, thisRef, thisPath[:], n, this, path, &amp;siblingRef, sibling, siblingHandle)
        return newRootId, false, err</span>
}

func (n *ValueNode) SetSlot(NodeManager, *NodeReference, shared.WriteHandle[Node], common.Address, []Nibble, common.Key, common.Value) (NodeReference, bool, error) <span class="cov8" title="1">{
        return NodeReference{}, false, fmt.Errorf("invalid request: slot update should not reach values")
}</span>

func (n *ValueNode) ClearStorage(NodeManager, *NodeReference, shared.WriteHandle[Node], common.Address, []Nibble) (NodeReference, bool, error) <span class="cov8" title="1">{
        return NodeReference{}, false, fmt.Errorf("invalid request: clear storage should not reach values")
}</span>

func (n *ValueNode) Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        if n.IsFrozen() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">n.nodeBase.Release()
        return manager.release(thisRef)</span>
}

func (n *ValueNode) setPathLength(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], length byte) (NodeReference, bool, error) <span class="cov8" title="1">{
        if n.pathLength == length </span><span class="cov8" title="1">{
                return *thisRef, false, nil
        }</span>
        <span class="cov8" title="1">if n.IsFrozen() </span><span class="cov8" title="1">{
                newRef, newHandle, err := manager.createValue()
                if err != nil </span><span class="cov8" title="1">{
                        return NodeReference{}, false, err
                }</span>
                <span class="cov8" title="1">defer newHandle.Release()
                newNode := newHandle.Get().(*ValueNode)
                newNode.key = n.key
                newNode.value = n.value
                newNode.markDirty()
                newNode.pathLength = length
                return newRef, false, nil</span>
        }

        <span class="cov8" title="1">n.pathLength = length
        n.markDirty()
        return *thisRef, true, nil</span>
}

func (n *ValueNode) Freeze(NodeManager, shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        n.MarkFrozen()
        return nil
}</span>

func (n *ValueNode) Check(source NodeSource, thisRef *NodeReference, path []Nibble) error <span class="cov8" title="1">{
        // Checked invariants:
        //  - value must not be empty
        //  - values are in the right position of the trie
        //  - the path length is correct (if enabled to be tracked)
        var errs []error

        if err := n.nodeBase.check(thisRef); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, err)
        }</span>

        <span class="cov8" title="1">fullPath := KeyToNibblePath(n.key, source)
        if !IsPrefixOf(path, fullPath[:]) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v - value node %v [%v] located in wrong branch: %v", thisRef.Id(), n.key, fullPath, path))
        }</span>

        <span class="cov8" title="1">if n.value == (common.Value{}) </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("node %v - value slot must not be empty", thisRef.Id()))
        }</span>

        <span class="cov8" title="1">if source.getConfig().TrackSuffixLengthsInLeafNodes </span><span class="cov8" title="1">{
                if got, want := n.pathLength, byte(64-len(path)); got != want </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("node %v - invalid path length, wanted %d, got %d", thisRef.Id(), want, got))
                }</span>
        }

        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (n *ValueNode) Dump(out io.Writer, source NodeSource, thisRef *NodeReference, indent string) error <span class="cov8" title="1">{
        fmt.Fprintf(out, "%sValue (ID: %v/%t/%d, Hash: %v, hashState: %v): %v - %x\n", indent, thisRef.Id(), n.IsFrozen(), n.pathLength, formatHashForDump(n.hash), n.getHashStatus(), n.key, n.value)
        return nil
}</span>

func formatHashForDump(hash common.Hash) string <span class="cov8" title="1">{
        return fmt.Sprintf("0x%x", hash)
}</span>

func (n *ValueNode) Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        return visitor.Visit(n, NodeInfo{Id: thisRef.Id(), Depth: &amp;depth}) == VisitResponseAbort, nil
}</span>

// ----------------------------------------------------------------------------
//                               Node Encoders
// ----------------------------------------------------------------------------

// TODO [cleanup]: move encoder to extra file and clean-up definitions

type BranchNodeEncoderWithNodeHash struct{}

func (BranchNodeEncoderWithNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        encoder := NodeIdEncoder{}
        return encoder.GetEncodedSize()*16 + common.HashSize
}</span>

func (BranchNodeEncoderWithNodeHash) Store(dst []byte, node *BranchNode) error <span class="cov8" title="1">{
        if !node.hasCleanHash() </span><span class="cov0" title="0">{
                panic("unable to store branch node with dirty hash")</span>
        }
        <span class="cov8" title="1">encoder := NodeIdEncoder{}
        step := encoder.GetEncodedSize()
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                encoder.Store(dst[i*step:], &amp;node.children[i].id)
        }</span>
        <span class="cov8" title="1">dst = dst[step*16:]
        copy(dst, node.hash[:])
        return nil</span>
}

func (BranchNodeEncoderWithNodeHash) Load(src []byte, node *BranchNode) error <span class="cov8" title="1">{
        encoder := NodeIdEncoder{}
        step := encoder.GetEncodedSize()
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                var id NodeId
                encoder.Load(src[i*step:], &amp;id)
                node.children[i] = NewNodeReference(id)
        }</span>
        <span class="cov8" title="1">src = src[step*16:]
        copy(node.hash[:], src)
        node.hashStatus = hashStatusClean

        // The hashes of the child nodes are not stored with the node, so they are
        // marked as dirty to trigger a re-computation the next time they are used.
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                if !node.children[i].Id().IsEmpty() </span><span class="cov8" title="1">{
                        node.markChildHashDirty(byte(i))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type BranchNodeEncoderWithChildHashes struct{}

func (BranchNodeEncoderWithChildHashes) GetEncodedSize() int <span class="cov8" title="1">{
        encoder := NodeIdEncoder{}
        return encoder.GetEncodedSize()*16 + common.HashSize*16 + 2
}</span>

func (BranchNodeEncoderWithChildHashes) Store(dst []byte, node *BranchNode) error <span class="cov8" title="1">{
        if node.dirtyHashes != 0 </span><span class="cov0" title="0">{
                panic("unable to store branch node with dirty hash")</span>
        }
        <span class="cov8" title="1">encoder := NodeIdEncoder{}
        step := encoder.GetEncodedSize()
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                encoder.Store(dst[i*step:], &amp;node.children[i].id)
        }</span>
        <span class="cov8" title="1">dst = dst[step*16:]
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                copy(dst, node.hashes[i][:])
                dst = dst[common.HashSize:]
        }</span>
        <span class="cov8" title="1">binary.BigEndian.PutUint16(dst, node.embeddedChildren)
        return nil</span>
}

func (BranchNodeEncoderWithChildHashes) Load(src []byte, node *BranchNode) error <span class="cov8" title="1">{
        encoder := NodeIdEncoder{}
        step := encoder.GetEncodedSize()
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                var id NodeId
                encoder.Load(src[i*step:], &amp;id)
                node.children[i] = NewNodeReference(id)
        }</span>
        <span class="cov8" title="1">src = src[step*16:]
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                copy(node.hashes[i][:], src)
                src = src[common.HashSize:]
        }</span>
        <span class="cov8" title="1">node.embeddedChildren = binary.BigEndian.Uint16(src)

        // The node's hash is not stored with the node, so it is marked unknown.
        node.hashStatus = hashStatusUnknown

        return nil</span>
}

type ExtensionNodeEncoderWithNodeHash struct{}

func (ExtensionNodeEncoderWithNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        pathEncoder := PathEncoder{}
        idEncoder := NodeIdEncoder{}
        return pathEncoder.GetEncodedSize() + idEncoder.GetEncodedSize() + common.HashSize
}</span>

func (ExtensionNodeEncoderWithNodeHash) Store(dst []byte, value *ExtensionNode) error <span class="cov8" title="1">{
        if !value.hasCleanHash() </span><span class="cov0" title="0">{
                panic("unable to store extension node with dirty hash")</span>
        }
        <span class="cov8" title="1">pathEncoder := PathEncoder{}
        idEncoder := NodeIdEncoder{}
        pathEncoder.Store(dst, &amp;value.path)
        dst = dst[pathEncoder.GetEncodedSize():]
        idEncoder.Store(dst, &amp;value.next.id)
        dst = dst[idEncoder.GetEncodedSize():]
        copy(dst, value.hash[:])
        return nil</span>
}

func (ExtensionNodeEncoderWithNodeHash) Load(src []byte, node *ExtensionNode) error <span class="cov8" title="1">{
        pathEncoder := PathEncoder{}
        idEncoder := NodeIdEncoder{}
        pathEncoder.Load(src, &amp;node.path)
        src = src[pathEncoder.GetEncodedSize():]
        var id NodeId
        idEncoder.Load(src, &amp;id)
        node.next = NewNodeReference(id)
        src = src[idEncoder.GetEncodedSize():]
        copy(node.hash[:], src)
        node.hashStatus = hashStatusClean

        // The hash of the next node is not stored with the node, so it is marked
        // as dirty to trigger a re-computation the next time it is accessed.
        node.nextHashDirty = true

        return nil
}</span>

type ExtensionNodeEncoderWithChildHash struct{}

func (ExtensionNodeEncoderWithChildHash) GetEncodedSize() int <span class="cov8" title="1">{
        pathEncoder := PathEncoder{}
        idEncoder := NodeIdEncoder{}
        return pathEncoder.GetEncodedSize() + idEncoder.GetEncodedSize() + common.HashSize + 1
}</span>

func (ExtensionNodeEncoderWithChildHash) Store(dst []byte, value *ExtensionNode) error <span class="cov8" title="1">{
        if value.nextHashDirty </span><span class="cov0" title="0">{
                panic("unable to store extension node with dirty hash")</span>
        }
        <span class="cov8" title="1">pathEncoder := PathEncoder{}
        idEncoder := NodeIdEncoder{}
        pathEncoder.Store(dst, &amp;value.path)
        dst = dst[pathEncoder.GetEncodedSize():]
        idEncoder.Store(dst, &amp;value.next.id)
        dst = dst[idEncoder.GetEncodedSize():]
        copy(dst, value.nextHash[:])
        dst = dst[common.HashSize:]
        if value.nextIsEmbedded </span><span class="cov8" title="1">{
                dst[0] = 1
        }</span> else<span class="cov8" title="1"> {
                dst[0] = 0
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ExtensionNodeEncoderWithChildHash) Load(src []byte, node *ExtensionNode) error <span class="cov8" title="1">{
        pathEncoder := PathEncoder{}
        idEncoder := NodeIdEncoder{}
        pathEncoder.Load(src, &amp;node.path)
        src = src[pathEncoder.GetEncodedSize():]
        var id NodeId
        idEncoder.Load(src, &amp;id)
        node.next = NewNodeReference(id)
        src = src[idEncoder.GetEncodedSize():]
        copy(node.nextHash[:], src)
        src = src[common.HashSize:]
        node.nextIsEmbedded = src[0] != 0

        // The node's hash is not stored with the node, so it is marked unknown.
        node.hashStatus = hashStatusUnknown

        return nil
}</span>

type AccountNodeEncoderWithNodeHash struct{}

func (AccountNodeEncoderWithNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        return common.AddressSize +
                AccountInfoEncoder{}.GetEncodedSize() +
                NodeIdEncoder{}.GetEncodedSize() +
                common.HashSize
}</span>

func (AccountNodeEncoderWithNodeHash) Store(dst []byte, node *AccountNode) error <span class="cov8" title="1">{
        if !node.hasCleanHash() </span><span class="cov0" title="0">{
                panic("unable to store account node with dirty hash")</span>
        }
        <span class="cov8" title="1">copy(dst, node.address[:])
        dst = dst[len(node.address):]

        infoEncoder := AccountInfoEncoder{}
        infoEncoder.Store(dst, &amp;node.info)
        dst = dst[infoEncoder.GetEncodedSize():]

        idEncoder := NodeIdEncoder{}
        idEncoder.Store(dst, &amp;node.storage.id)
        dst = dst[idEncoder.GetEncodedSize():]
        copy(dst[:], node.hash[:])
        return nil</span>
}

func (AccountNodeEncoderWithNodeHash) Load(src []byte, node *AccountNode) error <span class="cov8" title="1">{
        copy(node.address[:], src)
        src = src[len(node.address):]

        infoEncoder := AccountInfoEncoder{}
        infoEncoder.Load(src, &amp;node.info)
        src = src[infoEncoder.GetEncodedSize():]

        idEncoder := NodeIdEncoder{}
        var id NodeId
        idEncoder.Load(src, &amp;id)
        node.storage = NewNodeReference(id)
        src = src[idEncoder.GetEncodedSize():]
        copy(node.hash[:], src)
        node.hashStatus = hashStatusClean

        // The storage hash is not stored with the node, so it is marked as dirty to
        // trigger a re-computation the next time it is accessed.
        node.storageHashDirty = true

        return nil
}</span>

type AccountNodeEncoderWithChildHash struct{}

func (AccountNodeEncoderWithChildHash) GetEncodedSize() int <span class="cov8" title="1">{
        return common.AddressSize +
                AccountInfoEncoder{}.GetEncodedSize() +
                NodeIdEncoder{}.GetEncodedSize() +
                common.HashSize
}</span>

func (AccountNodeEncoderWithChildHash) Store(dst []byte, node *AccountNode) error <span class="cov8" title="1">{
        if node.storageHashDirty </span><span class="cov0" title="0">{
                panic("unable to store account node with dirty hash")</span>
        }
        <span class="cov8" title="1">copy(dst, node.address[:])
        dst = dst[len(node.address):]

        infoEncoder := AccountInfoEncoder{}
        infoEncoder.Store(dst, &amp;node.info)
        dst = dst[infoEncoder.GetEncodedSize():]

        idEncoder := NodeIdEncoder{}
        idEncoder.Store(dst, &amp;node.storage.id)
        dst = dst[idEncoder.GetEncodedSize():]
        copy(dst[:], node.storageHash[:])
        return nil</span>
}

func (AccountNodeEncoderWithChildHash) Load(src []byte, node *AccountNode) error <span class="cov8" title="1">{
        copy(node.address[:], src)
        src = src[len(node.address):]

        infoEncoder := AccountInfoEncoder{}
        infoEncoder.Load(src, &amp;node.info)
        src = src[infoEncoder.GetEncodedSize():]

        idEncoder := NodeIdEncoder{}
        var id NodeId
        idEncoder.Load(src, &amp;id)
        node.storage = NewNodeReference(id)
        src = src[idEncoder.GetEncodedSize():]
        copy(node.storageHash[:], src)

        // The node's hash is not stored with the node, so it is marked unknown.
        node.hashStatus = hashStatusUnknown

        return nil
}</span>

type AccountNodeWithPathLengthEncoderWithNodeHash struct{}

func (AccountNodeWithPathLengthEncoderWithNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        return AccountNodeEncoderWithNodeHash{}.GetEncodedSize() + 1
}</span>

func (AccountNodeWithPathLengthEncoderWithNodeHash) Store(dst []byte, node *AccountNode) error <span class="cov8" title="1">{
        AccountNodeEncoderWithNodeHash{}.Store(dst, node)
        dst[len(dst)-1] = node.pathLength
        return nil
}</span>

func (AccountNodeWithPathLengthEncoderWithNodeHash) Load(src []byte, node *AccountNode) error <span class="cov8" title="1">{
        AccountNodeEncoderWithNodeHash{}.Load(src, node)
        node.pathLength = src[len(src)-1]
        return nil
}</span>

type AccountNodeWithPathLengthEncoderWithChildHash struct{}

func (AccountNodeWithPathLengthEncoderWithChildHash) GetEncodedSize() int <span class="cov8" title="1">{
        return AccountNodeEncoderWithChildHash{}.GetEncodedSize() + 1
}</span>

func (AccountNodeWithPathLengthEncoderWithChildHash) Store(dst []byte, node *AccountNode) error <span class="cov8" title="1">{
        AccountNodeEncoderWithChildHash{}.Store(dst, node)
        dst[len(dst)-1] = node.pathLength
        return nil
}</span>

func (AccountNodeWithPathLengthEncoderWithChildHash) Load(src []byte, node *AccountNode) error <span class="cov8" title="1">{
        AccountNodeEncoderWithChildHash{}.Load(src, node)
        node.pathLength = src[len(src)-1]
        return nil
}</span>

type ValueNodeEncoderWithoutNodeHash struct{}

func (ValueNodeEncoderWithoutNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        return common.KeySize + common.ValueSize
}</span>

func (ValueNodeEncoderWithoutNodeHash) Store(dst []byte, node *ValueNode) error <span class="cov8" title="1">{
        copy(dst, node.key[:])
        dst = dst[len(node.key):]
        copy(dst, node.value[:])
        return nil
}</span>

func (ValueNodeEncoderWithoutNodeHash) Load(src []byte, node *ValueNode) error <span class="cov8" title="1">{
        copy(node.key[:], src)
        src = src[len(node.key):]
        copy(node.value[:], src)

        // The node's hash is not stored with the node, so it is marked unknown.
        node.hashStatus = hashStatusUnknown

        return nil
}</span>

type ValueNodeEncoderWithNodeHash struct{}

func (ValueNodeEncoderWithNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        return ValueNodeEncoderWithoutNodeHash{}.GetEncodedSize() + common.HashSize
}</span>

func (ValueNodeEncoderWithNodeHash) Store(dst []byte, node *ValueNode) error <span class="cov8" title="1">{
        if !node.hasCleanHash() </span><span class="cov0" title="0">{
                panic("unable to store value node with dirty hash")</span>
        }
        <span class="cov8" title="1">ValueNodeEncoderWithoutNodeHash{}.Store(dst, node)
        dst = dst[ValueNodeEncoderWithoutNodeHash{}.GetEncodedSize():]
        copy(dst, node.hash[:])
        return nil</span>
}

func (ValueNodeEncoderWithNodeHash) Load(src []byte, node *ValueNode) error <span class="cov8" title="1">{
        ValueNodeEncoderWithoutNodeHash{}.Load(src, node)
        src = src[ValueNodeEncoderWithoutNodeHash{}.GetEncodedSize():]
        copy(node.hash[:], src)
        node.hashStatus = hashStatusClean
        return nil
}</span>

type ValueNodeWithPathLengthEncoderWithoutNodeHash struct{}

func (ValueNodeWithPathLengthEncoderWithoutNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        return ValueNodeEncoderWithoutNodeHash{}.GetEncodedSize() + 1
}</span>

func (ValueNodeWithPathLengthEncoderWithoutNodeHash) Store(dst []byte, node *ValueNode) error <span class="cov8" title="1">{
        ValueNodeEncoderWithoutNodeHash{}.Store(dst, node)
        dst[len(dst)-1] = node.pathLength
        return nil
}</span>

func (ValueNodeWithPathLengthEncoderWithoutNodeHash) Load(src []byte, node *ValueNode) error <span class="cov8" title="1">{
        ValueNodeEncoderWithoutNodeHash{}.Load(src, node)
        node.pathLength = src[len(src)-1]
        return nil
}</span>

type ValueNodeWithPathLengthEncoderWithNodeHash struct{}

func (ValueNodeWithPathLengthEncoderWithNodeHash) GetEncodedSize() int <span class="cov8" title="1">{
        return ValueNodeEncoderWithNodeHash{}.GetEncodedSize() + 1
}</span>

func (ValueNodeWithPathLengthEncoderWithNodeHash) Store(dst []byte, node *ValueNode) error <span class="cov8" title="1">{
        ValueNodeEncoderWithNodeHash{}.Store(dst, node)
        dst[len(dst)-1] = node.pathLength
        return nil
}</span>

func (ValueNodeWithPathLengthEncoderWithNodeHash) Load(src []byte, node *ValueNode) error <span class="cov8" title="1">{
        ValueNodeEncoderWithNodeHash{}.Load(src, node)
        node.pathLength = src[len(src)-1]
        return nil
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: nodes.go
//
// Generated by this command:
//
//        mockgen -source nodes.go -destination nodes_mocks.go -package mpt
//
// Package mpt is a generated GoMock package.
package mpt

import (
        io "io"
        reflect "reflect"

        common "github.com/Fantom-foundation/Carmen/go/common"
        shared "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        gomock "go.uber.org/mock/gomock"
)

// MockNode is a mock of Node interface.
type MockNode struct {
        ctrl     *gomock.Controller
        recorder *MockNodeMockRecorder
}

// MockNodeMockRecorder is the mock recorder for MockNode.
type MockNodeMockRecorder struct {
        mock *MockNode
}

// NewMockNode creates a new mock instance.
func NewMockNode(ctrl *gomock.Controller) *MockNode <span class="cov8" title="1">{
        mock := &amp;MockNode{ctrl: ctrl}
        mock.recorder = &amp;MockNodeMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNode) EXPECT() *MockNodeMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Check mocks base method.
func (m *MockNode) Check(source NodeSource, thisRef *NodeReference, path []Nibble) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Check", source, thisRef, path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Check indicates an expected call of Check.
func (mr *MockNodeMockRecorder) Check(source, thisRef, path any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockNode)(nil).Check), source, thisRef, path)
}</span>

// ClearStorage mocks base method.
func (m *MockNode) ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ClearStorage", manager, thisRef, this, address, path)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ClearStorage indicates an expected call of ClearStorage.
func (mr *MockNodeMockRecorder) ClearStorage(manager, thisRef, this, address, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearStorage", reflect.TypeOf((*MockNode)(nil).ClearStorage), manager, thisRef, this, address, path)
}</span>

// Dump mocks base method.
func (m *MockNode) Dump(dest io.Writer, source NodeSource, thisRef *NodeReference, indent string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Dump", dest, source, thisRef, indent)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Dump indicates an expected call of Dump.
func (mr *MockNodeMockRecorder) Dump(dest, source, thisRef, indent any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockNode)(nil).Dump), dest, source, thisRef, indent)
}</span>

// Freeze mocks base method.
func (m *MockNode) Freeze(manager NodeManager, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Freeze", manager, this)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Freeze indicates an expected call of Freeze.
func (mr *MockNodeMockRecorder) Freeze(manager, this any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Freeze", reflect.TypeOf((*MockNode)(nil).Freeze), manager, this)
}</span>

// GetAccount mocks base method.
func (m *MockNode) GetAccount(source NodeSource, address common.Address, path []Nibble) (AccountInfo, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAccount", source, address, path)
        ret0, _ := ret[0].(AccountInfo)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAccount indicates an expected call of GetAccount.
func (mr *MockNodeMockRecorder) GetAccount(source, address, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockNode)(nil).GetAccount), source, address, path)
}</span>

// GetHash mocks base method.
func (m *MockNode) GetHash() (common.Hash, bool) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetHash")
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(bool)
        return ret0, ret1
}</span>

// GetHash indicates an expected call of GetHash.
func (mr *MockNodeMockRecorder) GetHash() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHash", reflect.TypeOf((*MockNode)(nil).GetHash))
}</span>

// GetSlot mocks base method.
func (m *MockNode) GetSlot(source NodeSource, address common.Address, path []Nibble, key common.Key) (common.Value, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSlot", source, address, path, key)
        ret0, _ := ret[0].(common.Value)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetSlot indicates an expected call of GetSlot.
func (mr *MockNodeMockRecorder) GetSlot(source, address, path, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSlot", reflect.TypeOf((*MockNode)(nil).GetSlot), source, address, path, key)
}</span>

// GetValue mocks base method.
func (m *MockNode) GetValue(source NodeSource, key common.Key, path []Nibble) (common.Value, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetValue", source, key, path)
        ret0, _ := ret[0].(common.Value)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetValue indicates an expected call of GetValue.
func (mr *MockNodeMockRecorder) GetValue(source, key, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValue", reflect.TypeOf((*MockNode)(nil).GetValue), source, key, path)
}</span>

// IsDirty mocks base method.
func (m *MockNode) IsDirty() bool <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsDirty")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsDirty indicates an expected call of IsDirty.
func (mr *MockNodeMockRecorder) IsDirty() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDirty", reflect.TypeOf((*MockNode)(nil).IsDirty))
}</span>

// IsFrozen mocks base method.
func (m *MockNode) IsFrozen() bool <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsFrozen")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsFrozen indicates an expected call of IsFrozen.
func (mr *MockNodeMockRecorder) IsFrozen() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFrozen", reflect.TypeOf((*MockNode)(nil).IsFrozen))
}</span>

// MarkClean mocks base method.
func (m *MockNode) MarkClean() <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "MarkClean")
}</span>

// MarkClean indicates an expected call of MarkClean.
func (mr *MockNodeMockRecorder) MarkClean() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkClean", reflect.TypeOf((*MockNode)(nil).MarkClean))
}</span>

// MarkFrozen mocks base method.
func (m *MockNode) MarkFrozen() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "MarkFrozen")
}</span>

// MarkFrozen indicates an expected call of MarkFrozen.
func (mr *MockNodeMockRecorder) MarkFrozen() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkFrozen", reflect.TypeOf((*MockNode)(nil).MarkFrozen))
}</span>

// Release mocks base method.
func (m *MockNode) Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Release", manager, thisRef, this)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Release indicates an expected call of Release.
func (mr *MockNodeMockRecorder) Release(manager, thisRef, this any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockNode)(nil).Release), manager, thisRef, this)
}</span>

// SetAccount mocks base method.
func (m *MockNode) SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetAccount", manager, thisRef, this, address, path, info)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SetAccount indicates an expected call of SetAccount.
func (mr *MockNodeMockRecorder) SetAccount(manager, thisRef, this, address, path, info any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAccount", reflect.TypeOf((*MockNode)(nil).SetAccount), manager, thisRef, this, address, path, info)
}</span>

// SetHash mocks base method.
func (m *MockNode) SetHash(arg0 common.Hash) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetHash", arg0)
}</span>

// SetHash indicates an expected call of SetHash.
func (mr *MockNodeMockRecorder) SetHash(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetHash", reflect.TypeOf((*MockNode)(nil).SetHash), arg0)
}</span>

// SetSlot mocks base method.
func (m *MockNode) SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetSlot", manager, thisRef, this, address, path, key, value)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SetSlot indicates an expected call of SetSlot.
func (mr *MockNodeMockRecorder) SetSlot(manager, thisRef, this, address, path, key, value any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSlot", reflect.TypeOf((*MockNode)(nil).SetSlot), manager, thisRef, this, address, path, key, value)
}</span>

// SetValue mocks base method.
func (m *MockNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetValue", manager, thisRef, this, key, path, value)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SetValue indicates an expected call of SetValue.
func (mr *MockNodeMockRecorder) SetValue(manager, thisRef, this, key, path, value any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetValue", reflect.TypeOf((*MockNode)(nil).SetValue), manager, thisRef, this, key, path, value)
}</span>

// Visit mocks base method.
func (m *MockNode) Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Visit", source, thisRef, depth, visitor)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Visit indicates an expected call of Visit.
func (mr *MockNodeMockRecorder) Visit(source, thisRef, depth, visitor any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Visit", reflect.TypeOf((*MockNode)(nil).Visit), source, thisRef, depth, visitor)
}</span>

// MockNodeSource is a mock of NodeSource interface.
type MockNodeSource struct {
        ctrl     *gomock.Controller
        recorder *MockNodeSourceMockRecorder
}

// MockNodeSourceMockRecorder is the mock recorder for MockNodeSource.
type MockNodeSourceMockRecorder struct {
        mock *MockNodeSource
}

// NewMockNodeSource creates a new mock instance.
func NewMockNodeSource(ctrl *gomock.Controller) *MockNodeSource <span class="cov8" title="1">{
        mock := &amp;MockNodeSource{ctrl: ctrl}
        mock.recorder = &amp;MockNodeSourceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNodeSource) EXPECT() *MockNodeSourceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// getConfig mocks base method.
func (m *MockNodeSource) getConfig() MptConfig <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getConfig")
        ret0, _ := ret[0].(MptConfig)
        return ret0
}</span>

// getConfig indicates an expected call of getConfig.
func (mr *MockNodeSourceMockRecorder) getConfig() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getConfig", reflect.TypeOf((*MockNodeSource)(nil).getConfig))
}</span>

// getHashFor mocks base method.
func (m *MockNodeSource) getHashFor(arg0 *NodeReference) (common.Hash, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getHashFor", arg0)
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getHashFor indicates an expected call of getHashFor.
func (mr *MockNodeSourceMockRecorder) getHashFor(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getHashFor", reflect.TypeOf((*MockNodeSource)(nil).getHashFor), arg0)
}</span>

// getReadAccess mocks base method.
func (m *MockNodeSource) getReadAccess(arg0 *NodeReference) (shared.ReadHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getReadAccess", arg0)
        ret0, _ := ret[0].(shared.ReadHandle[Node])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getReadAccess indicates an expected call of getReadAccess.
func (mr *MockNodeSourceMockRecorder) getReadAccess(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getReadAccess", reflect.TypeOf((*MockNodeSource)(nil).getReadAccess), arg0)
}</span>

// getViewAccess mocks base method.
func (m *MockNodeSource) getViewAccess(arg0 *NodeReference) (shared.ViewHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getViewAccess", arg0)
        ret0, _ := ret[0].(shared.ViewHandle[Node])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getViewAccess indicates an expected call of getViewAccess.
func (mr *MockNodeSourceMockRecorder) getViewAccess(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getViewAccess", reflect.TypeOf((*MockNodeSource)(nil).getViewAccess), arg0)
}</span>

// hashAddress mocks base method.
func (m *MockNodeSource) hashAddress(address common.Address) common.Hash <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "hashAddress", address)
        ret0, _ := ret[0].(common.Hash)
        return ret0
}</span>

// hashAddress indicates an expected call of hashAddress.
func (mr *MockNodeSourceMockRecorder) hashAddress(address any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "hashAddress", reflect.TypeOf((*MockNodeSource)(nil).hashAddress), address)
}</span>

// hashKey mocks base method.
func (m *MockNodeSource) hashKey(arg0 common.Key) common.Hash <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "hashKey", arg0)
        ret0, _ := ret[0].(common.Hash)
        return ret0
}</span>

// hashKey indicates an expected call of hashKey.
func (mr *MockNodeSourceMockRecorder) hashKey(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "hashKey", reflect.TypeOf((*MockNodeSource)(nil).hashKey), arg0)
}</span>

// MockNodeManager is a mock of NodeManager interface.
type MockNodeManager struct {
        ctrl     *gomock.Controller
        recorder *MockNodeManagerMockRecorder
}

// MockNodeManagerMockRecorder is the mock recorder for MockNodeManager.
type MockNodeManagerMockRecorder struct {
        mock *MockNodeManager
}

// NewMockNodeManager creates a new mock instance.
func NewMockNodeManager(ctrl *gomock.Controller) *MockNodeManager <span class="cov8" title="1">{
        mock := &amp;MockNodeManager{ctrl: ctrl}
        mock.recorder = &amp;MockNodeManagerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNodeManager) EXPECT() *MockNodeManagerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// createAccount mocks base method.
func (m *MockNodeManager) createAccount() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "createAccount")
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(shared.WriteHandle[Node])
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// createAccount indicates an expected call of createAccount.
func (mr *MockNodeManagerMockRecorder) createAccount() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "createAccount", reflect.TypeOf((*MockNodeManager)(nil).createAccount))
}</span>

// createBranch mocks base method.
func (m *MockNodeManager) createBranch() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "createBranch")
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(shared.WriteHandle[Node])
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// createBranch indicates an expected call of createBranch.
func (mr *MockNodeManagerMockRecorder) createBranch() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "createBranch", reflect.TypeOf((*MockNodeManager)(nil).createBranch))
}</span>

// createExtension mocks base method.
func (m *MockNodeManager) createExtension() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "createExtension")
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(shared.WriteHandle[Node])
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// createExtension indicates an expected call of createExtension.
func (mr *MockNodeManagerMockRecorder) createExtension() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "createExtension", reflect.TypeOf((*MockNodeManager)(nil).createExtension))
}</span>

// createValue mocks base method.
func (m *MockNodeManager) createValue() (NodeReference, shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "createValue")
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(shared.WriteHandle[Node])
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// createValue indicates an expected call of createValue.
func (mr *MockNodeManagerMockRecorder) createValue() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "createValue", reflect.TypeOf((*MockNodeManager)(nil).createValue))
}</span>

// getConfig mocks base method.
func (m *MockNodeManager) getConfig() MptConfig <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getConfig")
        ret0, _ := ret[0].(MptConfig)
        return ret0
}</span>

// getConfig indicates an expected call of getConfig.
func (mr *MockNodeManagerMockRecorder) getConfig() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getConfig", reflect.TypeOf((*MockNodeManager)(nil).getConfig))
}</span>

// getHashAccess mocks base method.
func (m *MockNodeManager) getHashAccess(arg0 *NodeReference) (shared.HashHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getHashAccess", arg0)
        ret0, _ := ret[0].(shared.HashHandle[Node])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getHashAccess indicates an expected call of getHashAccess.
func (mr *MockNodeManagerMockRecorder) getHashAccess(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getHashAccess", reflect.TypeOf((*MockNodeManager)(nil).getHashAccess), arg0)
}</span>

// getHashFor mocks base method.
func (m *MockNodeManager) getHashFor(arg0 *NodeReference) (common.Hash, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getHashFor", arg0)
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getHashFor indicates an expected call of getHashFor.
func (mr *MockNodeManagerMockRecorder) getHashFor(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getHashFor", reflect.TypeOf((*MockNodeManager)(nil).getHashFor), arg0)
}</span>

// getReadAccess mocks base method.
func (m *MockNodeManager) getReadAccess(arg0 *NodeReference) (shared.ReadHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getReadAccess", arg0)
        ret0, _ := ret[0].(shared.ReadHandle[Node])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getReadAccess indicates an expected call of getReadAccess.
func (mr *MockNodeManagerMockRecorder) getReadAccess(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getReadAccess", reflect.TypeOf((*MockNodeManager)(nil).getReadAccess), arg0)
}</span>

// getViewAccess mocks base method.
func (m *MockNodeManager) getViewAccess(arg0 *NodeReference) (shared.ViewHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getViewAccess", arg0)
        ret0, _ := ret[0].(shared.ViewHandle[Node])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getViewAccess indicates an expected call of getViewAccess.
func (mr *MockNodeManagerMockRecorder) getViewAccess(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getViewAccess", reflect.TypeOf((*MockNodeManager)(nil).getViewAccess), arg0)
}</span>

// getWriteAccess mocks base method.
func (m *MockNodeManager) getWriteAccess(arg0 *NodeReference) (shared.WriteHandle[Node], error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "getWriteAccess", arg0)
        ret0, _ := ret[0].(shared.WriteHandle[Node])
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// getWriteAccess indicates an expected call of getWriteAccess.
func (mr *MockNodeManagerMockRecorder) getWriteAccess(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "getWriteAccess", reflect.TypeOf((*MockNodeManager)(nil).getWriteAccess), arg0)
}</span>

// hashAddress mocks base method.
func (m *MockNodeManager) hashAddress(address common.Address) common.Hash <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "hashAddress", address)
        ret0, _ := ret[0].(common.Hash)
        return ret0
}</span>

// hashAddress indicates an expected call of hashAddress.
func (mr *MockNodeManagerMockRecorder) hashAddress(address any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "hashAddress", reflect.TypeOf((*MockNodeManager)(nil).hashAddress), address)
}</span>

// hashKey mocks base method.
func (m *MockNodeManager) hashKey(arg0 common.Key) common.Hash <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "hashKey", arg0)
        ret0, _ := ret[0].(common.Hash)
        return ret0
}</span>

// hashKey indicates an expected call of hashKey.
func (mr *MockNodeManagerMockRecorder) hashKey(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "hashKey", reflect.TypeOf((*MockNodeManager)(nil).hashKey), arg0)
}</span>

// release mocks base method.
func (m *MockNodeManager) release(arg0 *NodeReference) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "release", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// release indicates an expected call of release.
func (mr *MockNodeManagerMockRecorder) release(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "release", reflect.TypeOf((*MockNodeManager)(nil).release), arg0)
}</span>

// releaseTrieAsynchronous mocks base method.
func (m *MockNodeManager) releaseTrieAsynchronous(arg0 NodeReference) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "releaseTrieAsynchronous", arg0)
}</span>

// releaseTrieAsynchronous indicates an expected call of releaseTrieAsynchronous.
func (mr *MockNodeManagerMockRecorder) releaseTrieAsynchronous(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "releaseTrieAsynchronous", reflect.TypeOf((*MockNodeManager)(nil).releaseTrieAsynchronous), arg0)
}</span>

// MockleafNode is a mock of leafNode interface.
type MockleafNode struct {
        ctrl     *gomock.Controller
        recorder *MockleafNodeMockRecorder
}

// MockleafNodeMockRecorder is the mock recorder for MockleafNode.
type MockleafNodeMockRecorder struct {
        mock *MockleafNode
}

// NewMockleafNode creates a new mock instance.
func NewMockleafNode(ctrl *gomock.Controller) *MockleafNode <span class="cov0" title="0">{
        mock := &amp;MockleafNode{ctrl: ctrl}
        mock.recorder = &amp;MockleafNodeMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockleafNode) EXPECT() *MockleafNodeMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Check mocks base method.
func (m *MockleafNode) Check(source NodeSource, thisRef *NodeReference, path []Nibble) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Check", source, thisRef, path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Check indicates an expected call of Check.
func (mr *MockleafNodeMockRecorder) Check(source, thisRef, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockleafNode)(nil).Check), source, thisRef, path)
}</span>

// ClearStorage mocks base method.
func (m *MockleafNode) ClearStorage(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ClearStorage", manager, thisRef, this, address, path)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// ClearStorage indicates an expected call of ClearStorage.
func (mr *MockleafNodeMockRecorder) ClearStorage(manager, thisRef, this, address, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearStorage", reflect.TypeOf((*MockleafNode)(nil).ClearStorage), manager, thisRef, this, address, path)
}</span>

// Dump mocks base method.
func (m *MockleafNode) Dump(dest io.Writer, source NodeSource, thisRef *NodeReference, indent string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Dump", dest, source, thisRef, indent)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Dump indicates an expected call of Dump.
func (mr *MockleafNodeMockRecorder) Dump(dest, source, thisRef, indent any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockleafNode)(nil).Dump), dest, source, thisRef, indent)
}</span>

// Freeze mocks base method.
func (m *MockleafNode) Freeze(manager NodeManager, this shared.WriteHandle[Node]) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Freeze", manager, this)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Freeze indicates an expected call of Freeze.
func (mr *MockleafNodeMockRecorder) Freeze(manager, this any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Freeze", reflect.TypeOf((*MockleafNode)(nil).Freeze), manager, this)
}</span>

// GetAccount mocks base method.
func (m *MockleafNode) GetAccount(source NodeSource, address common.Address, path []Nibble) (AccountInfo, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAccount", source, address, path)
        ret0, _ := ret[0].(AccountInfo)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAccount indicates an expected call of GetAccount.
func (mr *MockleafNodeMockRecorder) GetAccount(source, address, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockleafNode)(nil).GetAccount), source, address, path)
}</span>

// GetHash mocks base method.
func (m *MockleafNode) GetHash() (common.Hash, bool) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetHash")
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(bool)
        return ret0, ret1
}</span>

// GetHash indicates an expected call of GetHash.
func (mr *MockleafNodeMockRecorder) GetHash() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHash", reflect.TypeOf((*MockleafNode)(nil).GetHash))
}</span>

// GetSlot mocks base method.
func (m *MockleafNode) GetSlot(source NodeSource, address common.Address, path []Nibble, key common.Key) (common.Value, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSlot", source, address, path, key)
        ret0, _ := ret[0].(common.Value)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetSlot indicates an expected call of GetSlot.
func (mr *MockleafNodeMockRecorder) GetSlot(source, address, path, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSlot", reflect.TypeOf((*MockleafNode)(nil).GetSlot), source, address, path, key)
}</span>

// GetValue mocks base method.
func (m *MockleafNode) GetValue(source NodeSource, key common.Key, path []Nibble) (common.Value, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetValue", source, key, path)
        ret0, _ := ret[0].(common.Value)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetValue indicates an expected call of GetValue.
func (mr *MockleafNodeMockRecorder) GetValue(source, key, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValue", reflect.TypeOf((*MockleafNode)(nil).GetValue), source, key, path)
}</span>

// IsDirty mocks base method.
func (m *MockleafNode) IsDirty() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsDirty")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsDirty indicates an expected call of IsDirty.
func (mr *MockleafNodeMockRecorder) IsDirty() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDirty", reflect.TypeOf((*MockleafNode)(nil).IsDirty))
}</span>

// IsFrozen mocks base method.
func (m *MockleafNode) IsFrozen() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsFrozen")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsFrozen indicates an expected call of IsFrozen.
func (mr *MockleafNodeMockRecorder) IsFrozen() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFrozen", reflect.TypeOf((*MockleafNode)(nil).IsFrozen))
}</span>

// MarkClean mocks base method.
func (m *MockleafNode) MarkClean() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "MarkClean")
}</span>

// MarkClean indicates an expected call of MarkClean.
func (mr *MockleafNodeMockRecorder) MarkClean() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkClean", reflect.TypeOf((*MockleafNode)(nil).MarkClean))
}</span>

// MarkFrozen mocks base method.
func (m *MockleafNode) MarkFrozen() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "MarkFrozen")
}</span>

// MarkFrozen indicates an expected call of MarkFrozen.
func (mr *MockleafNodeMockRecorder) MarkFrozen() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkFrozen", reflect.TypeOf((*MockleafNode)(nil).MarkFrozen))
}</span>

// Release mocks base method.
func (m *MockleafNode) Release(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node]) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Release", manager, thisRef, this)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Release indicates an expected call of Release.
func (mr *MockleafNodeMockRecorder) Release(manager, thisRef, this any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockleafNode)(nil).Release), manager, thisRef, this)
}</span>

// SetAccount mocks base method.
func (m *MockleafNode) SetAccount(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, info AccountInfo) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetAccount", manager, thisRef, this, address, path, info)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SetAccount indicates an expected call of SetAccount.
func (mr *MockleafNodeMockRecorder) SetAccount(manager, thisRef, this, address, path, info any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAccount", reflect.TypeOf((*MockleafNode)(nil).SetAccount), manager, thisRef, this, address, path, info)
}</span>

// SetHash mocks base method.
func (m *MockleafNode) SetHash(arg0 common.Hash) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetHash", arg0)
}</span>

// SetHash indicates an expected call of SetHash.
func (mr *MockleafNodeMockRecorder) SetHash(arg0 any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetHash", reflect.TypeOf((*MockleafNode)(nil).SetHash), arg0)
}</span>

// SetSlot mocks base method.
func (m *MockleafNode) SetSlot(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], address common.Address, path []Nibble, key common.Key, value common.Value) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetSlot", manager, thisRef, this, address, path, key, value)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SetSlot indicates an expected call of SetSlot.
func (mr *MockleafNodeMockRecorder) SetSlot(manager, thisRef, this, address, path, key, value any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSlot", reflect.TypeOf((*MockleafNode)(nil).SetSlot), manager, thisRef, this, address, path, key, value)
}</span>

// SetValue mocks base method.
func (m *MockleafNode) SetValue(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], key common.Key, path []Nibble, value common.Value) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetValue", manager, thisRef, this, key, path, value)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// SetValue indicates an expected call of SetValue.
func (mr *MockleafNodeMockRecorder) SetValue(manager, thisRef, this, key, path, value any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetValue", reflect.TypeOf((*MockleafNode)(nil).SetValue), manager, thisRef, this, key, path, value)
}</span>

// Visit mocks base method.
func (m *MockleafNode) Visit(source NodeSource, thisRef *NodeReference, depth int, visitor NodeVisitor) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Visit", source, thisRef, depth, visitor)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Visit indicates an expected call of Visit.
func (mr *MockleafNodeMockRecorder) Visit(source, thisRef, depth, visitor any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Visit", reflect.TypeOf((*MockleafNode)(nil).Visit), source, thisRef, depth, visitor)
}</span>

// setPathLength mocks base method.
func (m *MockleafNode) setPathLength(manager NodeManager, thisRef *NodeReference, this shared.WriteHandle[Node], length byte) (NodeReference, bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "setPathLength", manager, thisRef, this, length)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// setPathLength indicates an expected call of setPathLength.
func (mr *MockleafNodeMockRecorder) setPathLength(manager, thisRef, this, length any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "setPathLength", reflect.TypeOf((*MockleafNode)(nil).setPathLength), manager, thisRef, this, length)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "fmt"
        "strings"
)

// Path is a sequence of nibble's describing a navigation path in a Trie.
// Paths are used in expansion nodes to short-cut multiple steps in the
// trie which would otherwise require numerous branch nodes.
// Unlike []Nibble slices, Paths are encoding pairs of 4-bit Nibbles into
// 8-bit values for a dense data representation. Also, paths are limited
// to a maximum length of 64 Nibbles.
type Path struct {
        // The zero-padded navigation path to be covered. The maximum length
        // is 256 bits, which are 32 bytes and 64 nibbles. Nibbles are encoded
        // in bytes in little-endian order.
        path [32]byte
        // The length of the relevant prefix of the path to be represented in
        // number of nibbles (= 4bit values). Limited to &lt;= 64.
        length uint8
}

// SingleStepPath creates a path consisting of a single step.
func SingleStepPath(n Nibble) Path <span class="cov8" title="1">{
        return Path{path: [32]byte{byte(n) &lt;&lt; 4}, length: uint8(1)}
}</span>

// CreatePathFromNibbles converts a Nibble-slice into a path.
func CreatePathFromNibbles(path []Nibble) Path <span class="cov8" title="1">{
        res := Path{}
        for _, cur := range path </span><span class="cov8" title="1">{
                res.Append(cur)
        }</span>
        <span class="cov8" title="1">return res</span>
}

// Length returns the length of the path.
func (p *Path) Length() int <span class="cov8" title="1">{
        return int(p.length)
}</span>

// GetPackedNibbles returns a slice of nibbles encoded in consecutive high/low
// bits of bytes. If the path length is odd, a leading 0 is added.
func (p *Path) GetPackedNibbles() []byte <span class="cov8" title="1">{
        // If the length is even, we can return a prefix of the path.
        if p.length%2 == 0 </span><span class="cov8" title="1">{
                return p.path[:p.length/2]
        }</span>
        // Otherwise we need to shift the path by 4 bit.
        <span class="cov8" title="1">length := p.length/2 + 1
        res := make([]byte, length)
        res[0] = p.path[0] &gt;&gt; 4
        for i := 1; i &lt; len(res); i++ </span><span class="cov8" title="1">{
                res[i] = (p.path[i-1]&amp;0xf)&lt;&lt;4 | (p.path[i] &gt;&gt; 4)
        }</span>
        <span class="cov8" title="1">return res</span>
}

// Get returns the Nibble value at the given path position, where pos == 0
// is the first position and Length()-1 the last. For positions outside this
// range the value 0 is returned.
func (p *Path) Get(pos int) Nibble <span class="cov8" title="1">{
        if pos &lt; 0 || pos &gt;= int(p.length) </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">twin := p.path[pos/2]
        if pos%2 == 0 </span><span class="cov8" title="1">{
                return Nibble(twin &gt;&gt; 4)
        }</span>
        <span class="cov8" title="1">return Nibble(twin &amp; 0xF)</span>
}

// Set updates the value of a Nibble on this path or ignores the call if
// the position is not on the path, thus not in the range [0,Lenght()-1].
func (p *Path) Set(pos int, val Nibble) <span class="cov8" title="1">{
        if pos &lt; 0 || pos &gt;= int(p.length) </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("out-of-range path update at %d in range [%d,%d)", pos, 0, p.length))</span>
        }
        <span class="cov8" title="1">if pos%2 == 0 </span><span class="cov8" title="1">{
                p.path[pos/2] = (p.path[pos/2] &amp; 0xF) | byte(val&lt;&lt;4)
        }</span> else<span class="cov8" title="1"> {
                p.path[pos/2] = (p.path[pos/2] &amp; 0xF0) | byte(val&amp;0xF)
        }</span>
}

// IsPrefixOf determines whether the given nibble sequence is a prefix of
// this path.
func (p *Path) IsPrefixOf(list []Nibble) bool <span class="cov8" title="1">{
        return p.GetCommonPrefixLength(list) == int(p.length)
}</span>

// IsEqualTo determines whether the given nibble sequence is equal to this path.
func (p *Path) IsEqualTo(list []Nibble) bool <span class="cov8" title="1">{
        return p.Length() == len(list) &amp;&amp; p.GetCommonPrefixLength(list) == int(p.length)
}</span>

// GetCommonPrefixLength determines the common prefix of the given Nibble
// slice and this path.
func (p *Path) GetCommonPrefixLength(list []Nibble) int <span class="cov8" title="1">{
        max := int(p.length)
        if max &gt; len(list) </span><span class="cov8" title="1">{
                max = len(list)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; max; i++ </span><span class="cov8" title="1">{
                if p.Get(i) != list[i] </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return max</span>
}

// Append appends a nibble to the end of this path extending it by one element.
func (p *Path) Append(n Nibble) *Path <span class="cov8" title="1">{
        trg := &amp;p.path[p.length/2]
        if p.length%2 == 0 </span><span class="cov8" title="1">{
                *trg |= byte(n&amp;0xF) &lt;&lt; 4
        }</span> else<span class="cov8" title="1"> {
                *trg |= byte(n &amp; 0xF)
        }</span>
        <span class="cov8" title="1">p.length++
        return p</span>
}

// AppendAll appends the given path to the end of this path.
func (p *Path) AppendAll(other *Path) *Path <span class="cov8" title="1">{
        for i := 0; i &lt; other.Length(); i++ </span><span class="cov8" title="1">{
                p.Append(other.Get(i))
        }</span>
        <span class="cov8" title="1">return p</span>
}

// Prepend adds a nibble to be begin of this path, growing it by one element.
func (p *Path) Prepend(n Nibble) *Path <span class="cov8" title="1">{
        p.length++
        for i := int(p.length) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                p.Set(i+1, p.Get(i))
        }</span>
        <span class="cov8" title="1">p.Set(0, n)
        return p</span>
}

// RemoveLast removes the last n elements from this path. If n &gt; length, the
// resulting list is empty.
func (p *Path) RemoveLast(n int) *Path <span class="cov8" title="1">{
        if n &gt; int(p.length) </span><span class="cov8" title="1">{
                p.length = 0
        }</span> else<span class="cov8" title="1"> {
                p.length -= uint8(n)
        }</span>
        <span class="cov8" title="1">return p</span>
}

// ShiftLeft shifts alle elements in the path by the given number of steps,
// dropping leading elements and reducing the path length by steps elements.
func (p *Path) ShiftLeft(steps int) *Path <span class="cov8" title="1">{
        if steps &gt;= p.Length() </span><span class="cov8" title="1">{
                *p = Path{}
                return p
        }</span>
        <span class="cov8" title="1">if steps &lt; 0 </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">if steps%2 == 0 </span><span class="cov8" title="1">{
                // Which way: we can shift full bytes.
                copy(p.path[:], p.path[steps/2:])
        }</span> else<span class="cov8" title="1"> {
                // Slower: we need to shift half-bytes.
                j := 0
                for i := 0; i &lt; int(p.length)-steps; i++ </span><span class="cov8" title="1">{
                        p.Set(j, p.Get(i+steps))
                        j++
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; steps; i++ </span><span class="cov8" title="1">{
                        p.Set(j, 0)
                        j++
                }</span>

        }
        <span class="cov8" title="1">p.length -= uint8(steps)
        return p</span>
}

func (p *Path) String() string <span class="cov8" title="1">{
        if p.length == 0 </span><span class="cov8" title="1">{
                return "-empty-"
        }</span>
        <span class="cov8" title="1">builder := strings.Builder{}
        for i := 0; i &lt; p.Length(); i++ </span><span class="cov8" title="1">{
                builder.WriteRune(p.Get(i).Rune())
        }</span>
        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf(" : %d", p.length))
        return builder.String()</span>
}

// ----------------------------------------------------------------------------
//                               Path Encoder
// ----------------------------------------------------------------------------

type PathEncoder struct{}

func (PathEncoder) GetEncodedSize() int <span class="cov8" title="1">{
        return 33
}</span>

func (PathEncoder) Store(trg []byte, path *Path) <span class="cov8" title="1">{
        copy(trg, path.path[:])
        trg[32] = path.length
}</span>

func (PathEncoder) Load(src []byte, path *Path) <span class="cov8" title="1">{
        copy(path.path[:], src)
        path.length = uint8(src[32])
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "bytes"
        "errors"
        "fmt"
        "slices"
        "sort"
        "strings"

        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/common/amount"
        "github.com/Fantom-foundation/Carmen/go/common/tribool"
        "golang.org/x/exp/maps"
)

//go:generate mockgen -source proof.go -destination proof_mocks.go -package mpt

// rlpEncodedNode is an RLP encoded MPT node.
type rlpEncodedNode []byte

// rlpEncodedNodeEquals returns true if the two RLP encoded nodes are equal.
func rlpEncodedNodeEquals(a, b rlpEncodedNode) bool <span class="cov8" title="1">{
        return bytes.Equal(a, b)
}</span>

// proofDb is a database of RLP encoded MPT nodes and their hashes that represent witness proofs.
type proofDb map[common.Hash]rlpEncodedNode

// WitnessProof represents a witness proof.
// It contains a database of MPT nodes and their hashes.
type WitnessProof struct {
        proofDb
}

// CreateWitnessProofFromNodes creates a witness proof from a list of strings.
// Each string is an RLP node of the witness proof.
func CreateWitnessProofFromNodes(nodes []string) WitnessProof <span class="cov8" title="1">{
        db := make(proofDb, len(nodes))
        for _, n := range nodes </span><span class="cov8" title="1">{
                h := common.Keccak256([]byte(n))
                db[h] = []byte(n)
        }</span>

        <span class="cov8" title="1">return WitnessProof{db}</span>
}

// CreateWitnessProof creates a witness proof for the input account address
// and possibly storage slots of the same account under the input storage keys.
// This method may return an error when it occurs in the underlying database.
func CreateWitnessProof(nodeSource NodeSource, root *NodeReference, address common.Address, keys ...common.Key) (WitnessProof, error) <span class="cov8" title="1">{
        proof := proofDb{}
        visitor := &amp;proofExtractionVisitor{
                nodeSource: nodeSource,
                proof:      proof,
        }

        var innerError error

        _, err := VisitPathToAccount(nodeSource, root, address, MakeVisitor(func(node Node, info NodeInfo) VisitResponse </span><span class="cov8" title="1">{
                if res := visitor.Visit(node, info); res == VisitResponseAbort </span><span class="cov8" title="1">{
                        return VisitResponseAbort
                }</span>
                // if account reached, prove storage keys and terminate.
                <span class="cov8" title="1">if account, ok := node.(*AccountNode); ok </span><span class="cov8" title="1">{
                        for _, key := range keys </span><span class="cov8" title="1">{
                                _, err := VisitPathToStorage(nodeSource, &amp;account.storage, key, visitor)
                                if err != nil || visitor.err != nil </span><span class="cov8" title="1">{
                                        innerError = errors.Join(innerError, visitor.err, err)
                                        return VisitResponseAbort
                                }</span>
                        }
                        <span class="cov8" title="1">return VisitResponseAbort</span>
                }

                <span class="cov8" title="1">return VisitResponseContinue</span>
        }))

        <span class="cov8" title="1">return WitnessProof{proof}, errors.Join(innerError, visitor.err, err)</span>
}

// Add merges the input witness proof into the current witness proof.
func (p WitnessProof) Add(other WitnessProof) <span class="cov8" title="1">{
        for k, v := range other.proofDb </span><span class="cov8" title="1">{
                p.proofDb[k] = v
        }</span>
}

// Extract extracts a sub-proof for a given account and selected storage locations from this proof.
// It returns a copy that contains only the data necessary for proving the given address and storage keys.
// The resulting proof covers proofs for the intersection of the requested properties (account information and slots)
// and the properties covered by this proof. The second return parameter indicates whether everything that
// was requested could be covered. If so it is set to true, otherwise it is set to false.
func (p WitnessProof) Extract(root common.Hash, address common.Address, keys ...common.Key) (WitnessProof, bool) <span class="cov8" title="1">{
        result := proofDb{}
        visitor := &amp;proofCollectingVisitor{visited: result}
        found, complete, err := visitWitnessPathTo(p.proofDb, root, addressToHashedNibbles(address), visitor)
        if err != nil || !found </span><span class="cov8" title="1">{
                return WitnessProof{result}, complete
        }</span>

        <span class="cov8" title="1">storageRoot := visitor.visitedAccount.storageHash
        for _, key := range keys </span><span class="cov8" title="1">{
                _, completeKey, err := visitWitnessPathTo(p.proofDb, storageRoot, keyToHashedPathNibbles(key), visitor)
                if err != nil || !completeKey </span><span class="cov0" title="0">{
                        complete = false
                }</span>
        }

        <span class="cov8" title="1">return WitnessProof{result}, complete</span>
}

// IsValid checks that this proof is self-consistent. If the result is true, the proof can be used
// for extracting verified information. If false, the proof is corrupted and should be discarded.
func (p WitnessProof) IsValid() bool <span class="cov8" title="1">{
        for k, v := range p.proofDb </span><span class="cov8" title="1">{
                if k != common.Keccak256(v) </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">_, err := DecodeFromRlp(v)
                if err != nil </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// GetAccountInfo extracts an account info from the witness proof for the input root hash and the address.
// This method returns true, if the inputs could be proven. In this case, the first return parameter gives
// the actual value. If the methods return false, the input could not be proved, and the returned value
// is undefined.
// The method may return an error if the proof is invalid.
func (p WitnessProof) GetAccountInfo(root common.Hash, address common.Address) (AccountInfo, bool, error) <span class="cov8" title="1">{
        return witnessAccountFieldGetter(p.proofDb, root, address, func(n AccountNode) AccountInfo </span><span class="cov8" title="1">{
                return n.Info()
        }</span>)
}

// GetBalance extracts a balance from the witness proof for the input root hash and the address.
// This method returns true, if the inputs could be proven. In this case, the first return parameter gives
// the actual value. If the methods return false, the input could not be proved, and the returned value
// is undefined.
// The method may return an error if the proof is invalid.
func (p WitnessProof) GetBalance(root common.Hash, address common.Address) (amount.Amount, bool, error) <span class="cov8" title="1">{
        return witnessAccountFieldGetter(p.proofDb, root, address, func(n AccountNode) amount.Amount </span><span class="cov8" title="1">{
                return n.Info().Balance
        }</span>)
}

// GetNonce extracts a nonce from the witness proof for the input root hash and the address.
// This method returns true, if the inputs could be proven. In this case, the first return parameter gives
// the actual value. If the methods return false, the input could not be proved, and the returned value
// is undefined.
// The method may return an error if the proof is invalid.
func (p WitnessProof) GetNonce(root common.Hash, address common.Address) (common.Nonce, bool, error) <span class="cov8" title="1">{
        return witnessAccountFieldGetter(p.proofDb, root, address, func(n AccountNode) common.Nonce </span><span class="cov8" title="1">{
                return n.Info().Nonce
        }</span>)
}

// GetCodeHash extracts a code hash from the witness proof for the input root hash and the address.
// This method returns true, if the inputs could be proven. In this case, the first return parameter gives
// the actual value. If the methods return false, the input could not be proved, and the returned value
// is undefined.
// The method may return an error if the proof is invalid.
func (p WitnessProof) GetCodeHash(root common.Hash, address common.Address) (common.Hash, bool, error) <span class="cov8" title="1">{
        return witnessAccountFieldGetter(p.proofDb, root, address, func(n AccountNode) common.Hash </span><span class="cov8" title="1">{
                return n.Info().CodeHash
        }</span>)
}

// GetState extracts a storage slot from the witness proof for the input root hash, account address and the storage key.
// If the proof was complete, this method returns true, otherwise it returns false.
// The proof was complete if it could fully determine either existence or non-existence of the slot.
// In other words, it was possible to reach either a value node or an empty node.
// The method may return an error if the proof is invalid.
func (p WitnessProof) GetState(root common.Hash, address common.Address, key common.Key) (common.Value, bool, error) <span class="cov8" title="1">{
        visitor := &amp;proofCollectingVisitor{}
        found, complete, err := visitWitnessPathTo(p.proofDb, root, addressToHashedNibbles(address), visitor)
        if err != nil || !found </span><span class="cov8" title="1">{
                return common.Value{}, complete, err
        }</span>

        <span class="cov8" title="1">storageRoot := visitor.visitedAccount.storageHash
        found, complete, err = visitWitnessPathTo(p.proofDb, storageRoot, keyToHashedPathNibbles(key), visitor)
        if err != nil || !found </span><span class="cov8" title="1">{
                return common.Value{}, complete, err
        }</span>

        <span class="cov8" title="1">return visitor.visitedValue.value, true, nil</span>
}

// AllStatesZero checks that all storage slots are empty for the input root hash,
// account address and the storage key range. If the witness proof contains all empty slots
// for the input key range, it returns true. If there is at least one non-empty slot,
// it returns false. If the proof is not complete, it returns unknown. An incomplete proof
// is a proof where the input address or key terminates in a node that is not a correct
// value node, or an empty node.
func (p WitnessProof) AllStatesZero(root common.Hash, address common.Address, from, to common.Key) (tribool.Tribool, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

// AllAddressesEmpty checks that all accounts are empty for the input root hash and the address range.
// If the witness proof contains all empty accounts for the input address range, it returns true.
// An empty account is an account that contains a zero balance, nonce, and code hash.
// If there is at least one non-empty account, it returns false. If the proof is not complete,
// it returns unknown. An incomplete proof is a proof where the input address terminates in a node
// that is not a correct account node.
func (p WitnessProof) AllAddressesEmpty(root common.Hash, from, to common.Address) (tribool.Tribool, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

// Equals returns true if the two witness proofs are equal.
func (p WitnessProof) Equals(other WitnessProof) bool <span class="cov8" title="1">{
        return maps.EqualFunc(p.proofDb, other.proofDb, rlpEncodedNodeEquals)
}</span>

// proofExtractionVisitor is a visitor that visits MPT nodes and creates a witness proof.
// It hashes and encodes the nodes and stores them into the proof database.
type proofExtractionVisitor struct {
        proof      proofDb
        nodeSource NodeSource
        err        error
}

// Visit computes RLP and hash of the visited node and puts it to the proof.
func (p *proofExtractionVisitor) Visit(node Node, info NodeInfo) VisitResponse <span class="cov8" title="1">{
        if info.Embedded.True() </span><span class="cov8" title="1">{
                return VisitResponseAbort
        }</span>

        // node child hashes will be dirty for the archive when hashes are stored with nodes
        // and must be loaded here for witness proof.
        <span class="cov8" title="1">switch n := node.(type) </span>{
        case *ExtensionNode:<span class="cov8" title="1">
                if n.nextHashDirty </span><span class="cov0" title="0">{
                        nextHandle, err := p.nodeSource.getViewAccess(&amp;n.next)
                        if err != nil </span><span class="cov0" title="0">{
                                p.err = err
                                return VisitResponseAbort
                        }</span>
                        <span class="cov0" title="0">embedded, err := isNodeEmbedded(nextHandle.Get(), p.nodeSource)
                        nextHandle.Release()
                        if err != nil </span><span class="cov0" title="0">{
                                p.err = err
                                return VisitResponseAbort
                        }</span>
                        <span class="cov0" title="0">if err := updateChildrenHashes(p.nodeSource, n, map[NodeId]bool{n.next.Id(): embedded}); err != nil </span><span class="cov0" title="0">{
                                p.err = err
                                return VisitResponseAbort
                        }</span>
                }
        case *BranchNode:<span class="cov8" title="1">
                if n.dirtyHashes != 0 </span><span class="cov8" title="1">{
                        embeddedChildren := make(map[NodeId]bool, 16)
                        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                                if n.isChildHashDirty(byte(i)) </span><span class="cov8" title="1">{
                                        childHandle, err := p.nodeSource.getViewAccess(&amp;n.children[i])
                                        if err != nil </span><span class="cov8" title="1">{
                                                p.err = err
                                                return VisitResponseAbort
                                        }</span>
                                        <span class="cov8" title="1">embedded, err := isNodeEmbedded(childHandle.Get(), p.nodeSource)
                                        childHandle.Release()
                                        if err != nil </span><span class="cov8" title="1">{
                                                p.err = err
                                                return VisitResponseAbort
                                        }</span>
                                        <span class="cov8" title="1">embeddedChildren[n.children[i].Id()] = embedded</span>
                                }
                        }

                        <span class="cov8" title="1">if err := updateChildrenHashes(p.nodeSource, n, embeddedChildren); err != nil </span><span class="cov8" title="1">{
                                p.err = err
                                return VisitResponseAbort
                        }</span>
                }
        case *AccountNode:<span class="cov8" title="1">
                if n.storageHashDirty </span><span class="cov8" title="1">{
                        if err := updateChildrenHashes(p.nodeSource, n, map[NodeId]bool{n.storage.Id(): false}); err != nil </span><span class="cov0" title="0">{
                                p.err = err
                                return VisitResponseAbort
                        }</span>
                }
        }

        <span class="cov8" title="1">data := make([]byte, 0, 1024)
        rlp, err := encodeToRlp(node, p.nodeSource, data)
        if err != nil </span><span class="cov8" title="1">{
                p.err = err
                return VisitResponseAbort
        }</span>
        <span class="cov8" title="1">hash := common.Keccak256(rlp)

        p.proof[hash] = rlp

        return VisitResponseContinue</span>
}

// String returns a string representation of the witness proof.
// The representation contains all nodes sorted by their hash.
func (p WitnessProof) String() string <span class="cov8" title="1">{
        // Extract keys and sort them
        keys := maps.Keys(p.proofDb)
        cmp := common.HashComparator{}
        sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                return cmp.Compare(&amp;keys[i], &amp;keys[j]) &lt;= 0
        }</span>)

        // Build the string representation
        <span class="cov8" title="1">var b strings.Builder
        for _, k := range keys </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("0x%x-&gt;0x%x\n", k, p.proofDb[k]))
        }</span>
        <span class="cov8" title="1">return b.String()</span>
}

// GetElements returns serialised elements of the witness proof.
func (p WitnessProof) GetElements() []string <span class="cov8" title="1">{
        res := make([]string, 0, len(p.proofDb))
        for _, v := range p.proofDb </span><span class="cov8" title="1">{
                res = append(res, string(v))
        }</span>
        <span class="cov8" title="1">return res</span>
}

// MergeProofs merges the input witness proofs and returns the resulting witness proof.
func MergeProofs(others ...WitnessProof) WitnessProof <span class="cov8" title="1">{
        res := WitnessProof{make(proofDb)}
        for _, other := range others </span><span class="cov8" title="1">{
                res.Add(other)
        }</span>

        <span class="cov8" title="1">return res</span>
}

// witnessAccountFieldGetter extracts an account field from the witness proof for the input root hash and the address.
// Which particular field to extract is given by the callback function.
// This method returns true, if the inputs could be proven. In this case, the first return parameter gives
// the actual value. If the methods return false, the input could not be proved, and the returned value
// is undefined.
// The method may return an error if the proof is invalid.
func witnessAccountFieldGetter[T any](source proofDb, root common.Hash, address common.Address, getter func(AccountNode) T) (T, bool, error) <span class="cov8" title="1">{
        visitor := &amp;proofCollectingVisitor{}
        found, complete, err := visitWitnessPathTo(source, root, addressToHashedNibbles(address), visitor)
        if err != nil || !found </span><span class="cov8" title="1">{
                var empty T
                return empty, complete, err
        }</span>
        <span class="cov8" title="1">return getter(visitor.visitedAccount.AccountNode), true, nil</span>
}

// visitWitnessPathTo visits all nodes from the input root following the input path.
// Each encountered node is passed to the visitor.
// If no more nodes are available on the path, the execution ends.
// When the function reaches either an account node or a value node it is compared to the remaining input path
// that was not iterated yet.
// If the path matches, the function terminates and returns found equals to true.
// The function determines if the proof was complete.
// The proof is complete if it reaches a terminal node, where it could either fully consume the path,
// or determine that the path cannot recurse to further nodes.
// The proof is incomplete when the path could not be fully iterated and reached a node that is not in the proof.
// The function returns an error if the path cannot be iterated due to error propagated from the input proof.
func visitWitnessPathTo(source proofDb, root common.Hash, path []Nibble, visitor witnessProofVisitor) (found, complete bool, err error) <span class="cov8" title="1">{
        nodeHash := root

        var nextEmbedded, currentEmbedded bool
        var done bool
        for !done &amp;&amp; nodeHash != EmptyNodeEthereumHash </span><span class="cov8" title="1">{
                var rlpNode rlpEncodedNode
                if nextEmbedded </span><span class="cov8" title="1">{
                        rlpNode = nodeHash[:]
                }</span> else<span class="cov8" title="1"> {
                        var exists bool
                        rlpNode, exists = source[nodeHash]
                        if !exists </span><span class="cov8" title="1">{
                                // missing node, proof is not complete
                                return false, false, nil
                        }</span>
                }
                <span class="cov8" title="1">node, err := DecodeFromRlp(rlpNode)
                if err != nil </span><span class="cov8" title="1">{
                        return false, false, err
                }</span>

                <span class="cov8" title="1">var nextHash common.Hash
                switch n := node.(type) </span>{
                case *ExtensionNode:<span class="cov8" title="1">
                        if n.path.IsPrefixOf(path) </span><span class="cov8" title="1">{
                                nextHash = n.nextHash
                                path = path[n.path.Length():]
                                nextEmbedded = n.nextIsEmbedded
                                done = len(path) == 0
                        }</span> else<span class="cov8" title="1"> {
                                done = true
                        }</span>
                case *BranchNode:<span class="cov8" title="1">
                        if len(path) == 0 </span><span class="cov8" title="1">{
                                done = true
                        }</span> else<span class="cov8" title="1"> {
                                nextHash = n.hashes[path[0]]
                                nextEmbedded = n.isEmbedded(byte(path[0]))
                                path = path[1:]
                        }</span>
                case *decodedAccountNode:<span class="cov8" title="1">
                        if n.suffix.IsEqualTo(path) </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                        <span class="cov8" title="1">done = true</span>
                case *ValueNode:<span class="cov8" title="1">
                        keyNibbles := createNibblesFromKeyPrefix(n.key, n.pathLength)
                        if slices.Equal(keyNibbles, path) </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                        <span class="cov8" title="1">done = true</span>
                default:<span class="cov8" title="1">
                        return false, true, nil</span> // EmptyNode -&gt; do not visit, and terminate, proof is complete
                }

                <span class="cov8" title="1">visitor.Visit(nodeHash, rlpNode, node, currentEmbedded)
                nodeHash = nextHash
                currentEmbedded = nextEmbedded</span>
        }

        <span class="cov8" title="1">return found, true, nil</span>
}

// witnessProofVisitor is a visitor that visits witness proof nodes.
// It visits the proof element and provides hash of the element,
// the RLP encoded node and the encoded node itself.
type witnessProofVisitor interface {

        // Visit visits the witness proof node.
        // It provides the hash of the node, the RLP encoded node and the node itself.
        Visit(hash common.Hash, rlpNode rlpEncodedNode, node Node, isEmbedded bool)
}

type proofCollectingVisitor struct {
        visited        proofDb            // all visited nodes
        visitedAccount decodedAccountNode // the last visited account node
        visitedValue   ValueNode          // the last visited value node
}

func (v *proofCollectingVisitor) Visit(hash common.Hash, rlpNode rlpEncodedNode, node Node, isEmbedded bool) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ValueNode:<span class="cov8" title="1">
                v.visitedValue = *n</span>
        case *decodedAccountNode:<span class="cov8" title="1">
                v.visitedAccount = *n</span>
        }

        <span class="cov8" title="1">if !isEmbedded &amp;&amp; v.visited != nil </span><span class="cov8" title="1">{
                v.visited[hash] = rlpNode
        }</span>
        <span class="cov8" title="1">if account, ok := node.(*decodedAccountNode); ok </span><span class="cov8" title="1">{
                v.visitedAccount = *account
        }</span>
}

// createNibblesFromKeyPrefix creates a nibble path from the input key and the number of nibbles.
func createNibblesFromKeyPrefix(key common.Key, nibbles uint8) []Nibble <span class="cov8" title="1">{
        return createNibblesFromCompact(key[:], int(nibbles))
}</span>

// createNibblesFromCompact creates a nibble path from the input compact byte slice.
// The input slice is trimmed of trailing data if the size exceeds the number of requested nibbles.
// If the number of nibbles is odd, the first nibble from the input slice is ignored.
func createNibblesFromCompact(compact []byte, nibbles int) []Nibble <span class="cov8" title="1">{
        odd := nibbles % 2
        res := make([]Nibble, nibbles+odd)
        numBytes := nibbles/2 + odd
        parseNibbles(res, compact[:numBytes])
        if odd == 1 </span><span class="cov8" title="1">{
                res = res[1:]
        }</span>
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: proof.go
//
// Generated by this command:
//
//        mockgen -source proof.go -destination proof_mocks.go -package mpt
//

// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        common "github.com/Fantom-foundation/Carmen/go/common"
        gomock "go.uber.org/mock/gomock"
)

// MockwitnessProofVisitor is a mock of witnessProofVisitor interface.
type MockwitnessProofVisitor struct {
        ctrl     *gomock.Controller
        recorder *MockwitnessProofVisitorMockRecorder
}

// MockwitnessProofVisitorMockRecorder is the mock recorder for MockwitnessProofVisitor.
type MockwitnessProofVisitorMockRecorder struct {
        mock *MockwitnessProofVisitor
}

// NewMockwitnessProofVisitor creates a new mock instance.
func NewMockwitnessProofVisitor(ctrl *gomock.Controller) *MockwitnessProofVisitor <span class="cov0" title="0">{
        mock := &amp;MockwitnessProofVisitor{ctrl: ctrl}
        mock.recorder = &amp;MockwitnessProofVisitorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockwitnessProofVisitor) EXPECT() *MockwitnessProofVisitorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Visit mocks base method.
func (m *MockwitnessProofVisitor) Visit(hash common.Hash, rlpNode rlpEncodedNode, node Node, isEmbedded bool) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "GetAllChildren", hash, rlpNode, node, isEmbedded)
}</span>

// Visit indicates an expected call of Visit.
func (mr *MockwitnessProofVisitorMockRecorder) Visit(hash, rlpNode, node, isEmbedded any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllChildren", reflect.TypeOf((*MockwitnessProofVisitor)(nil).Visit), hash, rlpNode, node, isEmbedded)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

import (
        "bufio"
        "encoding/binary"
        "errors"
        "fmt"
        "hash"
        "io"
        "maps"
        "os"
        "sync"
        "unsafe"

        "github.com/Fantom-foundation/Carmen/go/common/amount"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        "github.com/Fantom-foundation/Carmen/go/state"

        "github.com/Fantom-foundation/Carmen/go/backend"
        "github.com/Fantom-foundation/Carmen/go/common"
        "golang.org/x/crypto/sha3"
)

//go:generate mockgen -source state.go -destination state_mocks.go -package mpt

// Database is a global single access point to Merkle-Patricia-Trie (MPT) data.
// It contains public methods to retrieve information about accounts
// and storage slots, furthermore, it allows for  MPT nodes hashing.
// MPT database maintains a DAG of MPT trees that can be each accessed
// via a single root node.
// The database is an appendable storage, where the current state is modified,
// accessible via the current root node, and eventually sealed and appended
// to the historical database.
// Root nodes allow for traversing the respective MPT tree hierarchy
// to access the history.
// A Freeze method is provided to seal the current MPT so that further updates
// will take place on a new version of the MPT.
// The Current MPT tree may be modified, and the modifications are destructive,
// until the tree is sealed by Freeze.
type Database interface {
        common.FlushAndCloser
        common.MemoryFootprintProvider

        // GetAccountInfo retrieves account information for input root and account address.
        GetAccountInfo(rootRef *NodeReference, addr common.Address) (AccountInfo, bool, error)

        // SetAccountInfo sets the input account into the storage under the input root and the address.
        SetAccountInfo(rootRef *NodeReference, addr common.Address, info AccountInfo) (NodeReference, error)

        // GetValue retrieves storage slot for input root, account address, and storage key.
        GetValue(rootRef *NodeReference, addr common.Address, key common.Key) (common.Value, error)

        // SetValue sets storage slot for input root, account address, and storage key.
        SetValue(rootRef *NodeReference, addr common.Address, key common.Key, value common.Value) (NodeReference, error)

        // ClearStorage removes all storage slots for the input address and the root.
        ClearStorage(rootRef *NodeReference, addr common.Address) (NodeReference, error)

        // HasEmptyStorage returns true if account has empty storage.
        HasEmptyStorage(rootRef *NodeReference, addr common.Address) (bool, error)

        // Freeze seals current trie, preventing further updates to it.
        Freeze(ref *NodeReference) error

        // VisitTrie allows for travertines the whole trie under the input root
        VisitTrie(rootRef *NodeReference, visitor NodeVisitor) error

        // Dump provides a debug print of the whole trie under the input root
        Dump(rootRef *NodeReference)

        // Check verifies internal invariants of the Trie instance. If the trie is
        // self-consistent, nil is returned and the Trie is ready to be accessed. If
        // errors are detected, the Trie is to be considered in an invalid state and
        // the behavior of all other operations is undefined.
        Check(rootRef *NodeReference) error

        // CheckAll verifies internal invariants of a set of Trie instances rooted by
        // the given nodes. It is a generalization of the Check() function.
        CheckAll(rootRefs []*NodeReference) error

        // CheckErrors returns an error that might have been
        // encountered on this forest in the past.
        // If the result is not empty, this
        // Forest is to be considered corrupted and should be discarded.
        CheckErrors() error

        updateHashesFor(ref *NodeReference) (common.Hash, *NodeHashes, error)
        setHashesFor(root *NodeReference, hashes *NodeHashes) error
}

// LiveState represents a single  Merkle-Patricia-Trie (MPT) view to the Database
// as it was accessed for a single root.
// It allows for reading and updating state
// of accounts, storage slots, and codes.
// Access to the data is provided via a set of getters,
// while the update is provides via a single Apply function.
type LiveState interface {
        common.UpdateTarget
        common.MemoryFootprintProvider
        state.LiveDB

        // GetHash provides hash root of this MPT.
        // The hash is recomputed if it is not available.
        GetHash() (hash common.Hash, err error)

        // GetCodeForHash retrieves bytecode stored
        // under the input hash.
        GetCodeForHash(hash common.Hash) []byte

        // GetCodes retrieves all codes and their hashes.
        GetCodes() map[common.Hash][]byte

        // UpdateHashes recomputes hash root of this trie.
        UpdateHashes() (common.Hash, *NodeHashes, error)

        // Root provides root of this trie.
        Root() NodeReference

        closeWithError(externalError error) error
        setHashes(hashes *NodeHashes) error
}

// MptState implementation of a state utilizes an MPT based data structure. While
// functionally equivalent to the Ethereum State MPT, hashes are computed using
// a configurable algorithm.
//
// The main role of the MptState is to provide an adapter between a LiveTrie and
// Carmen's State interface. Also, it retains an index of contract codes.
type MptState struct {
        directory string
        lock      common.LockFile
        trie      *LiveTrie
        code      map[common.Hash][]byte
        codeDirty bool
        codeMutex sync.Mutex
        codefile  string
        hasher    hash.Hash
}

var emptyCodeHash = common.GetHash(sha3.NewLegacyKeccak256(), []byte{})

func newMptState(directory string, lock common.LockFile, trie *LiveTrie) (*MptState, error) <span class="cov8" title="1">{
        codefile := directory + "/codes.dat"
        codes, err := readCodes(codefile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;MptState{
                directory: directory,
                lock:      lock,
                trie:      trie,
                code:      codes,
                codefile:  codefile,
        }, nil</span>
}

func openStateDirectory(directory string) (common.LockFile, error) <span class="cov8" title="1">{
        lock, err := LockDirectory(directory)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := tryMarkDirty(directory); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Join(err, lock.Release())
        }</span>

        <span class="cov8" title="1">return lock, nil</span>
}

func tryMarkDirty(directory string) error <span class="cov8" title="1">{
        dirty, err := isDirty(directory)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if dirty </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to open %s, content is dirty, likely corrupted", directory)
        }</span>
        <span class="cov8" title="1">return markDirty(directory)</span>
}

// OpenGoMemoryState loads state information from the given directory and
// creates a Trie entirely retained in memory.
func OpenGoMemoryState(directory string, config MptConfig, cacheConfig NodeCacheConfig) (*MptState, error) <span class="cov8" title="1">{
        lock, err := openStateDirectory(directory)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">trie, err := OpenInMemoryLiveTrie(directory, config, cacheConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return newMptState(directory, lock, trie)</span>
}

func OpenGoFileState(directory string, config MptConfig, cacheConfig NodeCacheConfig) (*MptState, error) <span class="cov8" title="1">{
        lock, err := openStateDirectory(directory)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">trie, err := OpenFileLiveTrie(directory, config, cacheConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return newMptState(directory, lock, trie)</span>
}

func (s *MptState) CreateAccount(address common.Address) (err error) <span class="cov8" title="1">{
        _, exists, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                // For existing accounts, only clear the storage, preserve the rest.
                return s.trie.ClearStorage(address)
        }</span>
        // Create account with hash of empty code.
        <span class="cov8" title="1">return s.trie.SetAccountInfo(address, AccountInfo{
                CodeHash: emptyCodeHash,
        })</span>
}

func (s *MptState) Exists(address common.Address) (bool, error) <span class="cov8" title="1">{
        _, exists, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return exists, nil</span>
}

func (s *MptState) DeleteAccount(address common.Address) error <span class="cov8" title="1">{
        return s.trie.SetAccountInfo(address, AccountInfo{})
}</span>

func (s *MptState) GetBalance(address common.Address) (balance amount.Amount, err error) <span class="cov8" title="1">{
        info, exists, err := s.trie.GetAccountInfo(address)
        if !exists || err != nil </span><span class="cov8" title="1">{
                return amount.New(), err
        }</span>
        <span class="cov8" title="1">return info.Balance, nil</span>
}

func (s *MptState) SetBalance(address common.Address, balance amount.Amount) (err error) <span class="cov8" title="1">{
        info, exists, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if info.Balance == balance </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">info.Balance = balance
        if !exists </span><span class="cov8" title="1">{
                info.CodeHash = emptyCodeHash
        }</span>
        <span class="cov8" title="1">return s.trie.SetAccountInfo(address, info)</span>
}

func (s *MptState) GetNonce(address common.Address) (nonce common.Nonce, err error) <span class="cov8" title="1">{
        info, _, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return common.Nonce{}, err
        }</span>
        <span class="cov8" title="1">return info.Nonce, nil</span>
}

func (s *MptState) SetNonce(address common.Address, nonce common.Nonce) (err error) <span class="cov8" title="1">{
        info, exists, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if info.Nonce == nonce </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">info.Nonce = nonce
        if !exists </span><span class="cov8" title="1">{
                info.CodeHash = emptyCodeHash
        }</span>
        <span class="cov8" title="1">return s.trie.SetAccountInfo(address, info)</span>
}

func (s *MptState) GetStorage(address common.Address, key common.Key) (value common.Value, err error) <span class="cov8" title="1">{
        return s.trie.GetValue(address, key)
}</span>

func (s *MptState) SetStorage(address common.Address, key common.Key, value common.Value) error <span class="cov8" title="1">{
        return s.trie.SetValue(address, key, value)
}</span>

func (s *MptState) HasEmptyStorage(address common.Address) (bool, error) <span class="cov8" title="1">{
        return s.trie.HasEmptyStorage(address)
}</span>
func (s *MptState) GetCode(address common.Address) (value []byte, err error) <span class="cov8" title="1">{
        info, exists, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">s.codeMutex.Lock()
        res := s.code[info.CodeHash]
        s.codeMutex.Unlock()
        return res, nil</span>
}

func (s *MptState) GetCodeForHash(hash common.Hash) []byte <span class="cov8" title="1">{
        s.codeMutex.Lock()
        res := s.code[hash]
        s.codeMutex.Unlock()
        return res
}</span>

func (s *MptState) GetCodeSize(address common.Address) (size int, err error) <span class="cov8" title="1">{
        code, err := s.GetCode(address)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return len(code), err</span>
}

func (s *MptState) SetCode(address common.Address, code []byte) (err error) <span class="cov8" title="1">{
        var codeHash common.Hash
        if s.hasher == nil </span><span class="cov8" title="1">{
                s.hasher = sha3.NewLegacyKeccak256()
        }</span>
        <span class="cov8" title="1">codeHash = common.GetHash(s.hasher, code)

        info, exists, err := s.trie.GetAccountInfo(address)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if !exists &amp;&amp; len(code) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if info.CodeHash == codeHash </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">info.CodeHash = codeHash
        s.codeMutex.Lock()
        s.code[codeHash] = code
        s.codeDirty = true
        s.codeMutex.Unlock()
        return s.trie.SetAccountInfo(address, info)</span>
}

func (s *MptState) GetCodeHash(address common.Address) (hash common.Hash, err error) <span class="cov8" title="1">{
        info, exists, err := s.trie.GetAccountInfo(address)
        if !exists || err != nil </span><span class="cov8" title="1">{
                return emptyCodeHash, err
        }</span>
        <span class="cov8" title="1">return info.CodeHash, nil</span>
}

func (s *MptState) GetRootId() NodeId <span class="cov8" title="1">{
        return s.trie.root.Id()
}</span>

func (s *MptState) GetHash() (hash common.Hash, err error) <span class="cov8" title="1">{
        hash, hints, err := s.trie.UpdateHashes()
        if hints != nil </span><span class="cov8" title="1">{
                hints.Release()
        }</span>
        <span class="cov8" title="1">return hash, err</span>
}

func (s *MptState) Apply(block uint64, update common.Update) (archiveUpdateHints common.Releaser, err error) <span class="cov8" title="1">{
        if err := update.ApplyTo(s); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, hints, err := s.trie.UpdateHashes()
        return hints, err</span>
}

func (s *MptState) Visit(visitor NodeVisitor) error <span class="cov8" title="1">{
        return s.trie.VisitTrie(visitor)
}</span>

func (s *MptState) GetCodes() map[common.Hash][]byte <span class="cov8" title="1">{
        s.codeMutex.Lock()
        res := maps.Clone(s.code)
        s.codeMutex.Unlock()
        return res
}</span>

// Flush codes and state trie
func (s *MptState) Flush() error <span class="cov8" title="1">{
        // flush codes
        var err error
        s.codeMutex.Lock()
        if s.codeDirty </span><span class="cov8" title="1">{
                err = writeCodes(s.code, s.codefile)
                if err == nil </span><span class="cov8" title="1">{
                        s.codeDirty = false
                }</span>
        }
        <span class="cov8" title="1">s.codeMutex.Unlock()
        return errors.Join(
                s.trie.forest.CheckErrors(),
                err,
                s.trie.Flush(),
        )</span>
}

func (s *MptState) Close() error <span class="cov8" title="1">{
        return s.closeWithError(nil)
}</span>

func (s *MptState) closeWithError(externalError error) error <span class="cov8" title="1">{
        // Only if the state can be successfully closed, the directory is to
        // be marked as clean. Otherwise, the dirty flag needs to be retained.
        err := errors.Join(
                externalError,
                s.Flush(),
                s.trie.Close(),
        )
        if err == nil </span><span class="cov8" title="1">{
                err = markClean(s.directory)
        }</span>
        <span class="cov8" title="1">return errors.Join(
                err,
                s.lock.Release(),
        )</span>
}

func (s *MptState) GetSnapshotableComponents() []backend.Snapshotable <span class="cov8" title="1">{
        //panic("not implemented")
        return nil
}</span>

func (s *MptState) RunPostRestoreTasks() error <span class="cov8" title="1">{
        //panic("not implemented")
        return nil
}</span>

// GetMemoryFootprint provides sizes of individual components of the state in the memory
func (s *MptState) GetMemoryFootprint() *common.MemoryFootprint <span class="cov8" title="1">{
        mf := common.NewMemoryFootprint(unsafe.Sizeof(*s))
        mf.AddChild("trie", s.trie.GetMemoryFootprint())
        var sizeCodes uint
        s.codeMutex.Lock()
        for k, v := range s.code </span><span class="cov0" title="0">{
                sizeCodes += uint(len(k) + len(v))
        }</span>
        <span class="cov8" title="1">s.codeMutex.Unlock()
        mf.AddChild("codes", common.NewMemoryFootprint(uintptr(sizeCodes)))
        return mf</span>
}

func (s *MptState) UpdateHashes() (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        return s.trie.UpdateHashes()
}</span>

func (s *MptState) Root() NodeReference <span class="cov8" title="1">{
        return s.trie.root
}</span>

func (s *MptState) setHashes(hashes *NodeHashes) error <span class="cov8" title="1">{
        return s.trie.setHashes(hashes)
}</span>

// readCodes parses the content of the given file if it exists or returns
// a an empty code collection if there is no such file.
func readCodes(filename string) (map[common.Hash][]byte, error) <span class="cov8" title="1">{
        // If there is no file, initialize and return an empty code collection.
        if _, err := os.Stat(filename); err != nil </span><span class="cov8" title="1">{
                return map[common.Hash][]byte{}, nil
        }</span>

        <span class="cov8" title="1">file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        reader := bufio.NewReader(file)
        return parseCodes(reader)</span>
}

func parseCodes(reader io.Reader) (map[common.Hash][]byte, error) <span class="cov8" title="1">{
        // If the file exists, parse it and return its content.
        res := map[common.Hash][]byte{}
        // The format is simple: [&lt;key&gt;, &lt;length&gt;, &lt;code&gt;]*
        var hash common.Hash
        var length [4]byte
        for </span><span class="cov8" title="1">{
                if _, err := io.ReadFull(reader, hash[:]); err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                return res, nil
                        }</span>
                        <span class="cov8" title="1">return nil, err</span>
                }
                <span class="cov8" title="1">if _, err := io.ReadFull(reader, length[:]); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">size := binary.BigEndian.Uint32(length[:])
                code := make([]byte, size)
                if _, err := io.ReadFull(reader, code[:]); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">res[hash] = code</span>
        }
}

// writeCodes write the given map of codes to the given file.
func writeCodes(codes map[common.Hash][]byte, filename string) (err error) <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">writer := bufio.NewWriter(file)
        return errors.Join(
                writeCodesTo(codes, writer),
                writer.Flush(),
                file.Close())</span>
}

func writeCodesTo(codes map[common.Hash][]byte, writer io.Writer) (err error) <span class="cov8" title="1">{
        // The format is simple: [&lt;key&gt;, &lt;length&gt;, &lt;code&gt;]*
        for key, code := range codes </span><span class="cov8" title="1">{
                if _, err := writer.Write(key[:]); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">var length [4]byte
                binary.BigEndian.PutUint32(length[:], uint32(len(code)))
                if _, err := writer.Write(length[:]); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := writer.Write(code); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// EstimatePerNodeMemoryUsage returns an estimated upper bound for the
// amount of memory used per MPT node. This values is provided to facilitate
// a conversion between memory limits expressed in bytes and MPT cache
// sizes defined by the number of stored nodes.
func EstimatePerNodeMemoryUsage() int <span class="cov8" title="1">{

        // The largest node is the BranchNode with ~944 bytes, which is
        // likely allocated into 1 KB memory slots. Thus, a memory usage
        // of 1 KB is used for the notes
        maxNodeSize := 1 &lt;&lt; 10

        // Additionally, every node in the node cache needs a owner slot
        // and a NodeID/ownerPosition entry pair in the index of the cache.
        nodeCacheSlotSize := unsafe.Sizeof(nodeOwner{}) +
                unsafe.Sizeof(NodeId(0)) +
                unsafe.Sizeof(ownerPosition(0)) +
                unsafe.Sizeof(shared.Shared[Node]{})

        return maxNodeSize + int(nodeCacheSlotSize)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: state.go
//
// Generated by this command:
//
//        mockgen -source state.go -destination state_mocks.go -package mpt
//

// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        backend "github.com/Fantom-foundation/Carmen/go/backend"
        common "github.com/Fantom-foundation/Carmen/go/common"
        amount "github.com/Fantom-foundation/Carmen/go/common/amount"
        gomock "go.uber.org/mock/gomock"
)

// MockDatabase is a mock of Database interface.
type MockDatabase struct {
        ctrl     *gomock.Controller
        recorder *MockDatabaseMockRecorder
}

// MockDatabaseMockRecorder is the mock recorder for MockDatabase.
type MockDatabaseMockRecorder struct {
        mock *MockDatabase
}

// NewMockDatabase creates a new mock instance.
func NewMockDatabase(ctrl *gomock.Controller) *MockDatabase <span class="cov8" title="1">{
        mock := &amp;MockDatabase{ctrl: ctrl}
        mock.recorder = &amp;MockDatabaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDatabase) EXPECT() *MockDatabaseMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Check mocks base method.
func (m *MockDatabase) Check(rootRef *NodeReference) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Check", rootRef)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Check indicates an expected call of Check.
func (mr *MockDatabaseMockRecorder) Check(rootRef any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockDatabase)(nil).Check), rootRef)
}</span>

// CheckAll mocks base method.
func (m *MockDatabase) CheckAll(rootRefs []*NodeReference) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckAll", rootRefs)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CheckAll indicates an expected call of CheckAll.
func (mr *MockDatabaseMockRecorder) CheckAll(rootRefs any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAll", reflect.TypeOf((*MockDatabase)(nil).CheckAll), rootRefs)
}</span>

// CheckErrors mocks base method.
func (m *MockDatabase) CheckErrors() error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckErrors")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CheckErrors indicates an expected call of CheckErrors.
func (mr *MockDatabaseMockRecorder) CheckErrors() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckErrors", reflect.TypeOf((*MockDatabase)(nil).CheckErrors))
}</span>

// ClearStorage mocks base method.
func (m *MockDatabase) ClearStorage(rootRef *NodeReference, addr common.Address) (NodeReference, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ClearStorage", rootRef, addr)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ClearStorage indicates an expected call of ClearStorage.
func (mr *MockDatabaseMockRecorder) ClearStorage(rootRef, addr any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearStorage", reflect.TypeOf((*MockDatabase)(nil).ClearStorage), rootRef, addr)
}</span>

// Close mocks base method.
func (m *MockDatabase) Close() error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockDatabaseMockRecorder) Close() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockDatabase)(nil).Close))
}</span>

// Dump mocks base method.
func (m *MockDatabase) Dump(rootRef *NodeReference) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Dump", rootRef)
}</span>

// Dump indicates an expected call of Dump.
func (mr *MockDatabaseMockRecorder) Dump(rootRef any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockDatabase)(nil).Dump), rootRef)
}</span>

// Flush mocks base method.
func (m *MockDatabase) Flush() error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Flush")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Flush indicates an expected call of Flush.
func (mr *MockDatabaseMockRecorder) Flush() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockDatabase)(nil).Flush))
}</span>

// Freeze mocks base method.
func (m *MockDatabase) Freeze(ref *NodeReference) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Freeze", ref)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Freeze indicates an expected call of Freeze.
func (mr *MockDatabaseMockRecorder) Freeze(ref any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Freeze", reflect.TypeOf((*MockDatabase)(nil).Freeze), ref)
}</span>

// GetAccountInfo mocks base method.
func (m *MockDatabase) GetAccountInfo(rootRef *NodeReference, addr common.Address) (AccountInfo, bool, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAccountInfo", rootRef, addr)
        ret0, _ := ret[0].(AccountInfo)
        ret1, _ := ret[1].(bool)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetAccountInfo indicates an expected call of GetAccountInfo.
func (mr *MockDatabaseMockRecorder) GetAccountInfo(rootRef, addr any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountInfo", reflect.TypeOf((*MockDatabase)(nil).GetAccountInfo), rootRef, addr)
}</span>

// GetMemoryFootprint mocks base method.
func (m *MockDatabase) GetMemoryFootprint() *common.MemoryFootprint <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMemoryFootprint")
        ret0, _ := ret[0].(*common.MemoryFootprint)
        return ret0
}</span>

// GetMemoryFootprint indicates an expected call of GetMemoryFootprint.
func (mr *MockDatabaseMockRecorder) GetMemoryFootprint() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMemoryFootprint", reflect.TypeOf((*MockDatabase)(nil).GetMemoryFootprint))
}</span>

// GetValue mocks base method.
func (m *MockDatabase) GetValue(rootRef *NodeReference, addr common.Address, key common.Key) (common.Value, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetValue", rootRef, addr, key)
        ret0, _ := ret[0].(common.Value)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetValue indicates an expected call of GetValue.
func (mr *MockDatabaseMockRecorder) GetValue(rootRef, addr, key any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValue", reflect.TypeOf((*MockDatabase)(nil).GetValue), rootRef, addr, key)
}</span>

// HasEmptyStorage mocks base method.
func (m *MockDatabase) HasEmptyStorage(rootRef *NodeReference, addr common.Address) (bool, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HasEmptyStorage", rootRef, addr)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// HasEmptyStorage indicates an expected call of HasEmptyStorage.
func (mr *MockDatabaseMockRecorder) HasEmptyStorage(rootRef, addr any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasEmptyStorage", reflect.TypeOf((*MockDatabase)(nil).HasEmptyStorage), rootRef, addr)
}</span>

// SetAccountInfo mocks base method.
func (m *MockDatabase) SetAccountInfo(rootRef *NodeReference, addr common.Address, info AccountInfo) (NodeReference, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetAccountInfo", rootRef, addr, info)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SetAccountInfo indicates an expected call of SetAccountInfo.
func (mr *MockDatabaseMockRecorder) SetAccountInfo(rootRef, addr, info any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAccountInfo", reflect.TypeOf((*MockDatabase)(nil).SetAccountInfo), rootRef, addr, info)
}</span>

// SetValue mocks base method.
func (m *MockDatabase) SetValue(rootRef *NodeReference, addr common.Address, key common.Key, value common.Value) (NodeReference, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetValue", rootRef, addr, key, value)
        ret0, _ := ret[0].(NodeReference)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SetValue indicates an expected call of SetValue.
func (mr *MockDatabaseMockRecorder) SetValue(rootRef, addr, key, value any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetValue", reflect.TypeOf((*MockDatabase)(nil).SetValue), rootRef, addr, key, value)
}</span>

// VisitTrie mocks base method.
func (m *MockDatabase) VisitTrie(rootRef *NodeReference, visitor NodeVisitor) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VisitTrie", rootRef, visitor)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// VisitTrie indicates an expected call of VisitTrie.
func (mr *MockDatabaseMockRecorder) VisitTrie(rootRef, visitor any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VisitTrie", reflect.TypeOf((*MockDatabase)(nil).VisitTrie), rootRef, visitor)
}</span>

// setHashesFor mocks base method.
func (m *MockDatabase) setHashesFor(root *NodeReference, hashes *NodeHashes) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "setHashesFor", root, hashes)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// setHashesFor indicates an expected call of setHashesFor.
func (mr *MockDatabaseMockRecorder) setHashesFor(root, hashes any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "setHashesFor", reflect.TypeOf((*MockDatabase)(nil).setHashesFor), root, hashes)
}</span>

// updateHashesFor mocks base method.
func (m *MockDatabase) updateHashesFor(ref *NodeReference) (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "updateHashesFor", ref)
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(*NodeHashes)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// updateHashesFor indicates an expected call of updateHashesFor.
func (mr *MockDatabaseMockRecorder) updateHashesFor(ref any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "updateHashesFor", reflect.TypeOf((*MockDatabase)(nil).updateHashesFor), ref)
}</span>

// MockLiveState is a mock of LiveState interface.
type MockLiveState struct {
        ctrl     *gomock.Controller
        recorder *MockLiveStateMockRecorder
}

// MockLiveStateMockRecorder is the mock recorder for MockLiveState.
type MockLiveStateMockRecorder struct {
        mock *MockLiveState
}

// NewMockLiveState creates a new mock instance.
func NewMockLiveState(ctrl *gomock.Controller) *MockLiveState <span class="cov8" title="1">{
        mock := &amp;MockLiveState{ctrl: ctrl}
        mock.recorder = &amp;MockLiveStateMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLiveState) EXPECT() *MockLiveStateMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Apply mocks base method.
func (m *MockLiveState) Apply(block uint64, update common.Update) (common.Releaser, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Apply", block, update)
        ret0, _ := ret[0].(common.Releaser)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Apply indicates an expected call of Apply.
func (mr *MockLiveStateMockRecorder) Apply(block, update any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockLiveState)(nil).Apply), block, update)
}</span>

// Close mocks base method.
func (m *MockLiveState) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockLiveStateMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLiveState)(nil).Close))
}</span>

// CreateAccount mocks base method.
func (m *MockLiveState) CreateAccount(address common.Address) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateAccount", address)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateAccount indicates an expected call of CreateAccount.
func (mr *MockLiveStateMockRecorder) CreateAccount(address any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccount", reflect.TypeOf((*MockLiveState)(nil).CreateAccount), address)
}</span>

// DeleteAccount mocks base method.
func (m *MockLiveState) DeleteAccount(address common.Address) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteAccount", address)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteAccount indicates an expected call of DeleteAccount.
func (mr *MockLiveStateMockRecorder) DeleteAccount(address any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccount", reflect.TypeOf((*MockLiveState)(nil).DeleteAccount), address)
}</span>

// Exists mocks base method.
func (m *MockLiveState) Exists(address common.Address) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Exists", address)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Exists indicates an expected call of Exists.
func (mr *MockLiveStateMockRecorder) Exists(address any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockLiveState)(nil).Exists), address)
}</span>

// Flush mocks base method.
func (m *MockLiveState) Flush() error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Flush")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Flush indicates an expected call of Flush.
func (mr *MockLiveStateMockRecorder) Flush() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockLiveState)(nil).Flush))
}</span>

// GetBalance mocks base method.
func (m *MockLiveState) GetBalance(address common.Address) (amount.Amount, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBalance", address)
        ret0, _ := ret[0].(amount.Amount)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBalance indicates an expected call of GetBalance.
func (mr *MockLiveStateMockRecorder) GetBalance(address any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockLiveState)(nil).GetBalance), address)
}</span>

// GetCode mocks base method.
func (m *MockLiveState) GetCode(address common.Address) ([]byte, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCode", address)
        ret0, _ := ret[0].([]byte)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCode indicates an expected call of GetCode.
func (mr *MockLiveStateMockRecorder) GetCode(address any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockLiveState)(nil).GetCode), address)
}</span>

// GetCodeForHash mocks base method.
func (m *MockLiveState) GetCodeForHash(hash common.Hash) []byte <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCodeForHash", hash)
        ret0, _ := ret[0].([]byte)
        return ret0
}</span>

// GetCodeForHash indicates an expected call of GetCodeForHash.
func (mr *MockLiveStateMockRecorder) GetCodeForHash(hash any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeForHash", reflect.TypeOf((*MockLiveState)(nil).GetCodeForHash), hash)
}</span>

// GetCodeHash mocks base method.
func (m *MockLiveState) GetCodeHash(address common.Address) (common.Hash, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCodeHash", address)
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCodeHash indicates an expected call of GetCodeHash.
func (mr *MockLiveStateMockRecorder) GetCodeHash(address any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeHash", reflect.TypeOf((*MockLiveState)(nil).GetCodeHash), address)
}</span>

// GetCodeSize mocks base method.
func (m *MockLiveState) GetCodeSize(address common.Address) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCodeSize", address)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCodeSize indicates an expected call of GetCodeSize.
func (mr *MockLiveStateMockRecorder) GetCodeSize(address any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeSize", reflect.TypeOf((*MockLiveState)(nil).GetCodeSize), address)
}</span>

// GetCodes mocks base method.
func (m *MockLiveState) GetCodes() map[common.Hash][]byte <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCodes")
        ret0, _ := ret[0].(map[common.Hash][]byte)
        return ret0
}</span>

// GetCodes indicates an expected call of GetCodes.
func (mr *MockLiveStateMockRecorder) GetCodes() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodes", reflect.TypeOf((*MockLiveState)(nil).GetCodes))
}</span>

// GetHash mocks base method.
func (m *MockLiveState) GetHash() (common.Hash, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetHash")
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetHash indicates an expected call of GetHash.
func (mr *MockLiveStateMockRecorder) GetHash() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHash", reflect.TypeOf((*MockLiveState)(nil).GetHash))
}</span>

// GetMemoryFootprint mocks base method.
func (m *MockLiveState) GetMemoryFootprint() *common.MemoryFootprint <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMemoryFootprint")
        ret0, _ := ret[0].(*common.MemoryFootprint)
        return ret0
}</span>

// GetMemoryFootprint indicates an expected call of GetMemoryFootprint.
func (mr *MockLiveStateMockRecorder) GetMemoryFootprint() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMemoryFootprint", reflect.TypeOf((*MockLiveState)(nil).GetMemoryFootprint))
}</span>

// GetNonce mocks base method.
func (m *MockLiveState) GetNonce(address common.Address) (common.Nonce, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNonce", address)
        ret0, _ := ret[0].(common.Nonce)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetNonce indicates an expected call of GetNonce.
func (mr *MockLiveStateMockRecorder) GetNonce(address any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockLiveState)(nil).GetNonce), address)
}</span>

// GetSnapshotableComponents mocks base method.
func (m *MockLiveState) GetSnapshotableComponents() []backend.Snapshotable <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSnapshotableComponents")
        ret0, _ := ret[0].([]backend.Snapshotable)
        return ret0
}</span>

// GetSnapshotableComponents indicates an expected call of GetSnapshotableComponents.
func (mr *MockLiveStateMockRecorder) GetSnapshotableComponents() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSnapshotableComponents", reflect.TypeOf((*MockLiveState)(nil).GetSnapshotableComponents))
}</span>

// GetStorage mocks base method.
func (m *MockLiveState) GetStorage(address common.Address, key common.Key) (common.Value, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetStorage", address, key)
        ret0, _ := ret[0].(common.Value)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetStorage indicates an expected call of GetStorage.
func (mr *MockLiveStateMockRecorder) GetStorage(address, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorage", reflect.TypeOf((*MockLiveState)(nil).GetStorage), address, key)
}</span>

// Root mocks base method.
func (m *MockLiveState) Root() NodeReference <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Root")
        ret0, _ := ret[0].(NodeReference)
        return ret0
}</span>

// Root indicates an expected call of Root.
func (mr *MockLiveStateMockRecorder) Root() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Root", reflect.TypeOf((*MockLiveState)(nil).Root))
}</span>

// RunPostRestoreTasks mocks base method.
func (m *MockLiveState) RunPostRestoreTasks() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RunPostRestoreTasks")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RunPostRestoreTasks indicates an expected call of RunPostRestoreTasks.
func (mr *MockLiveStateMockRecorder) RunPostRestoreTasks() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunPostRestoreTasks", reflect.TypeOf((*MockLiveState)(nil).RunPostRestoreTasks))
}</span>

// SetBalance mocks base method.
func (m *MockLiveState) SetBalance(address common.Address, balance amount.Amount) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetBalance", address, balance)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetBalance indicates an expected call of SetBalance.
func (mr *MockLiveStateMockRecorder) SetBalance(address, balance any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockLiveState)(nil).SetBalance), address, balance)
}</span>

// SetCode mocks base method.
func (m *MockLiveState) SetCode(address common.Address, code []byte) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetCode", address, code)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetCode indicates an expected call of SetCode.
func (mr *MockLiveStateMockRecorder) SetCode(address, code any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockLiveState)(nil).SetCode), address, code)
}</span>

// SetNonce mocks base method.
func (m *MockLiveState) SetNonce(address common.Address, nonce common.Nonce) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetNonce", address, nonce)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetNonce indicates an expected call of SetNonce.
func (mr *MockLiveStateMockRecorder) SetNonce(address, nonce any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockLiveState)(nil).SetNonce), address, nonce)
}</span>

// SetStorage mocks base method.
func (m *MockLiveState) SetStorage(address common.Address, key common.Key, value common.Value) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetStorage", address, key, value)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetStorage indicates an expected call of SetStorage.
func (mr *MockLiveStateMockRecorder) SetStorage(address, key, value any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStorage", reflect.TypeOf((*MockLiveState)(nil).SetStorage), address, key, value)
}</span>

// UpdateHashes mocks base method.
func (m *MockLiveState) UpdateHashes() (common.Hash, *NodeHashes, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateHashes")
        ret0, _ := ret[0].(common.Hash)
        ret1, _ := ret[1].(*NodeHashes)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// UpdateHashes indicates an expected call of UpdateHashes.
func (mr *MockLiveStateMockRecorder) UpdateHashes() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateHashes", reflect.TypeOf((*MockLiveState)(nil).UpdateHashes))
}</span>

// closeWithError mocks base method.
func (m *MockLiveState) closeWithError(externalError error) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "closeWithError", externalError)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// closeWithError indicates an expected call of closeWithError.
func (mr *MockLiveStateMockRecorder) closeWithError(externalError any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "closeWithError", reflect.TypeOf((*MockLiveState)(nil).closeWithError), externalError)
}</span>

// setHashes mocks base method.
func (m *MockLiveState) setHashes(hashes *NodeHashes) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "setHashes", hashes)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// setHashes indicates an expected call of setHashes.
func (mr *MockLiveStateMockRecorder) setHashes(hashes any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "setHashes", reflect.TypeOf((*MockLiveState)(nil).setHashes), hashes)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

//go:generate mockgen -source verification.go -destination verification_mocks.go -package mpt

import (
        "errors"
        "fmt"
        "path/filepath"
        "sort"

        "github.com/Fantom-foundation/Carmen/go/backend/stock"
        "github.com/Fantom-foundation/Carmen/go/backend/stock/file"
        "github.com/Fantom-foundation/Carmen/go/common"
        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        "github.com/pbnjay/memory"
)

// VerificationObserver is a listener interface for tracking the progress of the verification
// of a forest. It can, for instance, be implemented by a user interface to keep the user updated
// on current activities.
type VerificationObserver interface {
        StartVerification()
        Progress(msg string)
        EndVerification(res error)
}

// NilVerificationObserver is a trivial implementation of the observer interface above which
// ignores all reported events.
type NilVerificationObserver struct{}

func (NilVerificationObserver) StartVerification()        {<span class="cov8" title="1">}</span>
func (NilVerificationObserver) Progress(msg string)       {<span class="cov8" title="1">}</span>
func (NilVerificationObserver) EndVerification(res error) {<span class="cov8" title="1">}</span>

// VerifyMptState runs validation checks on the forest and code hashes
// stored in the given directory.
// Forest checks:
//   - all required files are present and can be read
//   - all referenced nodes are present
//   - all hashes are consistent
//
// Code Hashes checks:
//  1. Fatal checks
//     - all CodeHashes of accounts are present in the code file
//     - all byte-codes within the code file matches their hashed representation in accounts
//  2. Non-fatal checks
//     - there are no extra Code Hashes not referenced by any account
func VerifyMptState(directory string, config MptConfig, roots []Root, observer VerificationObserver) (res error) <span class="cov8" title="1">{
        if observer == nil </span><span class="cov8" title="1">{
                observer = NilVerificationObserver{}
        }</span>

        <span class="cov8" title="1">observer.StartVerification()
        defer func() </span><span class="cov8" title="1">{
                observer.EndVerification(res)
        }</span>()

        // Open stock data structures for content verification.
        <span class="cov8" title="1">observer.Progress("Obtaining read access to files ...")
        source, err := openVerificationNodeSource(directory, config)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer source.Close()

        err = verifyContractCodes(directory, source, observer)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = verifyForest(directory, config, roots, source, observer)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// verifyFileForest runs list of validation checks on the forest stored in the given
// directory. These checks include:
//   - all required files are present and can be read
//   - all referenced nodes are present
//   - all hashes are consistent
func verifyFileForest(directory string, config MptConfig, roots []Root, observer VerificationObserver) (res error) <span class="cov8" title="1">{
        if observer == nil </span><span class="cov8" title="1">{
                observer = NilVerificationObserver{}
        }</span>

        <span class="cov8" title="1">observer.StartVerification()
        defer func() </span><span class="cov8" title="1">{
                observer.EndVerification(res)
        }</span>()

        // Open stock data structures for content verification.
        <span class="cov8" title="1">observer.Progress("Obtaining read access to files ...")
        source, err := openVerificationNodeSource(directory, config)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer source.Close()
        return verifyForest(directory, config, roots, source, observer)</span>
}

func verifyForest(directory string, config MptConfig, roots []Root, source *verificationNodeSource, observer VerificationObserver) (res error) <span class="cov8" title="1">{
        // ------------------------- Meta-Data Checks -----------------------------

        observer.Progress(fmt.Sprintf("Checking forest stored in %s ...", directory))

        // Verify stock data structures.
        observer.Progress("Checking meta-data ...")
        accountEncoder, branchEncoder, extensionEncoder, valueEncoder := getEncoder(config)
        if err := file.VerifyStock[uint64](directory+"/accounts", accountEncoder); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := file.VerifyStock[uint64](directory+"/branches", branchEncoder); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := file.VerifyStock[uint64](directory+"/extensions", extensionEncoder); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := file.VerifyStock[uint64](directory+"/values", valueEncoder); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // ----------------- First Pass: check Node References --------------------

        // Check that all IDs used to reference other nodes are valid.
        <span class="cov8" title="1">observer.Progress("Checking node references ...")
        checkId := func(ref NodeReference) error </span><span class="cov8" title="1">{
                if source.isValid(ref.Id()) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("contains invalid reference to node %v", ref.Id())</span>
        }

        // Check that roots are valid.
        <span class="cov8" title="1">errs := []error{}
        for _, root := range roots </span><span class="cov8" title="1">{
                if err := checkId(root.NodeRef); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return errors.Join(errs...)
        }</span>

        <span class="cov8" title="1">err := source.forAllInnerNodes(func(node Node) error </span><span class="cov8" title="1">{
                switch n := node.(type) </span>{
                case *AccountNode:<span class="cov8" title="1">
                        return checkId(n.storage)</span>
                case *ExtensionNode:<span class="cov8" title="1">
                        return checkId(n.next)</span>
                case *BranchNode:<span class="cov8" title="1">
                        errs := []error{}
                        for i := 0; i &lt; len(n.children); i++ </span><span class="cov8" title="1">{
                                if err := checkId(n.children[i]); err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        }
                        <span class="cov8" title="1">return errors.Join(errs...)</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // -------------------- Further Passes: node hashes -----------------------

        <span class="cov8" title="1">hasher := config.Hashing.createHasher()
        hash := func(node Node) (common.Hash, error) </span><span class="cov8" title="1">{
                overrideId := ValueId((^uint64(0)) &gt;&gt; 2)
                if _, ok := node.(EmptyNode); ok </span><span class="cov8" title="1">{
                        overrideId = EmptyId()
                }</span>
                <span class="cov8" title="1">source.setNodeOverride(overrideId, node)
                defer source.clearOverride()
                ref := NewNodeReference(overrideId)
                return hasher.getHash(&amp;ref, source)</span>
        }
        <span class="cov8" title="1">emptyNodeHash, err := hash(EmptyNode{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash empty node: %v", err)
        }</span>

        // Check roots for Archive node
        <span class="cov8" title="1">if source.getConfig().HashStorageLocation == HashStoredWithNode </span><span class="cov8" title="1">{
                // Check hashes of roots.
                observer.Progress(fmt.Sprintf("Checking %d root hashes ...", len(roots)))
                refIds := newNodeIds(uint64(len(roots)))
                for _, root := range roots </span><span class="cov8" title="1">{
                        refIds.Put(root.NodeRef.id)
                }</span>
                <span class="cov8" title="1">isEmbedded := func(node Node) (bool, error) </span><span class="cov8" title="1">{ return false, nil }</span> // root node cannot be embedded
                <span class="cov8" title="1">hashes, _, err := loadNodeHashes(refIds, source, isEmbedded, emptyNodeHash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, root := range roots </span><span class="cov8" title="1">{
                        want := hashes[root.NodeRef.Id()]
                        got := root.Hash
                        if want != got </span><span class="cov8" title="1">{
                                return fmt.Errorf("inconsistent hash for root node %v, want %v, got %v", root.NodeRef.Id(), want, got)
                        }</span>
                }
        }

        <span class="cov8" title="1">err = verifyHashes(
                "account", source, source.accounts, source.accountIds, emptyNodeHash, roots, observer,
                func(node *AccountNode) (common.Hash, error) </span><span class="cov8" title="1">{ return hash(node) }</span>,
                func(node *AccountNode) (common.Hash, bool) <span class="cov8" title="1">{ return node.GetHash() }</span>,
                func(node Node) (bool, error) <span class="cov8" title="1">{ return hasher.isEmbedded(node, source) }</span>,
                func(id NodeId) bool <span class="cov8" title="1">{ return id.IsAccount() }</span>,
                func(node *AccountNode, hashes map[NodeId]common.Hash, embedded map[NodeId]bool) <span class="cov8" title="1">{
                        node.storageHash = hashes[node.storage.Id()]
                        node.storageHashDirty = false
                }</span>,
                func(node *AccountNode, ids *nodeIdCollection) <span class="cov8" title="1">{
                        ids.Put(node.storage.Id())
                }</span>,
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = verifyHashes(
                "branch", source, source.branches, source.branchIds, emptyNodeHash, roots, observer,
                func(node *BranchNode) (common.Hash, error) </span><span class="cov8" title="1">{ return hash(node) }</span>,
                func(node *BranchNode) (common.Hash, bool) <span class="cov8" title="1">{ return node.GetHash() }</span>,
                func(node Node) (bool, error) <span class="cov8" title="1">{ return hasher.isEmbedded(node, source) }</span>,
                func(id NodeId) bool <span class="cov8" title="1">{ return id.IsBranch() }</span>,
                func(node *BranchNode, hashes map[NodeId]common.Hash, embedded map[NodeId]bool) <span class="cov8" title="1">{
                        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                                child := node.children[i]
                                if !child.Id().IsEmpty() &amp;&amp; embedded[child.Id()] </span><span class="cov0" title="0">{
                                        node.setEmbedded(byte(i), true)
                                }</span>
                                <span class="cov8" title="1">if child := node.children[i]; !node.isEmbedded(byte(i)) &amp;&amp; !child.Id().IsEmpty() </span><span class="cov8" title="1">{
                                        hash, found := hashes[child.Id()]
                                        if !found </span><span class="cov0" title="0">{
                                                panic(fmt.Sprintf("missing hash for %v\n", child.Id()))</span>
                                        }
                                        <span class="cov8" title="1">node.hashes[i] = hash</span>
                                }
                        }
                        <span class="cov8" title="1">node.dirtyHashes = 0</span>
                },
                func(node *BranchNode, ids *nodeIdCollection) <span class="cov8" title="1">{
                        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                                // ID may be an embedded child, it will be determined later while hashing
                                ids.Put(node.children[i].Id())
                        }</span>
                },
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = verifyHashes(
                "extension", source, source.extensions, source.extensionIds, emptyNodeHash, roots, observer,
                func(node *ExtensionNode) (common.Hash, error) </span><span class="cov8" title="1">{ return hash(node) }</span>,
                func(node *ExtensionNode) (common.Hash, bool) <span class="cov8" title="1">{ return node.GetHash() }</span>,
                func(node Node) (bool, error) <span class="cov8" title="1">{ return hasher.isEmbedded(node, source) }</span>,
                func(id NodeId) bool <span class="cov8" title="1">{ return id.IsExtension() }</span>,
                func(node *ExtensionNode, hashes map[NodeId]common.Hash, embedded map[NodeId]bool) <span class="cov8" title="1">{
                        node.nextHash = hashes[node.next.Id()]
                        node.nextHashDirty = false
                        node.nextIsEmbedded = embedded[node.next.Id()]
                }</span>,
                func(node *ExtensionNode, ids *nodeIdCollection) <span class="cov8" title="1">{
                        ids.Put(node.next.Id())
                }</span>,
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = verifyHashes(
                "value", source, source.values, source.valueIds, emptyNodeHash, roots, observer,
                func(node *ValueNode) (common.Hash, error) </span><span class="cov8" title="1">{ return hash(node) }</span>,
                func(node *ValueNode) (common.Hash, bool) <span class="cov8" title="1">{ return node.GetHash() }</span>,
                func(node Node) (bool, error) <span class="cov0" title="0">{ return hasher.isEmbedded(node, source) }</span>,
                func(id NodeId) bool <span class="cov8" title="1">{ return id.IsValue() }</span>,
                func(*ValueNode, map[NodeId]common.Hash, map[NodeId]bool) {<span class="cov8" title="1">}</span>,
                func(node *ValueNode, ids *nodeIdCollection) {<span class="cov8" title="1">}</span>,
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func verifyHashes[N any](
        name string,
        source *verificationNodeSource,
        stock stock.Stock[uint64, N],
        ids stock.IndexSet[uint64],
        hashOfEmptyNode common.Hash,
        roots []Root,
        observer VerificationObserver,
        hash func(*N) (common.Hash, error),
        readHash func(*N) (common.Hash, bool),
        isEmbedded func(Node) (bool, error),
        isNodeType func(NodeId) bool,
        fillInChildrenHashes func(*N, map[NodeId]common.Hash, map[NodeId]bool),
        collectChildrenIds func(*N, *nodeIdCollection),
) error <span class="cov8" title="1">{
        mode := source.getConfig().HashStorageLocation
        switch mode </span>{
        case HashStoredWithNode:<span class="cov8" title="1">
                return verifyHashesStoredWithNodes(name, source, stock, ids, hashOfEmptyNode, observer, hash, readHash, isEmbedded, fillInChildrenHashes, collectChildrenIds)</span>
        case HashStoredWithParent:<span class="cov8" title="1">
                return verifyHashesStoredWithParents(name, source, stock, ids, roots, observer, hash, isNodeType)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown hash storage location: %v", mode)</span>
        }
}

// nodeIdCollection is a struct that collects NodeIds.
// It allows for adding the IDs in the map so that duplicities are eliminated.
// It maintains an additional slice, which is used for exporting collected NodeIDs
// ordered.
// The slice is pre-allocated with the input capacity.
type nodeIdCollection struct {
        nodeIds     map[NodeId]struct{}
        nodeIdsKeys []NodeId
}

// newNodeIds creates a new NodeIDs collector.
// The input capacity is used for allocating a slice,
// which is used for exporting sorted and unique NodeIds.
func newNodeIds(capacity uint64) *nodeIdCollection <span class="cov8" title="1">{
        return &amp;nodeIdCollection{
                nodeIds:     make(map[NodeId]struct{}),
                nodeIdsKeys: make([]NodeId, 0, capacity),
        }
}</span>

// Put adds node ID into this structure if it is not present yet.
func (n *nodeIdCollection) Put(id NodeId) <span class="cov8" title="1">{
        n.nodeIds[id] = struct{}{}
}</span>

func (n *nodeIdCollection) Size() uint64 <span class="cov8" title="1">{
        return uint64(len(n.nodeIds))
}</span>

// DrainToOrderedKeys returns accumulated keys ordered.
// The accumulated keys are drained.
// It means that repeated call to this method will not return the same keys again.
// The returned slice is re-used for further calls of this method to save on memory allocations.
func (n *nodeIdCollection) DrainToOrderedKeys() []NodeId <span class="cov8" title="1">{
        n.nodeIdsKeys = n.nodeIdsKeys[0:0]
        // collect keys ...
        for id := range n.nodeIds </span><span class="cov8" title="1">{
                n.nodeIdsKeys = append(n.nodeIdsKeys, id)
        }</span>
        <span class="cov8" title="1">n.nodeIds = make(map[NodeId]struct{}) // remove items to save space

        // ... and sort
        sort.Slice(n.nodeIdsKeys, func(i, j int) bool </span><span class="cov8" title="1">{
                return n.nodeIdsKeys[i] &lt; n.nodeIdsKeys[j]
        }</span>)

        <span class="cov8" title="1">return n.nodeIdsKeys</span>
}

// loadNodeHashes loads hashes of nodes from the input map nodeIdCollection.
// This method optimizes I/O access and memory.
// For this reason, it collects all nodeIdCollection from the input map and copies then to a slice, which is sorted.
// The nodes to be hashed are loaded in sequence then using the sorted slice.
// To save memory, this method clears the input map while coping the keys into the slice.
// It means that the map content cannot be used after this method executes.
// Furthermore, the slice for storing map keys is passes as the input.
// It must be an empty slice, but it can be re-used for multiple calls of this method.
// This method returns hashed nodes for the input ID and a map with embedded node IDs.
func loadNodeHashes(
        nodeIds *nodeIdCollection,
        source *verificationNodeSource,
        isEmbedded func(Node) (bool, error),
        hashOfEmptyNode common.Hash,
) (map[NodeId]common.Hash, map[NodeId]bool, error) <span class="cov8" title="1">{
        nodeIdsKeys := nodeIds.DrainToOrderedKeys()
        // Load hashes from disk
        hashes := make(map[NodeId]common.Hash, len(nodeIdsKeys)+1)
        hashes[EmptyId()] = hashOfEmptyNode
        embedded := map[NodeId]bool{}
        for _, id := range nodeIdsKeys </span><span class="cov8" title="1">{
                var node Node
                if id.IsBranch() </span><span class="cov8" title="1">{
                        n, err := source.branches.Get(id.Index())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;n</span>
                } else<span class="cov8" title="1"> if id.IsValue() </span><span class="cov8" title="1">{
                        n, err := source.values.Get(id.Index())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;n</span>
                } else<span class="cov8" title="1"> if id.IsAccount() </span><span class="cov8" title="1">{
                        n, err := source.accounts.Get(id.Index())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;n</span>
                } else<span class="cov8" title="1"> if id.IsExtension() </span><span class="cov8" title="1">{
                        n, err := source.extensions.Get(id.Index())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">node = &amp;n</span>
                }

                <span class="cov8" title="1">if !id.IsEmpty() </span><span class="cov8" title="1">{
                        hash, dirty := node.GetHash()
                        if dirty </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("encountered dirty hash on disk for node %v", id)
                        }</span>
                        <span class="cov8" title="1">hashes[id] = hash
                        if res, err := isEmbedded(node); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span> else<span class="cov8" title="1"> if res </span><span class="cov0" title="0">{
                                embedded[id] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return hashes, embedded, nil</span>
}

// getBatchSize gets the size of batch used for a list of items stored in memory.
// It is computed as 80% of the main memory divided by the input item size.
func getBatchSize(itemSize uint) uint64 <span class="cov8" title="1">{
        return uint64(float64(memory.TotalMemory()) * 0.8 / float64(itemSize))
}</span>

func verifyHashesStoredWithNodes[N any](
        name string,
        source *verificationNodeSource,
        stock stock.Stock[uint64, N],
        ids stock.IndexSet[uint64],
        hashOfEmptyNode common.Hash,
        observer VerificationObserver,
        hash func(*N) (common.Hash, error),
        readHash func(*N) (common.Hash, bool),
        isEmbedded func(Node) (bool, error),
        fillInChildrenHashes func(*N, map[NodeId]common.Hash, map[NodeId]bool),
        collectChildrenIds func(*N, *nodeIdCollection),
) error <span class="cov8" title="1">{
        batchSize := getBatchSize(150) // empirically determined item size

        // re-used for each loop to save on allocations
        referencedIds := newNodeIds(batchSize / 3) // pre-allocate only a fraction of the capacity to prevent huge allocations and GC when not the whole batch is used.

        // check other nodes
        lowerBound := ids.GetLowerBound()
        upperBound := ids.GetLowerBound()
        var batchNum int

        for upperBound &lt; ids.GetUpperBound() </span><span class="cov8" title="1">{
                batchNum++
                // First step -- loop to collect Ids of node children
                // The number of child references determines the size of this batch
                // because some nodes like Branch can have many children while other nodes like Extension has just one or Value has none.
                observer.Progress(fmt.Sprintf("Getting refeences to children for %ss (batch %d, size: %d)...", name, batchNum, batchSize))
                for referencedIds.Size() &lt; batchSize &amp;&amp; upperBound &lt; ids.GetUpperBound() </span><span class="cov8" title="1">{
                        if !ids.Contains(upperBound) </span><span class="cov8" title="1">{
                                upperBound++
                                continue</span>
                        }
                        <span class="cov8" title="1">node, err := stock.Get(upperBound)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">collectChildrenIds(&amp;node, referencedIds)
                        upperBound++</span>
                }

                // Second step - sort IDs and load hashes from the disk
                <span class="cov8" title="1">observer.Progress(fmt.Sprintf("Loading %d child hashes for %ss (batch %d, size: %d)...", referencedIds.Size(), name, batchNum, batchSize))
                hashes, embedded, err := loadNodeHashes(referencedIds, source, isEmbedded, hashOfEmptyNode)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Third step - read again the nodes, fill-in collected child hashes, compare hashes
                <span class="cov8" title="1">observer.Progress(fmt.Sprintf("Checking hashes of up to %d %ss (batch %d, size: %d)...", upperBound-lowerBound, name, batchNum, batchSize))
                for i := lowerBound; i &lt; upperBound; i++ </span><span class="cov8" title="1">{
                        if !ids.Contains(i) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">node, err := stock.Get(i)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">fillInChildrenHashes(&amp;node, hashes, embedded)
                        want, err := hash(&amp;node)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">got, dirty := readHash(&amp;node)
                        if dirty </span><span class="cov0" title="0">{
                                return fmt.Errorf("encountered dirty hash for node: %v", i)
                        }</span>

                        <span class="cov8" title="1">if got != want </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid hash stored for node %v, want %v, got %v", i, want, got)
                        }</span>
                }

                <span class="cov8" title="1">lowerBound = upperBound</span> // move to next window
        }

        <span class="cov8" title="1">return nil</span>
}

func verifyHashesStoredWithParents[N any](
        name string,
        source *verificationNodeSource,
        stock stock.Stock[uint64, N],
        ids stock.IndexSet[uint64],
        roots []Root,
        observer VerificationObserver,
        hash func(*N) (common.Hash, error),
        isNodeType func(NodeId) bool,
) error <span class="cov8" title="1">{
        batchSize := getBatchSize(32) // a batch stores 32byte hashes
        // Load nodes of current type from disk
        for batch := ids.GetLowerBound(); batch &lt; ids.GetUpperBound(); batch += batchSize </span><span class="cov8" title="1">{
                lowerBound := batch
                upperBound := batch + batchSize
                if upperBound &gt; ids.GetUpperBound() </span><span class="cov8" title="1">{
                        upperBound = ids.GetUpperBound()
                }</span>

                <span class="cov8" title="1">observer.Progress(fmt.Sprintf("Hashing up to %d %ss (batch %d of %d)...", upperBound-lowerBound, name, batch/batchSize+1, ids.GetUpperBound()/batchSize+1))
                hashes := make([]common.Hash, upperBound-lowerBound)
                for i := lowerBound; i &lt; upperBound; i++ </span><span class="cov8" title="1">{
                        if ids.Contains(i) </span><span class="cov8" title="1">{
                                node, err := stock.Get(i)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">h, err := hash(&amp;node)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">hashes[i-lowerBound] = h</span>
                        }
                }

                // Check hashes of roots.
                <span class="cov8" title="1">checkNodeHash := func(id NodeId, hash common.Hash) error </span><span class="cov8" title="1">{
                        if !isNodeType(id) || id.Index() &lt; lowerBound || id.Index() &gt;= upperBound </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">want := hashes[id.Index()-lowerBound]
                        if hash == want </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("inconsistent hash for node %v, want %v, got %v", id, want, hash)</span>
                }

                <span class="cov8" title="1">for _, root := range roots </span><span class="cov8" title="1">{
                        if err := checkNodeHash(root.NodeRef.Id(), root.Hash); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                // Check that all nodes referencing other nodes use the right hashes.
                <span class="cov8" title="1">checkContainedHashes := func(node Node) error </span><span class="cov8" title="1">{
                        switch n := node.(type) </span>{
                        case *AccountNode:<span class="cov8" title="1">
                                return checkNodeHash(n.storage.Id(), n.storageHash)</span>
                        case *ExtensionNode:<span class="cov8" title="1">
                                if !n.nextIsEmbedded </span><span class="cov8" title="1">{
                                        return checkNodeHash(n.next.Id(), n.nextHash)
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        case *BranchNode:<span class="cov8" title="1">
                                </span><span class="cov8" title="1">{
                                        errs := []error{}
                                        for i := 0; i &lt; len(n.children); i++ </span><span class="cov8" title="1">{
                                                if !n.isEmbedded(byte(i)) </span><span class="cov8" title="1">{
                                                        if err := checkNodeHash(n.children[i].Id(), n.hashes[i]); err != nil </span><span class="cov8" title="1">{
                                                                errs = append(errs, err)
                                                        }</span>
                                                }
                                        }
                                        <span class="cov8" title="1">return errors.Join(errs...)</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov8" title="1">observer.Progress(fmt.Sprintf("Checking hash references of up to %d %ss ...", upperBound-lowerBound, name))
                if err := source.forAllInnerNodes(checkContainedHashes); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// verifyContractCodes runs list of validation checks on accounts and on the
// code file stored in the given directory. These checks include:
// 1) Fatal checks
// - All CodeHashes within accounts are present in the code file
// - All CodeHashes within the code file are correct matching the contract byte-codes
// 2) Non-fatal checks
// - There are no extra Code Hashes not referenced by any account
func verifyContractCodes(directory string, source *verificationNodeSource, observer VerificationObserver) error <span class="cov8" title="1">{
        observer.Progress(fmt.Sprintf("Checking contract codes ..."))

        codeFile := filepath.Join(directory, "codes.dat")
        codes, err := readCodes(codeFile)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Check that the codes are correctly indexed.
        <span class="cov8" title="1">for hash, code := range codes </span><span class="cov8" title="1">{
                if got, want := common.Keccak256(code), hash; got != want </span><span class="cov8" title="1">{
                        return fmt.Errorf("unexpected code hash, got: %x want: %x", got, want)
                }</span>
        }
        // Check that all referenced codes are present in the code file.
        <span class="cov8" title="1">usedHashes := make(map[common.Hash]struct{})
        err = source.forAccountNodes(func(acc *AccountNode) error </span><span class="cov8" title="1">{
                codeHash := acc.info.CodeHash
                usedHashes[codeHash] = struct{}{}
                if _, exists := codes[codeHash]; codeHash != emptyCodeHash &amp;&amp; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("hash %x is missing in code file", codeHash)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        // find any extra hashes
        <span class="cov8" title="1">for hash := range codes </span><span class="cov8" title="1">{
                if _, exists := usedHashes[hash]; !exists </span><span class="cov8" title="1">{
                        observer.Progress(fmt.Sprintf("Contract %x is not referenced by any account\n", hash))
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

type verificationNodeSource struct {
        config MptConfig

        // The lock guaranteeing exclusive access to the data directory.
        lock      common.LockFile
        directory string

        // The stock containers managing individual node types.
        branches   stock.Stock[uint64, BranchNode]
        extensions stock.Stock[uint64, ExtensionNode]
        accounts   stock.Stock[uint64, AccountNode]
        values     stock.Stock[uint64, ValueNode]

        // The sets of valid IDs of each type.
        accountIds   stock.IndexSet[uint64]
        branchIds    stock.IndexSet[uint64]
        extensionIds stock.IndexSet[uint64]
        valueIds     stock.IndexSet[uint64]

        // A custom pair of node ID and Node to be overwritten for node resolution.
        overwriteId   NodeId
        overwriteNode Node
}

func openVerificationNodeSource(directory string, config MptConfig) (*verificationNodeSource, error) <span class="cov8" title="1">{
        lock, err := openStateDirectory(directory)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">success := false
        accountEncoder, branchEncoder, extensionEncoder, valueEncoder := getEncoder(config)
        branches, err := file.OpenStock[uint64, BranchNode](branchEncoder, directory+"/branches")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if !success </span><span class="cov8" title="1">{
                        branches.Close()
                }</span>
        }()
        <span class="cov8" title="1">extensions, err := file.OpenStock[uint64, ExtensionNode](extensionEncoder, directory+"/extensions")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if !success </span><span class="cov8" title="1">{
                        extensions.Close()
                }</span>
        }()
        <span class="cov8" title="1">accounts, err := file.OpenStock[uint64, AccountNode](accountEncoder, directory+"/accounts")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if !success </span><span class="cov8" title="1">{
                        accounts.Close()
                }</span>
        }()
        <span class="cov8" title="1">values, err := file.OpenStock[uint64, ValueNode](valueEncoder, directory+"/values")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if !success </span><span class="cov0" title="0">{
                        values.Close()
                }</span>
        }()
        <span class="cov8" title="1">accountIds, err := accounts.GetIds()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">branchIds, err := branches.GetIds()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">extensionIds, err := extensions.GetIds()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">valueIds, err := values.GetIds()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">success = true
        return &amp;verificationNodeSource{
                config:       config,
                lock:         lock,
                directory:    directory,
                accounts:     accounts,
                branches:     branches,
                extensions:   extensions,
                values:       values,
                accountIds:   accountIds,
                branchIds:    branchIds,
                extensionIds: extensionIds,
                valueIds:     valueIds,
        }, nil</span>
}

func (s *verificationNodeSource) getConfig() MptConfig <span class="cov8" title="1">{
        return s.config
}</span>

func (s *verificationNodeSource) getShared(id NodeId) (*shared.Shared[Node], error) <span class="cov8" title="1">{
        var node Node
        var err error
        if s.overwriteId == id &amp;&amp; s.overwriteNode != nil </span><span class="cov8" title="1">{
                node = s.overwriteNode
        }</span> else<span class="cov8" title="1"> if id.IsEmpty() </span><span class="cov0" title="0">{
                node, err = EmptyNode{}, nil
        }</span> else<span class="cov8" title="1"> if id.IsAccount() </span><span class="cov8" title="1">{
                account, e := s.accounts.Get(id.Index())
                node, err = &amp;account, e
        }</span> else<span class="cov8" title="1"> if id.IsBranch() </span><span class="cov8" title="1">{
                branch, e := s.branches.Get(id.Index())
                node, err = &amp;branch, e
        }</span> else<span class="cov8" title="1"> if id.IsExtension() </span><span class="cov0" title="0">{
                ext, e := s.extensions.Get(id.Index())
                node, err = &amp;ext, e
        }</span> else<span class="cov8" title="1"> if id.IsValue() </span><span class="cov8" title="1">{
                value, e := s.values.Get(id.Index())
                node, err = &amp;value, e
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return shared.MakeShared[Node](node), nil</span>
}

func (s *verificationNodeSource) getReadAccess(ref *NodeReference) (shared.ReadHandle[Node], error) <span class="cov0" title="0">{
        node, err := s.getShared(ref.Id())
        if err != nil </span><span class="cov0" title="0">{
                return shared.ReadHandle[Node]{}, err
        }</span>
        <span class="cov0" title="0">return node.GetReadHandle(), nil</span>
}

func (s *verificationNodeSource) getViewAccess(ref *NodeReference) (shared.ViewHandle[Node], error) <span class="cov8" title="1">{
        node, err := s.getShared(ref.Id())
        if err != nil </span><span class="cov0" title="0">{
                return shared.ViewHandle[Node]{}, err
        }</span>
        <span class="cov8" title="1">return node.GetViewHandle(), nil</span>
}

func (s *verificationNodeSource) getHashFor(*NodeReference) (common.Hash, error) <span class="cov0" title="0">{
        panic("hash resolution not supported")</span>
}

func (s *verificationNodeSource) hashKey(key common.Key) common.Hash <span class="cov8" title="1">{
        return common.Keccak256(key[:])
}</span>

func (s *verificationNodeSource) hashAddress(address common.Address) common.Hash <span class="cov8" title="1">{
        return common.Keccak256(address[:])
}</span>

func (s *verificationNodeSource) Close() error <span class="cov8" title="1">{
        err := errors.Join(
                s.accounts.Close(),
                s.branches.Close(),
                s.extensions.Close(),
                s.values.Close(),
        )
        if err == nil </span><span class="cov8" title="1">{
                err = markClean(s.directory)
        }</span>
        <span class="cov8" title="1">return errors.Join(
                err,
                s.lock.Release(),
        )</span>
}

func (s *verificationNodeSource) isValid(id NodeId) bool <span class="cov8" title="1">{
        if id.IsEmpty() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if id.IsAccount() </span><span class="cov8" title="1">{
                return s.accountIds.Contains(id.Index())
        }</span>
        <span class="cov8" title="1">if id.IsBranch() </span><span class="cov8" title="1">{
                return s.branchIds.Contains(id.Index())
        }</span>
        <span class="cov8" title="1">if id.IsExtension() </span><span class="cov8" title="1">{
                return s.extensionIds.Contains(id.Index())
        }</span>
        <span class="cov8" title="1">if id.IsValue() </span><span class="cov8" title="1">{
                return s.valueIds.Contains(id.Index())
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *verificationNodeSource) setNodeOverride(id NodeId, node Node) <span class="cov8" title="1">{
        s.overwriteId = id
        s.overwriteNode = node
}</span>

func (s *verificationNodeSource) clearOverride() <span class="cov8" title="1">{
        s.overwriteNode = nil
}</span>

func (s *verificationNodeSource) forAllInnerNodes(check func(Node) error) error <span class="cov8" title="1">{
        return s.forNodes(func(_ NodeId, node Node) error </span><span class="cov8" title="1">{ return check(node) }</span>, true, true, true, false)
}

func (s *verificationNodeSource) forAllNodes(check func(NodeId, Node) error) error <span class="cov8" title="1">{
        return s.forNodes(check, true, true, true, true)
}</span>

func (s *verificationNodeSource) forAccountNodes(check func(*AccountNode) error) error <span class="cov8" title="1">{
        var errs []error

        for i := s.accountIds.GetLowerBound(); i &lt; s.accountIds.GetUpperBound(); i++ </span><span class="cov8" title="1">{
                if s.accountIds.Contains(i) </span><span class="cov8" title="1">{
                        account, err := s.accounts.Get(i)
                        if err != nil </span><span class="cov0" title="0">{ // with IO errors =&gt; stop immediately
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := check(&amp;account); err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors.Join(errs...)</span>
}

func (s *verificationNodeSource) forNodes(
        check func(NodeId, Node) error,
        branches, extensions, accounts, values bool,
) error <span class="cov8" title="1">{
        errs := []error{}
        if branches </span><span class="cov8" title="1">{
                for i := s.branchIds.GetLowerBound(); i &lt; s.branchIds.GetUpperBound(); i++ </span><span class="cov8" title="1">{
                        if s.branchIds.Contains(i) </span><span class="cov8" title="1">{
                                branch, err := s.branches.Get(i)
                                if err != nil </span><span class="cov0" title="0">{ // with IO errors =&gt; stop immediately
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := check(BranchId(i), &amp;branch); err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if extensions </span><span class="cov8" title="1">{
                for i := s.extensionIds.GetLowerBound(); i &lt; s.extensionIds.GetUpperBound(); i++ </span><span class="cov8" title="1">{
                        if s.extensionIds.Contains(i) </span><span class="cov8" title="1">{
                                extension, err := s.extensions.Get(i)
                                if err != nil </span><span class="cov0" title="0">{ // with IO errors =&gt; stop immediately
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := check(ExtensionId(i), &amp;extension); err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if accounts </span><span class="cov8" title="1">{
                for i := s.accountIds.GetLowerBound(); i &lt; s.accountIds.GetUpperBound(); i++ </span><span class="cov8" title="1">{
                        if s.accountIds.Contains(i) </span><span class="cov8" title="1">{
                                account, err := s.accounts.Get(i)
                                if err != nil </span><span class="cov0" title="0">{ // with IO errors =&gt; stop immediately
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := check(AccountId(i), &amp;account); err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if values </span><span class="cov8" title="1">{
                for i := s.valueIds.GetLowerBound(); i &lt; s.valueIds.GetUpperBound(); i++ </span><span class="cov8" title="1">{
                        if s.valueIds.Contains(i) </span><span class="cov8" title="1">{
                                value, err := s.values.Get(i)
                                if err != nil </span><span class="cov0" title="0">{ // with IO errors =&gt; stop immediately
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := check(ValueId(i), &amp;value); err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, err)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return errors.Join(errs...)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: verification.go
//
// Generated by this command:
//
//        mockgen -source verification.go -destination verification_mocks.go -package mpt
//

// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockVerificationObserver is a mock of VerificationObserver interface.
type MockVerificationObserver struct {
        ctrl     *gomock.Controller
        recorder *MockVerificationObserverMockRecorder
}

// MockVerificationObserverMockRecorder is the mock recorder for MockVerificationObserver.
type MockVerificationObserverMockRecorder struct {
        mock *MockVerificationObserver
}

// NewMockVerificationObserver creates a new mock instance.
func NewMockVerificationObserver(ctrl *gomock.Controller) *MockVerificationObserver <span class="cov8" title="1">{
        mock := &amp;MockVerificationObserver{ctrl: ctrl}
        mock.recorder = &amp;MockVerificationObserverMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVerificationObserver) EXPECT() *MockVerificationObserverMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// EndVerification mocks base method.
func (m *MockVerificationObserver) EndVerification(res error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "EndVerification", res)
}</span>

// EndVerification indicates an expected call of EndVerification.
func (mr *MockVerificationObserverMockRecorder) EndVerification(res any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndVerification", reflect.TypeOf((*MockVerificationObserver)(nil).EndVerification), res)
}</span>

// Progress mocks base method.
func (m *MockVerificationObserver) Progress(msg string) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Progress", msg)
}</span>

// Progress indicates an expected call of Progress.
func (mr *MockVerificationObserverMockRecorder) Progress(msg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Progress", reflect.TypeOf((*MockVerificationObserver)(nil).Progress), msg)
}</span>

// StartVerification mocks base method.
func (m *MockVerificationObserver) StartVerification() <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "StartVerification")
}</span>

// StartVerification indicates an expected call of StartVerification.
func (mr *MockVerificationObserverMockRecorder) StartVerification() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartVerification", reflect.TypeOf((*MockVerificationObserver)(nil).StartVerification))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

//go:generate mockgen -source visitor.go -destination visitor_mocks.go -package mpt

import (
        "fmt"
        "github.com/Fantom-foundation/Carmen/go/common/tribool"
        "strings"
)

// ----------------------------------------------------------------------------
//                            Visitor Interface
// ----------------------------------------------------------------------------

// NodeVisitor defines an interface for any consumer interested in visiting a
// set of nodes of a Forest. It is intended for generic trie and
// forest analysis infrastructure.
type NodeVisitor interface {
        // Visit is called for each node. Through the response the visitor can
        // decide control the visiting process. It may be
        //  - continued: keep processing additional nodes
        //  - aborted: stop processing nodes and end node iteration
        //  - pruned: skip the child nodes of the current node and continue with
        //       the next node following the last descendent of the current node
        // While the first two options are supported in trees and forests, the
        // last one is only supported on trees.
        Visit(Node, NodeInfo) VisitResponse
}

type NodeInfo struct {
        Id       NodeId          // the ID of the visited node
        Depth    *int            // the nesting level of the visited node, only set for tree visits
        Embedded tribool.Tribool // true if this node is embedded in another node, tracked in visitPathTo
}

type VisitResponse int

const (
        VisitResponseContinue VisitResponse = 0
        VisitResponseAbort    VisitResponse = 1
        VisitResponsePrune    VisitResponse = 2
)

// VisitForestNodes load the nodes of the forest stored in the given directory and
// applies the visitor on each of those.
func VisitForestNodes(directory string, config MptConfig, visitor NodeVisitor) error <span class="cov8" title="1">{
        source, err := openVerificationNodeSource(directory, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer source.Close()
        return source.forAllNodes(func(id NodeId, node Node) error </span><span class="cov8" title="1">{
                visitor.Visit(node, NodeInfo{Id: id})
                return nil
        }</span>)
}

// ----------------------------------------------------------------------------
//                          Lambda Visitor
// ----------------------------------------------------------------------------

// MakeVisitor wraps a function into the node visitor interface.
func MakeVisitor(visit func(Node, NodeInfo) VisitResponse) NodeVisitor <span class="cov8" title="1">{
        return &amp;lambdaVisitor{visit}
}</span>

type lambdaVisitor struct {
        visit func(Node, NodeInfo) VisitResponse
}

func (v *lambdaVisitor) Visit(n Node, i NodeInfo) VisitResponse <span class="cov8" title="1">{
        return v.visit(n, i)
}</span>

// ----------------------------------------------------------------------------
//                            Node Statistics
// ----------------------------------------------------------------------------

// GetTrieNodeStatistics computes node statistics for the given Trie.
func GetTrieNodeStatistics(trie *LiveTrie) (NodeStatistic, error) <span class="cov8" title="1">{
        collector := &amp;nodeStatisticsCollector{}
        if err := trie.VisitTrie(collector); err != nil </span><span class="cov0" title="0">{
                return NodeStatistic{}, err
        }</span>
        <span class="cov8" title="1">return collector.stats, nil</span>
}

// GetForestNodeStatistics computes node statistics for the MPT forest stored in
// the given directory.
func GetForestNodeStatistics(directory string, config MptConfig) (NodeStatistic, error) <span class="cov8" title="1">{
        collector := &amp;nodeStatisticsCollector{}
        if err := VisitForestNodes(directory, config, collector); err != nil </span><span class="cov0" title="0">{
                return NodeStatistic{}, err
        }</span>
        <span class="cov8" title="1">return collector.stats, nil</span>
}

type NodeStatistic struct {
        numBranches   int
        numAccounts   int
        numValues     int
        numExtensions int

        numChildren [17]int

        depths []int
}

func (s *NodeStatistic) String() string <span class="cov0" title="0">{
        builder := strings.Builder{}

        builder.WriteString("Node types:\n")
        builder.WriteString(fmt.Sprintf("Accounts, %d\n", s.numAccounts))
        builder.WriteString(fmt.Sprintf("Branches, %d\n", s.numBranches))
        builder.WriteString(fmt.Sprintf("Extensions, %d\n", s.numExtensions))
        builder.WriteString(fmt.Sprintf("Values, %d\n", s.numValues))

        builder.WriteString("Branch-Node-Size Distribution:\n")
        for i, count := range s.numChildren </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("%d, %d\n", i, count))
        }</span>

        <span class="cov0" title="0">if len(s.depths) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString("Node depth distribution:\n")
                for i, count := range s.depths </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("%d, %d\n", i, count))
                }</span>
        }

        <span class="cov0" title="0">return builder.String()</span>
}

type nodeStatisticsCollector struct {
        stats NodeStatistic
}

func (c *nodeStatisticsCollector) Visit(node Node, info NodeInfo) VisitResponse <span class="cov8" title="1">{
        c.registerDepth(info)
        switch t := node.(type) </span>{
        case *AccountNode:<span class="cov8" title="1">
                c.stats.numAccounts++</span>
        case *BranchNode:<span class="cov8" title="1">
                c.visitBranch(t, info)</span>
        case *ExtensionNode:<span class="cov8" title="1">
                c.stats.numExtensions++</span>
        case *ValueNode:<span class="cov8" title="1">
                c.stats.numValues++</span>
        }
        <span class="cov8" title="1">return VisitResponseContinue</span>
}

func (c *nodeStatisticsCollector) visitBranch(b *BranchNode, info NodeInfo) <span class="cov8" title="1">{
        c.stats.numBranches++
        numChildren := 0
        for _, child := range b.children </span><span class="cov8" title="1">{
                if !child.Id().IsEmpty() </span><span class="cov8" title="1">{
                        numChildren++
                }</span>
        }
        <span class="cov8" title="1">c.stats.numChildren[numChildren]++</span>
}

func (c *nodeStatisticsCollector) registerDepth(info NodeInfo) <span class="cov8" title="1">{
        if info.Depth == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for len(c.stats.depths) &lt;= *info.Depth </span><span class="cov8" title="1">{
                c.stats.depths = append(c.stats.depths, 0)
        }</span>
        <span class="cov8" title="1">c.stats.depths[*info.Depth]++</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: visitor.go
//
// Generated by this command:
//
//        mockgen -source visitor.go -destination visitor_mocks.go -package mpt
//

// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockNodeVisitor is a mock of NodeVisitor interface.
type MockNodeVisitor struct {
        ctrl     *gomock.Controller
        recorder *MockNodeVisitorMockRecorder
}

// MockNodeVisitorMockRecorder is the mock recorder for MockNodeVisitor.
type MockNodeVisitorMockRecorder struct {
        mock *MockNodeVisitor
}

// NewMockNodeVisitor creates a new mock instance.
func NewMockNodeVisitor(ctrl *gomock.Controller) *MockNodeVisitor <span class="cov8" title="1">{
        mock := &amp;MockNodeVisitor{ctrl: ctrl}
        mock.recorder = &amp;MockNodeVisitorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNodeVisitor) EXPECT() *MockNodeVisitorMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Visit mocks base method.
func (m *MockNodeVisitor) Visit(arg0 Node, arg1 NodeInfo) VisitResponse <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Visit", arg0, arg1)
        ret0, _ := ret[0].(VisitResponse)
        return ret0
}</span>

// Visit indicates an expected call of Visit.
func (mr *MockNodeVisitorMockRecorder) Visit(arg0, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Visit", reflect.TypeOf((*MockNodeVisitor)(nil).Visit), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

package mpt

//go:generate mockgen -source write_buffer.go -destination write_buffer_mocks.go -package mpt

import (
        "errors"
        "runtime"
        "sort"
        "sync"

        "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
)

// ----------------------------------------------------------------------------
//                             Interfaces
// ----------------------------------------------------------------------------

// WriteBuffer is a utility buffering the flushing of nodes to some
// node sink. Its main task is to perform writes asynchronously in a
// managed background thread, queuing nodes to be written to the sink
// in an internal buffer.
type WriteBuffer interface {
        // Add adds the given node to the queue of nodes to be written to
        // the underlying sink. The timing and order of those write operations
        // is undefined. The only guarantee is that they may happen eventually
        // in an arbitrary order.
        Add(NodeId, *shared.Shared[Node])
        // Cancel aborts the flushing of the node with the given ID and returns
        // the node back to the caller. If present, the node is removed from the
        // buffer and no longer flushed. If no such node is present, (nil,false)
        // is returned.
        Cancel(NodeId) (*shared.Shared[Node], bool)
        // Flush forces all buffered elements to be written to the sink.
        Flush() error
        // Close flushes buffered elements and stops asynchronous operations.
        Close() error
}

// NodeSink defines an interface for where WriteBuffers are able to write
// node information to.
type NodeSink interface {
        Write(NodeId, shared.ViewHandle[Node]) error
}

func MakeWriteBuffer(sink NodeSink) WriteBuffer <span class="cov8" title="1">{
        return makeWriteBuffer(sink, 1024)
}</span>

// ----------------------------------------------------------------------------
//                             Implementation
// ----------------------------------------------------------------------------

type writeBuffer struct {
        sink                    NodeSink
        capacity                int
        counter                 int
        buffer                  map[NodeId]*shared.Shared[Node]
        bufferMutex             sync.Mutex
        emptyBufferSignal       chan bool // true if an explicit flush is triggered, false for an implicit
        emptyBufferSignalMutex  sync.Mutex
        emptyBufferSignalClosed bool
        flushDone               &lt;-chan struct{}
        done                    &lt;-chan struct{}
        errs                    []error
        errsMutex               sync.Mutex
}

func makeWriteBuffer(sink NodeSink, capacity int) WriteBuffer <span class="cov8" title="1">{
        if capacity &lt; 1 </span><span class="cov8" title="1">{
                capacity = 1
        }</span>

        <span class="cov8" title="1">emptyBufferSignal := make(chan bool, 1)
        flushDone := make(chan struct{})
        done := make(chan struct{})

        res := &amp;writeBuffer{
                sink:              sink,
                capacity:          capacity,
                buffer:            make(map[NodeId]*shared.Shared[Node], 2*capacity),
                emptyBufferSignal: emptyBufferSignal,
                flushDone:         flushDone,
                done:              done,
        }

        // A background goroutine flushing nodes to the sink and handling
        // synchronization tasks.
        go func() </span><span class="cov8" title="1">{
                runtime.LockOSThread()
                defer runtime.UnlockOSThread()
                defer close(done)
                defer close(flushDone)
                for flush := range emptyBufferSignal </span><span class="cov8" title="1">{
                        res.emptyBuffer()
                        if flush </span><span class="cov8" title="1">{
                                flushDone &lt;- struct{}{}
                        }</span>
                }
        }()

        <span class="cov8" title="1">return res</span>
}

func (b *writeBuffer) Add(id NodeId, node *shared.Shared[Node]) <span class="cov8" title="1">{
        // Empty nodes are ignored (and internally used for signaling flush requests).
        if id.IsEmpty() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">b.bufferMutex.Lock()
        b.buffer[id] = node
        b.bufferMutex.Unlock()
        b.emptyBufferSignalMutex.Lock()
        b.counter++
        if b.counter &gt; b.capacity &amp;&amp; !b.emptyBufferSignalClosed </span><span class="cov8" title="1">{
                // The option to ignore a full signal channel here is important
                // to prevent a potential deadlock. See
                // https://github.com/Fantom-foundation/Carmen/issues/724
                // for more details.
                select </span>{
                case b.emptyBufferSignal &lt;- false:<span class="cov8" title="1"></span> /* ok, a new clear-buffer operation is scheduled */
                default:<span class="cov8" title="1"></span> /* also fine, an operation to clear the buffer is already pending */
                }
                <span class="cov8" title="1">b.counter = 0</span>
        }
        <span class="cov8" title="1">b.emptyBufferSignalMutex.Unlock()</span>
}

func (b *writeBuffer) contains(id NodeId) bool <span class="cov8" title="1">{
        b.bufferMutex.Lock()
        defer b.bufferMutex.Unlock()
        _, found := b.buffer[id]
        return found
}</span>

func (b *writeBuffer) Cancel(id NodeId) (*shared.Shared[Node], bool) <span class="cov8" title="1">{
        b.bufferMutex.Lock()
        defer b.bufferMutex.Unlock()

        if res, found := b.buffer[id]; found </span><span class="cov8" title="1">{
                delete(b.buffer, id)
                return res, found
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}

func (b *writeBuffer) Flush() error <span class="cov8" title="1">{
        b.emptyBufferSignalMutex.Lock()
        if !b.emptyBufferSignalClosed </span><span class="cov8" title="1">{
                b.emptyBufferSignal &lt;- true
        }</span>
        <span class="cov8" title="1">b.emptyBufferSignalMutex.Unlock()
        &lt;-b.flushDone // finishes either due to flush signal or being closed
        b.errsMutex.Lock()
        defer b.errsMutex.Unlock()
        return errors.Join(b.errs...)</span>
}

func (b *writeBuffer) Close() error <span class="cov8" title="1">{
        b.emptyBufferSignalMutex.Lock()
        if !b.emptyBufferSignalClosed </span><span class="cov8" title="1">{
                close(b.emptyBufferSignal)
                b.emptyBufferSignalClosed = true
        }</span>
        <span class="cov8" title="1">b.emptyBufferSignalMutex.Unlock()
        &lt;-b.done // finishes once all elements are written
        b.errsMutex.Lock()
        defer b.errsMutex.Unlock()
        return errors.Join(b.errs...)</span>
}

func (b *writeBuffer) emptyBuffer() <span class="cov8" title="1">{

        // Collect a list of all IDs in the buffer.
        ids := make([]NodeId, 0, 2*b.capacity)
        b.bufferMutex.Lock()
        for id := range b.buffer </span><span class="cov8" title="1">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="1">b.bufferMutex.Unlock()

        // Sort IDs to minimize disk seeks.
        sort.Slice(ids, func(i, j int) bool </span><span class="cov8" title="1">{ return ids[i] &lt; ids[j] }</span>)

        // Flush all nodes of current patch.
        <span class="cov8" title="1">for i := 0; i &lt; len(ids); i++ </span><span class="cov8" title="1">{
                id := ids[i]
                // Check whether the given node has not been canceled in the meantime.
                b.bufferMutex.Lock()
                node, found := b.buffer[id]
                if !found </span><span class="cov8" title="1">{
                        b.bufferMutex.Unlock()
                        continue</span>
                }

                // Write a snapshot of the node to the disk.
                <span class="cov8" title="1">handle := node.GetWriteHandle() // write access is needed to clear the dirty flag.

                // To prevent the current node from being restored from the buffer
                // and modified by another goroutine, we need to keep the buffer
                // lock until we have write access. Otherwise, we might hold
                // a node that has been modified, yet its hash has not yet been
                // updated. Such nodes can not be written to the disk.
                b.bufferMutex.Unlock()

                if handle.Get().IsDirty() </span><span class="cov8" title="1">{
                        if err := b.sink.Write(id, handle.AsViewHandle()); err != nil </span><span class="cov8" title="1">{
                                b.errsMutex.Lock()
                                b.errs = append(b.errs, err)
                                b.errsMutex.Unlock()
                        }</span> else<span class="cov8" title="1"> {
                                handle.Get().MarkClean()
                        }</span>
                }

                <span class="cov8" title="1">b.bufferMutex.Lock()
                delete(b.buffer, id)
                b.bufferMutex.Unlock()

                // Only release access of the node after it has been removed from
                // the buffer such that subsequent updates are not lost.
                handle.Release()</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) 2024 Fantom Foundation
//
// Use of this software is governed by the Business Source License included
// in the LICENSE file and at fantom.foundation/bsl11.
//
// Change Date: 2028-4-16
//
// On the date above, in accordance with the Business Source License, use of
// this software will be governed by the GNU Lesser General Public License v3.

// Code generated by MockGen. DO NOT EDIT.
// Source: write_buffer.go
//
// Generated by this command:
//
//        mockgen -source write_buffer.go -destination write_buffer_mocks.go -package mpt
//

// Package mpt is a generated GoMock package.
package mpt

import (
        reflect "reflect"

        shared "github.com/Fantom-foundation/Carmen/go/database/mpt/shared"
        gomock "go.uber.org/mock/gomock"
)

// MockWriteBuffer is a mock of WriteBuffer interface.
type MockWriteBuffer struct {
        ctrl     *gomock.Controller
        recorder *MockWriteBufferMockRecorder
}

// MockWriteBufferMockRecorder is the mock recorder for MockWriteBuffer.
type MockWriteBufferMockRecorder struct {
        mock *MockWriteBuffer
}

// NewMockWriteBuffer creates a new mock instance.
func NewMockWriteBuffer(ctrl *gomock.Controller) *MockWriteBuffer <span class="cov8" title="1">{
        mock := &amp;MockWriteBuffer{ctrl: ctrl}
        mock.recorder = &amp;MockWriteBufferMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriteBuffer) EXPECT() *MockWriteBufferMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Add mocks base method.
func (m *MockWriteBuffer) Add(arg0 NodeId, arg1 *shared.Shared[Node]) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Add", arg0, arg1)
}</span>

// Add indicates an expected call of Add.
func (mr *MockWriteBufferMockRecorder) Add(arg0, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockWriteBuffer)(nil).Add), arg0, arg1)
}</span>

// Cancel mocks base method.
func (m *MockWriteBuffer) Cancel(arg0 NodeId) (*shared.Shared[Node], bool) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Cancel", arg0)
        ret0, _ := ret[0].(*shared.Shared[Node])
        ret1, _ := ret[1].(bool)
        return ret0, ret1
}</span>

// Cancel indicates an expected call of Cancel.
func (mr *MockWriteBufferMockRecorder) Cancel(arg0 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockWriteBuffer)(nil).Cancel), arg0)
}</span>

// Close mocks base method.
func (m *MockWriteBuffer) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockWriteBufferMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockWriteBuffer)(nil).Close))
}</span>

// Flush mocks base method.
func (m *MockWriteBuffer) Flush() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Flush")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Flush indicates an expected call of Flush.
func (mr *MockWriteBufferMockRecorder) Flush() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockWriteBuffer)(nil).Flush))
}</span>

// MockNodeSink is a mock of NodeSink interface.
type MockNodeSink struct {
        ctrl     *gomock.Controller
        recorder *MockNodeSinkMockRecorder
}

// MockNodeSinkMockRecorder is the mock recorder for MockNodeSink.
type MockNodeSinkMockRecorder struct {
        mock *MockNodeSink
}

// NewMockNodeSink creates a new mock instance.
func NewMockNodeSink(ctrl *gomock.Controller) *MockNodeSink <span class="cov8" title="1">{
        mock := &amp;MockNodeSink{ctrl: ctrl}
        mock.recorder = &amp;MockNodeSinkMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNodeSink) EXPECT() *MockNodeSinkMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Write mocks base method.
func (m *MockNodeSink) Write(arg0 NodeId, arg1 shared.ViewHandle[Node]) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Write indicates an expected call of Write.
func (mr *MockNodeSinkMockRecorder) Write(arg0, arg1 any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockNodeSink)(nil).Write), arg0, arg1)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
